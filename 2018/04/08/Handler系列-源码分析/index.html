<!DOCTYPE HTML>
<html>
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="https://github.com/smartsean/smartsean.github.io">
    <!--SEO-->



<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->


<title>Handler系列---源码分析 | SmartSean的小站</title>


    <link rel="alternate" href="/atom.xml" title="SmartSean的小站" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.4/css/bootstrap.min.css?rev=3.3.4">
<link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
    <div class="hide">
    	<script src="https://s4.cnzz.com/z_stat.php?id=1263868967&web_id=1263868967" language="JavaScript"></script>
    </div>






    
</head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://7xpw2b.com1.z0.glb.clouddn.com/hexo-sinppet/img/banner2.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="">
            <img src="/img/avatar.jpg" alt="logo头像">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 仰望星空，脚踏实地。 </h2>
             
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only">Toggle navigation</span>
                    <i class="fa fa-bars"></i>
                    </span>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation"><a href="/"><i class="fa fa-fw "></i>首页</a>
                            </li>
                        
                            <li role="presentation"><a href="/categories/Android/"><i class="fa fa-fw "></i>Android</a>
                            </li>
                        
                            <li role="presentation"><a href="/categories/工具/"><i class="fa fa-fw "></i>工具</a>
                            </li>
                        
                            <li role="presentation"><a href="/categories/我/"><i class="fa fa-fw "></i>我</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Handler系列---源码分析">
            
	            Handler系列---源码分析
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <span>Android</span>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            Android
            
        </span>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">2018/04/08</span>
    </span>
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <p>[toc]</p>
<h1 id="Handler系列—源码分析"><a href="#Handler系列—源码分析" class="headerlink" title="Handler系列—源码分析"></a>Handler系列—源码分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在上篇文章<a href="https://blog.csdn.net/sean_css/article/details/79767180" target="_blank" rel="noopener">Handler系列—基本使用</a>中讲解了 Handler 的使用以及解决了在使用 Handler 中内存泄漏的问题。</p>
<p>对于我们程序员来说，面对一个知识点，我们不仅要知其然，还要知其所以然。</p>
<p>所以本篇文章主要讲下 Handler 的源码。</p>
<p>分析源码之前先来看下 Handler 的运行机制</p>
<h2 id="一、Handler-的运行机制"><a href="#一、Handler-的运行机制" class="headerlink" title="一、Handler 的运行机制"></a>一、Handler 的运行机制</h2><p>实际上 Android 中的消息机制主要指的就是 Handler 的运行机制。</p>
<p>Handler 的运行需要以下对象的支持：</p>
<ul>
<li>Message</li>
<li>MessageQueue</li>
<li>Loop</li>
<li>Handler</li>
</ul>
<h3 id="1-1-Message"><a href="#1-1-Message" class="headerlink" title="1.1 Message"></a>1.1 Message</h3><p>来看下 Android Api 中关于 Message 的定义：</p>
<p><img src="http://p2oza5z62.bkt.clouddn.com/2018-04-08-15224817580316.jpg" alt=""></p>
<p>可以看到，官方给出的定义是：</p>
<blockquote>
<p>定义和包含了一些能够发送给 Handler 的描述和任意数据的对象，这个对象包含两个额外的 int 类型的字段和一些额外的对象数据以便能够适应多种场景<br>虽然 Message 的构造方法是公共的，但是最好是通过 <code>Message.obtain()</code>方法或者<code>Handler.obtainMessage()</code>方法来获取 Message 对象</p>
</blockquote>
<p>笼统的来说，Message 其实就是 Android 中在不同线程中通信的载体，Message 对象中存储了我们不同线程间通信的数据。</p>
<h3 id="1-2-MessageQueue"><a href="#1-2-MessageQueue" class="headerlink" title="1.2 MessageQueue"></a>1.2 MessageQueue</h3><p>看下官方的介绍：<br><img src="http://p2oza5z62.bkt.clouddn.com/2018-04-08-15224824016583.jpg" alt=""></p>
<blockquote>
<p>保存了一个由 Looper 管理的消息列表，消息并不是直接被添加到 MessageQueue 中的，而是通过 Handler 和 Looper 的协作。<br>你可以通过 Looper 的myQueue() 方法获得 MessageQueue 对象。</p>
</blockquote>
<p>可以看到，MessageQueue 保存了线程间通信消息列表，他由 Handler 和 Looper 共同管理。本身是一种数据结构，存储了线程间通讯的信息。</p>
<h3 id="1-3-Looper"><a href="#1-3-Looper" class="headerlink" title="1.3 Looper"></a>1.3 Looper</h3><p>官方的介绍：<br><img src="http://p2oza5z62.bkt.clouddn.com/2018-04-08-15224828610466.jpg" alt=""></p>
<blockquote>
<p>Looper这个类通常为线程（Thread）用于运行一个消息循环，线程默认是没有和 Looper 相关的消息循环，通过执行 Looper.prepare() 去运行消息循环，然后执行 Looper.loop() 方法去处理 Message ，直到当前的消息循环停止。</p>
</blockquote>
<p>从官网的介绍我们可以看出来，Looper 通常是和线程相关的，用于在线程上开启一个消息循环（MessageQueue），然后不断的处理消息循环中的消息，一直到消息循环终止。</p>
<p>其实 Looper 主要有的两大功能：</p>
<ol>
<li>消息获取 ：通过循环 MessageQueue ，不断的取出里面的 Message，如果 MessageQueue中 没有 Message ，则阻塞。</li>
<li>消息分发：将取出的 Message 分发给 Handler 处理</li>
</ol>
<h3 id="1-4-Handler"><a href="#1-4-Handler" class="headerlink" title="1.4 Handler"></a>1.4 Handler</h3><p>依旧来看下官方描述：<br><img src="http://p2oza5z62.bkt.clouddn.com/2018-04-08-15224895265199.jpg" alt=""></p>
<blockquote>
<p>一个 Handler 允许你发送和处理在线程 MessageQueue 里面的 Message 或者 Runnable 对象。每个 Handler 实例都与单个线程和该线程的消息队列相关联。当你创建一个新的 Handler 对象时，它将和创建它的线程和该线程的消息队列相绑定，从此刻开始，它将发送消息和 Runnable 对象到和它绑定的 MessageQueue，并在它们从 MessageQueue 中出来时处理它们。</p>
</blockquote>
<p>官方已经说得很清楚了，Handler 对象可以发送和处理 MessageQueue 中的消息对象或者 Runnable 对象。并且一个 Handler 创建的时候，是要和当前所处的线程以及该线程中的 MessageQueue 相绑定的。也就是说一个 Handler 对象只能绑定一个线程。</p>
<h3 id="1-5-Message、MessageQueue、Looper、Handler的对象关系"><a href="#1-5-Message、MessageQueue、Looper、Handler的对象关系" class="headerlink" title="1.5 Message、MessageQueue、Looper、Handler的对象关系"></a>1.5 Message、MessageQueue、Looper、Handler的对象关系</h3><ol>
<li>MessageQueue 中存放的是 Message ，一个 MessageQueue 中有可以多个 Message，或者没有 Message（此时阻塞）</li>
<li>一个线程中有一个 Looper ，并且只有一个 MessageQueue ，Looper 去循环 MessageQueue，有消息就发给 Handler 处理。</li>
<li>一个 Handler 只能绑定一个 Looper，但是一个 Looper 可以和多个 Handler 相关联</li>
</ol>
<p>好了，Handler 源码分析里面的几个关键对象已经大体上说了一遍，下面就一起来看看源码，看看 Handler 是怎么工作的吧。</p>
<h2 id="二、Handler-源码分析"><a href="#二、Handler-源码分析" class="headerlink" title="二、Handler 源码分析"></a>二、Handler 源码分析</h2><h3 id="2-1-在子线程中创建-Handler"><a href="#2-1-在子线程中创建-Handler" class="headerlink" title="2.1 在子线程中创建 Handler"></a>2.1 在子线程中创建 Handler</h3><p>如果我们需要在子线程中创建 Handler ，需要如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        Handler threadHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        message.what = <span class="number">1</span>;</span><br><span class="line">        threadHandler.sendMessage(message);</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>主要分为三步</p>
<ol>
<li>创建 Looper： Looper.prepare();</li>
<li>创建 Handler：Handler threadHandler = new Handler()</li>
<li>Handler 发送消息</li>
<li>开启 Looper 循环</li>
</ol>
<h4 id="创建-Looper"><a href="#创建-Looper" class="headerlink" title="创建 Looper"></a>创建 Looper</h4><p>我们先从<code>Looper.prepare()</code>这里开始，prepare() 方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>prepare 方法的参数很明显，是否允许退出。</p>
<p>prepare 方法首先通过 sThreadLocal.get() 获取 Looper，如果当前线程中的 Looper 不为空，那么抛出异常，提示“每个线程只能有一个 Looper”</p>
<p>那么 sThreadLocal 是什么呢？我们看下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure>
<p>sThreadLocal 实际上就是 一个指定类型的 ThreadLocal 对象，那么 ThreadLocal 的作用是什么呢？</p>
<p>实际上 ThreadLocal 可以在不同的线程之中互不干扰地存储并提供数据，通过 ThreadLocal 可以轻松的存储、获取每个线程的 Looper，这样就保证了 一个线程只能有一个 Looper 对象。</p>
<p>这里不做过多的讲解，想了解更多的话，请去<a href="https://blog.csdn.net/singwhatiwanna/article/details/48350919" target="_blank" rel="noopener">这里</a></p>
<p>继续看关键代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sThreadLocal.set(new Looper(quitAllowed));</span><br></pre></td></tr></table></figure>
<p>把通过 new Looper(quitAllowed) 的方式得到的 Looper 对象，放入到 ThreadLocal<looper> 的实例 sThreadLocal.set 中，继续看下 Looper 的构造方法：</looper></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造方法里面新建了一个 MessageQueue 对象，然后把给当前的线程赋值给 mThread。最终返回一个 Looper 对象。<br>再来看下<code>sThreadLocal.set(new Looper(quitAllowed));</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过getMap() 方法得到当前线程的 ThreadLocalMap 对象 map，顾名思义， ThreadLocalMap 存储是一个关于 ThreadLocal 的 Map，里面的</p>
<ul>
<li>key 是 ThreadLocal 对象，</li>
<li>value 是 Object 对象。</li>
</ul>
<p>接着判断 map 对象是否为空：</p>
<ul>
<li>如果不为空，那么把传进来的 Looper 对象作为 value，把当前的 ThreadLocal 作为 key，存储到当前线程的 ThreadLocalMap 对象中，</li>
<li>如果为空，则新建一个  ThreadLocalMap 对象，把传进来的 Looper 对象作为 value，把当前的 ThreadLocal 作为 key，存储到当前线程的 ThreadLocalMap 对象中。</li>
</ul>
<p><strong>到此我们知道，我们新建了 Looper 对象后，是把当前线程的 ThreadLocal 和 Looper 对象建立映射关系，存储到  ThreadLocalMap 中的。</strong></p>
<p>接下来看下第二步：创建 Handler 对象</p>
<h4 id="创建-Handler-对象"><a href="#创建-Handler-对象" class="headerlink" title="创建 Handler 对象"></a>创建 Handler 对象</h4><p>分析代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Handler threadHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>首先看到，我们 new 出了一个 Handler 对象。来看下 Handler 的构造方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，无参构造方法调用有参构造方法，接下来看看有参构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查当前的类是否是匿名内部类、成员内部类或者是本地类，如果是的话，就打印 log 可能引起内存泄漏，鼠标悬浮的时候也会提示。</span></span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 Looper 对象</span></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 MessageQueue</span></span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    <span class="comment">// 参数赋值</span></span><br><span class="line">    mCallback = callback;</span><br><span class="line">    <span class="comment">// 参数赋值</span></span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先要检查当前的类名，如果是匿名内部类、成员内部类或者是本地类，则给出可能有内存泄漏的提示</p>
<p>我们先看下这行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mLooper = Looper.myLooper();</span><br></pre></td></tr></table></figure>
<p>这行代码的作用主要是获取当前线程的 mLooper 对象。</p>
<p>我们去<code>Looper.myMooper()</code> 里面看下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sThreadLocal 是不是很熟悉，前面在创建 Looper 的时候，已经把 Looper 和 ThreadLocal 作为映射关联起来，存储到 sThreadLocal 中了。</p>
<p>在这里调用了 sThreadLocal.get 的 get() 方法返回了创建 Looper 时存入 sThreadLocal 中的 Looper 对象。</p>
<p>再来具体看下 <code>sThreadLocal.get()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到首先通过 <code>Thread.currentThread()</code> 拿到了当前的线程对象 t，然后根据 getMap(t) 拿到 ThreadLocalMap 对象，</p>
<p>getMap(t) 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是返回当前线程的 t.threadLocals；</p>
<p>然后我们再通过 map 的 getEntry 方法拿到 ThreadLocalMap 的 Entry对象。那么这里的 ThreadLocalMap.Entry 里面存储的是什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">    <span class="keyword">super</span>(k);</span><br><span class="line">    value = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应我们这里就是：</p>
<ul>
<li>key 存储的是当前线程的 ThreadLocal 对象</li>
<li>value 存储的 Object 是就是我们的 Looper 对象。</li>
</ul>
<p>最后来说下 sThreadLocal.get() 的工作：</p>
<ol>
<li>当在 ThreadLocalMap 不为空的时候，就从中取出对应当前 ThreadLocal 的 Looper 对象</li>
<li>当在 ThreadLocalMap 为空的时候，执行 setInitialValue() 方法去创建一个新的 ThreadLocalMap 赋值给 threadLocals，并且返回给 Looper 对象。</li>
</ol>
<p>继续往下看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">        <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这行代码可以看出，我们在 new 出一个 Handler 对象的时候，必须先有 Looper 对象，否则就会抛出异常。所以这就是在子线程中使用 Handler 的时候，必须先执行prepare、创建Handler、loop的原因了。</p>
<p>下面的就比较简单了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 把创建 Looper 时创建的 MessageQueue 赋值给 mQueue</span><br><span class="line">mQueue = mLooper.mQueue;</span><br><span class="line">// 把传入的callback 赋值给 mCallback</span><br><span class="line">mCallback = callback;</span><br><span class="line">// 把传入的async 赋值给 mAsynchronous</span><br><span class="line">mAsynchronous = async;</span><br></pre></td></tr></table></figure>
<h4 id="Handler-发送消息"><a href="#Handler-发送消息" class="headerlink" title="Handler 发送消息"></a>Handler 发送消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message message = Message.obtain();</span><br><span class="line">message.what = 1;</span><br><span class="line">threadHandler.sendMessage(message);</span><br></pre></td></tr></table></figure>
<p>首先我们创建了一个 Message 对象，然后通过 Handler 的 sendMessage 方法把 Message 发送出去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendMessage(Message msg)</span><br><span class="line">&#123;</span><br><span class="line">    return sendMessageDelayed(msg, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)</span><br><span class="line">&#123;</span><br><span class="line">    if (delayMillis &lt; 0) &#123;</span><br><span class="line">        delayMillis = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    if (queue == null) &#123;</span><br><span class="line">        RuntimeException e = new RuntimeException(</span><br><span class="line">                this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">        Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">    msg.target = this;</span><br><span class="line">    if (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到 sendMessage 方法最终调用了 Handler 的 enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) 方法。</p>
<p>在 Handler 的 enqueueMessage 方法中：</p>
<p>通过 msg.target = this; 把 Message 的 target 属性设置为当前的 Handler，这样就把该消息和要处理该消息的 Handler 做了绑定。</p>
<p>然后调用 MessageQueue 的 enqueueMessage(msg, uptimeMillis) 方法将消息添加到 MessageQueue 队列中。</p>
<p>至此，我们只是把消息加入到了队列中，但是还不能通过 Handler 的 handleMessage(Message msg) 方法处理，因为我们只是把消息加入到了 MessageQueue 中，MessageQueue 只是一个队列，要用 Looper 不断的去从 MessageQueue 中取消息给 Handler 才能处理消息。</p>
<p>接下来就看最后一步，开启 Looper 循环。</p>
<h4 id="开启-Looper-循环"><a href="#开启-Looper-循环" class="headerlink" title="开启 Looper 循环"></a>开启 Looper 循环</h4><p>对应代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.loop();</span><br></pre></td></tr></table></figure>
<p>我们看下源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">    final Looper me = myLooper();</span><br><span class="line">    if (me == null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    // Make sure the identity of this thread is that of the local process,</span><br><span class="line">    // and keep track of what that identity token actually is.</span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    final long ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); // might block</span><br><span class="line">        if (msg == null) &#123;</span><br><span class="line">            // No message indicates that the message queue is quitting.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // This must be in a local variable, in case a UI event sets the logger</span><br><span class="line">        final Printer logging = me.mLogging;</span><br><span class="line">        if (logging != null) &#123;</span><br><span class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                    msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line"></span><br><span class="line">        final long traceTag = me.mTraceTag;</span><br><span class="line">        if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">        final long end;</span><br><span class="line">        try &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (traceTag != 0) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (slowDispatchThresholdMs &gt; 0) &#123;</span><br><span class="line">            final long time = end - start;</span><br><span class="line">            if (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot;</span><br><span class="line">                        + Thread.currentThread().getName() + &quot;, h=&quot; +</span><br><span class="line">                        msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (logging != null) &#123;</span><br><span class="line">            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Make sure that during the course of dispatching the</span><br><span class="line">        // identity of the thread wasn&apos;t corrupted.</span><br><span class="line">        final long newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        if (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class="line">                    + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class="line">                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class="line">                    + msg.target.getClass().getName() + &quot; &quot;</span><br><span class="line">                    + msg.callback + &quot; what=&quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过 myLooper() 拿到 Looper 对象 me，然后再根据 me 拿到 MessageQueue 对象 queue。</p>
<p>然后我们看到一个无限循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(;;)&#123;</span><br><span class="line">    Message msg = queue.next(); // might block</span><br><span class="line">    if (msg == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个无限循环用于不断的从 MessageQueue 中取消息，如果 MessageQueue 中没有消息，那么就阻塞。</p>
<p>再来看下关键代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg.target.dispatchMessage(msg);</span><br></pre></td></tr></table></figure>
<p>msg 是从 MessageQueue 里面取出的消息。那我 msg.target 是什么呢？在第三步，我们已经在Handler 的 enqueueMessage 方法中将 Handler 对象赋值给 Message 的 target 属性了。所以这里的 msg.target 指代的就是 Handler 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    、、、<span class="comment">//省略其他代码</span></span><br><span class="line">    Handler target;</span><br><span class="line">    、、、<span class="comment">//省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用了调用了 msg.target（也就是 Handler 对象） 的 dispatchMessage（） 方法。<br>来看下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle system messages here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一眼就看到了最后的 handleMessage(msg); 方法，是不是有点似曾相识呢？</p>
<p>我们再来看下我们最开始的在子线程中使用 Handler 的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        Handler threadHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        message.what = <span class="number">1</span>;</span><br><span class="line">        threadHandler.sendMessage(message);</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>看到我们重写了 Handler 的 handleMessage 方法，也就是上面我们分析的 dispatchMessage 中调用的 handleMessage 方法，这样我们就把所有的流程关联了起来。</p>
<p>到此，相信已经知道为什么我们通过 Handler 发送消息，然后再通过 Handler 处理了。</p>
<h3 id="2-2-在主线程中使用-Handler"><a href="#2-2-在主线程中使用-Handler" class="headerlink" title="2.2 在主线程中使用 Handler"></a>2.2 在主线程中使用 Handler</h3><p>我们在主线程使用 Handler 的时候，并没有执行 Looper.prepare()、Looper.loop() 方法，比如下面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 主线程中的Handler</span><br><span class="line"> */</span><br><span class="line">private Handler mHandler = new Handler() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        super.handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是为什么呢？</p>
<p>前面我们说过，Android 是单线程模型，其线程为 ActivityThread，主程序的入口是 main(); main() 方法源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 省略无关代码</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread = new ActivityThread();</span><br><span class="line">    thread.attach(false);</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler == null) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (false) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(new</span><br><span class="line">                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // End of event ActivityThreadMain.</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，虽然我们没有主动的执行 prepare、loop方法，但是在 ActivityThread 的 main() 方法里面执行了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">Looper.loop();</span><br></pre></td></tr></table></figure>
<p>main() 方法里面还有个特殊的 Handler：sMainThreadHandler</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread thread = new ActivityThread();</span><br><span class="line">thread.attach(false);</span><br><span class="line">if (sMainThreadHandler == null) &#123;</span><br><span class="line">    sMainThreadHandler = thread.getHandler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看下 thread.getHandler()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final H mH = new H();</span><br><span class="line"></span><br><span class="line">final Handler getHandler() &#123;</span><br><span class="line">    return mH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的是一个 H，这个 H 是 ActivityThread 的内部类，并且继承于 Handler ：</p>
<p><img src="http://p2oza5z62.bkt.clouddn.com/2018-04-08-15226517496545.jpg" alt=""></p>
<p>H 这个类定义了很多常量，标示一些消息类型，比如上图的第一个<br> LAUNCH_ACTIVITY ：启动 Activity 等。主要包含了四大组件的启动和停止等过程。</p>
<blockquote>
<p>AnctivityThread 通过 ApplicationThread 和 AMS(ActivityManagerService) 进行进程间通信，AMS 以进程间通信的方式完成 ActivityThread 的请求后回调 ApplicationThread 中的 Binder 方法，然后 ApplicationThread 会向 H 发送消息，H 收到消息后会将 ApplicationThread 中的逻辑切换到 ActivityThread 中去执行，也就是切换到主线程中去执行。</p>
</blockquote>
<p>既然知道 Handler 的原理，那么我们就对上一节的六个实例做一个源码分析吧。</p>
<h2 id="三、上篇文章实例源码分析"><a href="#三、上篇文章实例源码分析" class="headerlink" title="三、上篇文章实例源码分析"></a>三、上篇文章实例源码分析</h2><h3 id="3-1-使用-Handler-的-post-方法更新-UI"><a href="#3-1-使用-Handler-的-post-方法更新-UI" class="headerlink" title="3.1 使用 Handler 的 post() 方法更新 UI"></a>3.1 使用 Handler 的 post() 方法更新 UI</h3><h4 id="3-1-1-使用："><a href="#3-1-1-使用：" class="headerlink" title="3.1.1 使用："></a>3.1.1 使用：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用post方法直接更新ui线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mShow.setText(<span class="string">"使用post方法直接更新ui线程"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h4 id="3-1-2-分析"><a href="#3-1-2-分析" class="headerlink" title="3.1.2 分析"></a>3.1.2 分析</h4><p>我们看下 mHandler.post（） 方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final boolean post(Runnable r)</span><br><span class="line">&#123;</span><br><span class="line">   return  sendMessageDelayed(getPostMessage(r), 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过 getPostMessage(r)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据传入的 Runnable 创建一个 Message 对象。</p>
<p>然后调用 sendMessageDelayed(getPostMessage(r), 0) 方法，sendMessageDelayed 方法我们在上面见过，最终会调用 Handler 的 enqueueMessage(queue, msg, uptimeMillis); 方法。把消息放入 MessageQueue 中。由 Looper 去不断取消息给 Handler 处理。</p>
<h3 id="3-2-使用-Handler-的-sendMessage-方法更新-UI"><a href="#3-2-使用-Handler-的-sendMessage-方法更新-UI" class="headerlink" title="3.2 使用 Handler 的 sendMessage() 方法更新 UI"></a>3.2 使用 Handler 的 sendMessage() 方法更新 UI</h3><h4 id="3-2-1-实例"><a href="#3-2-1-实例" class="headerlink" title="3.2.1 实例"></a>3.2.1 实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Message message = mHandler.obtainMessage(<span class="number">7</span>, <span class="string">"子线程中发布消息，更新主线程"</span>);</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-分析"><a href="#3-2-2-分析" class="headerlink" title="3.2.2 分析"></a>3.2.2 分析</h4><p>关键代码在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mHandler.sendMessage(message);</span><br></pre></td></tr></table></figure>
<p>看下 sendMessage方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，也是调用了 sendMessageDelayed(msg, 0) 方法，那么下面就和使用 Handler.post() 方法一样了，不在分析</p>
<h3 id="3-3-使用-runOnUiThread-方法更新-UI"><a href="#3-3-使用-runOnUiThread-方法更新-UI" class="headerlink" title="3.3 使用 runOnUiThread() 方法更新 UI"></a>3.3 使用 runOnUiThread() 方法更新 UI</h3><h4 id="3-3-1-实例"><a href="#3-3-1-实例" class="headerlink" title="3.3.1 实例"></a>3.3.1 实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mShow.setText(<span class="string">"使用runOnUiThread更新ui线程"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-分析"><a href="#3-3-2-分析" class="headerlink" title="3.3.2 分析"></a>3.3.2 分析</h4><p>我们看下 runOnUiThread 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">        mHandler.post(action);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        action.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先判断是当前的线程是不是 ui 线程，如果不是 UI 线程，就执行 Activity 中的 Handler 对象 mHandler.post() 方法，在主线程中执行；如果是在主线程，则直接在主线程中执行 Runnable 中的 run（） 方法。</p>
<h3 id="3-4-使用-View-的-post-方法更新-UI"><a href="#3-4-使用-View-的-post-方法更新-UI" class="headerlink" title="3.4 使用 View 的 post() 方法更新 UI"></a>3.4 使用 View 的 post() 方法更新 UI</h3><h4 id="3-4-1-实例"><a href="#3-4-1-实例" class="headerlink" title="3.4.1 实例"></a>3.4.1 实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mButton5.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mShow.setText(<span class="string">"通过View的post方法更新ui"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-2-分析"><a href="#3-4-2-分析" class="headerlink" title="3.4.2 分析"></a>3.4.2 分析</h4><p>看下 View.post方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></span><br><span class="line">    <span class="comment">// Assume that the runnable will be successfully placed after attach.</span></span><br><span class="line">    getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AttachInfo 的官方说明是：当 View 附加到父视图时向 View 提供的一组信息。</p>
<p>如果 attachInfo 不为空，执行 attachInfo 中的 mHandler post 方法，和 3.1 类似</p>
<p>如果 attachInfo 为空，执行 getRunQueue() 中的 mHandler post 方法，那 getRunQueue() 又是啥呢?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private HandlerActionQueue getRunQueue() &#123;</span><br><span class="line">    if (mRunQueue == null) &#123;</span><br><span class="line">        mRunQueue = new HandlerActionQueue();</span><br><span class="line">    &#125;</span><br><span class="line">    return mRunQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的是 HandlerActionQueue 对象，那么 HandlerActionQueue是啥?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Class used to enqueue pending work from Views when no Handler is attached.</span><br><span class="line"> *</span><br><span class="line"> * @hide Exposed for test framework only.</span><br><span class="line"> */</span><br><span class="line">public class HandlerActionQueue &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>注释中描述的很清楚，这个类用于当 View 没有附加到父 View 的时候，把待执行的工作放进队列。然后再 View 附加到父 View 之后再去执行之前添加的任务，有兴趣的可以具体了解下工作流程<br>相关文章地址:<a href="https://www.jianshu.com/p/dfdd0079da72" target="_blank" rel="noopener">地址</a></p>
<h3 id="3-5-子线程中创建-Handler（handler1）发送消息，在子线程中的Handler（handler1）-中处理-然后发送给主线程（mHandler）-去更新-UI"><a href="#3-5-子线程中创建-Handler（handler1）发送消息，在子线程中的Handler（handler1）-中处理-然后发送给主线程（mHandler）-去更新-UI" class="headerlink" title="3.5 子线程中创建 Handler（handler1）发送消息，在子线程中的Handler（handler1） 中处理,然后发送给主线程（mHandler） 去更新 UI"></a>3.5 子线程中创建 Handler（handler1）发送消息，在子线程中的Handler（handler1） 中处理,然后发送给主线程（mHandler） 去更新 UI</h3><p>这个就不在分析，在上面的第二部分已经说得很清楚了。</p>
<h3 id="3-6-在子线程中更新-UI"><a href="#3-6-在子线程中更新-UI" class="headerlink" title="3.6 在子线程中更新 UI"></a>3.6 在子线程中更新 UI</h3><h4 id="3-6-1-实例"><a href="#3-6-1-实例" class="headerlink" title="3.6.1 实例"></a>3.6.1 实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerTestActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line">    TextView mShow;</span><br><span class="line">    Button mButton4;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentLayout(R.layout.a_activity_handler_test);</span><br><span class="line">        mShow = findViewById(R.id.show);</span><br><span class="line">        mButton4 = findViewById(R.id.button4);</span><br><span class="line">        mButton4.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            beforeOnResumeClick();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 写在OnResume之前执行点击事件的话，可以在子线程更新UI线程</span></span><br><span class="line">        mButton4.performClick();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 测试在onResume之前调用Thread更新ui</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beforeOnResumeClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                mShow.setText(<span class="string">"测试在onResume之前调用Thread更新ui"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start(); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-6-2-分析"><a href="#3-6-2-分析" class="headerlink" title="3.6.2 分析"></a>3.6.2 分析</h4><p>可以看到，我们如果想在非 UI 线程更新 UI，就必须在 onResume 之前完成 View 的绑定，更新 UI 的操作，这是为什么呢？</p>
<p>我们先从在子线程中更新 UI 的异常说起：</p>
<p><img src="http://p2oza5z62.bkt.clouddn.com/2018-04-08-15226581691369.jpg" alt=""></p>
<p>我们看下异常的堆栈信息，可以知道异常产生的路径：</p>
<ol>
<li>View 的 setText</li>
<li>View 的 checkForRelayout</li>
<li>View 的 invalidate</li>
<li>View 的 invalidate</li>
<li>ViewGroup 的 InvalidateChild</li>
<li>ViewRootImpl 的 invalidateChildInParent</li>
<li>ViewRootImpl 的 CheckThread 方法。</li>
</ol>
<p>我们看下异常堆栈里面的流程：</p>
<p>首先，我们是在 <code>mShow.setText(&quot;测试在onResume之前调用Thread更新ui&quot;);</code> 这里崩溃的，来看下 <code>setText(CharSequence text)</code> 的源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public final void setText(CharSequence text) &#123;</span><br><span class="line">    setText(text, mBufferType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setText(CharSequence text, BufferType type) &#123;</span><br><span class="line">    setText(text, type, true, 0);</span><br><span class="line">    if (mCharWrapper != null) &#123;</span><br><span class="line">        mCharWrapper.mChars = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setText(CharSequence text, BufferType type,</span><br><span class="line">                     boolean notifyBefore, int oldlen) &#123;</span><br><span class="line">    // 省略前面代码</span><br><span class="line">    if (mLayout != null) &#123;</span><br><span class="line">        checkForRelayout();   </span><br><span class="line">    &#125;</span><br><span class="line">    // 省略后面代码 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里有个 checkForRelayout() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForRelayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If we have a fixed width, we can just swap in a new text layout</span></span><br><span class="line">    <span class="comment">// if the text height stays the same or if the view height is fixed.</span></span><br><span class="line">    <span class="keyword">if</span> ((mLayoutParams.width != LayoutParams.WRAP_CONTENT</span><br><span class="line">            || (mMaxWidthMode == mMinWidthMode &amp;&amp; mMaxWidth == mMinWidth))</span><br><span class="line">            &amp;&amp; (mHint == <span class="keyword">null</span> || mHintLayout != <span class="keyword">null</span>)</span><br><span class="line">            &amp;&amp; (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Static width, so try making a new text layout.</span></span><br><span class="line">        <span class="keyword">int</span> oldht = mLayout.getHeight();</span><br><span class="line">        <span class="keyword">int</span> want = mLayout.getWidth();</span><br><span class="line">        <span class="keyword">int</span> hintWant = mHintLayout == <span class="keyword">null</span> ? <span class="number">0</span> : mHintLayout.getWidth();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * No need to bring the text into view, since the size is not</span></span><br><span class="line"><span class="comment">         * changing (unless we do the requestLayout(), in which case it</span></span><br><span class="line"><span class="comment">         * will happen at measure).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        makeNewLayout(want, hintWant, UNKNOWN_BORING, UNKNOWN_BORING,</span><br><span class="line">                      mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight(),</span><br><span class="line">                      <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (mEllipsize != TextUtils.TruncateAt.MARQUEE) &#123;</span><br><span class="line">            <span class="comment">// In a fixed-height view, so use our new text layout.</span></span><br><span class="line">            <span class="keyword">if</span> (mLayoutParams.height != LayoutParams.WRAP_CONTENT</span><br><span class="line">                    &amp;&amp; mLayoutParams.height != LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                autoSizeText();</span><br><span class="line">                invalidate();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Dynamic height, but height has stayed the same,</span></span><br><span class="line">            <span class="comment">// so use our new text layout.</span></span><br><span class="line">            <span class="keyword">if</span> (mLayout.getHeight() == oldht</span><br><span class="line">                    &amp;&amp; (mHintLayout == <span class="keyword">null</span> || mHintLayout.getHeight() == oldht)) &#123;</span><br><span class="line">                autoSizeText();</span><br><span class="line">                invalidate();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We lose: the height has changed and we have a dynamic height.</span></span><br><span class="line">        <span class="comment">// Request a new view layout using our new text layout.</span></span><br><span class="line">        requestLayout();</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Dynamic width, so we have no choice but to request a new</span></span><br><span class="line">        <span class="comment">// view layout with a new text layout.</span></span><br><span class="line">        nullLayouts();</span><br><span class="line">        requestLayout();</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，checkForRelayout 这个方法不管怎样都会调用<code>invalidate();</code>方法。</p>
<p>看下 View 的 <code>invalidate()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    invalidate(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(<span class="keyword">boolean</span> invalidateCache)</span> </span>&#123;</span><br><span class="line">    invalidateInternal(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop, invalidateCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalidateInternal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b, <span class="keyword">boolean</span> invalidateCache,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> fullInvalidate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">        <span class="comment">// Propagate the damage rectangle to the parent view.</span></span><br><span class="line">        <span class="keyword">final</span> AttachInfo ai = mAttachInfo;</span><br><span class="line">        <span class="keyword">final</span> ViewParent p = mParent;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; ai != <span class="keyword">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</span><br><span class="line">            <span class="keyword">final</span> Rect damage = ai.mTmpInvalRect;</span><br><span class="line">            damage.set(l, t, r, b);</span><br><span class="line">            p.invalidateChild(<span class="keyword">this</span>, damage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到了 <code>p.invalidateChild(this, damage);</code> 这行代码，是使用了 ViewParent 对象的 invalidateChild 方法刷新布局，由于这里的 p 是 ViewParent 对象，然而 ViewParent 是个接口，而 ViewGroup 又实现了 ViewParent 接口（并且异常堆栈里面已经明确显示了是使用 ViewGroup 里面的 invalidateChild 方法），现在我们在 ViewGroup 中找下 invalidateChild（） 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Deprecated</span><br><span class="line">@Override</span><br><span class="line">public final void invalidateChild(View child, final Rect dirty) &#123;</span><br><span class="line">        // 省略部分代码</span><br><span class="line">        do &#123;</span><br><span class="line">            View view = null;</span><br><span class="line">            if (parent instanceof View) &#123;</span><br><span class="line">                view = (View) parent;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (drawAnimation) &#123;</span><br><span class="line">                if (view != null) &#123;</span><br><span class="line">                    view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</span><br><span class="line">                &#125; else if (parent instanceof ViewRootImpl) &#123;</span><br><span class="line">                    ((ViewRootImpl) parent).mIsAnimating = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If the parent is dirty opaque or not dirty, mark it dirty with the opaque</span><br><span class="line">            // flag coming from the child that initiated the invalidate</span><br><span class="line">            if (view != null) &#123;</span><br><span class="line">                if ((view.mViewFlags &amp; FADING_EDGE_MASK) != 0 &amp;&amp;</span><br><span class="line">                        view.getSolidColor() == 0) &#123;</span><br><span class="line">                    opaqueFlag = PFLAG_DIRTY;</span><br><span class="line">                &#125;</span><br><span class="line">                if ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123;</span><br><span class="line">                    view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            parent = parent.invalidateChildInParent(location, dirty);</span><br><span class="line">            if (view != null) &#123;</span><br><span class="line">                // Account for transform on current parent</span><br><span class="line">                Matrix m = view.getMatrix();</span><br><span class="line">                if (!m.isIdentity()) &#123;</span><br><span class="line">                    RectF boundingRect = attachInfo.mTmpTransformRect;</span><br><span class="line">                    boundingRect.set(dirty);</span><br><span class="line">                    m.mapRect(boundingRect);</span><br><span class="line">                    dirty.set((int) Math.floor(boundingRect.left),</span><br><span class="line">                            (int) Math.floor(boundingRect.top),</span><br><span class="line">                            (int) Math.ceil(boundingRect.right),</span><br><span class="line">                            (int) Math.ceil(boundingRect.bottom));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (parent != null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们由找到了这两句关键代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">((ViewRootImpl) parent).mIsAnimating = true;</span><br><span class="line"></span><br><span class="line">parent = parent.invalidateChildInParent(location, dirty);</span><br></pre></td></tr></table></figure>
<p>可以知道，parent.invalidateChildInParent(location, dirty) 这行代码调用的是 ViewRootImpl 的方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">int</span>[] location, Rect dirty)</span> </span>&#123;</span><br><span class="line">    checkThread();</span><br><span class="line">    <span class="comment">// 省略大量代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 checkThread() 代码又是如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void checkThread() &#123;</span><br><span class="line">    if (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        throw new CalledFromWrongThreadException(</span><br><span class="line">                &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，正是这里抛出的异常。从上面的分析可知，是我们在子线程中 setText 的时候，抛出的这个异常。</p>
<p>看下 mThread 是什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class ViewRootImpl implements ViewParent,</span><br><span class="line">        View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks &#123;</span><br><span class="line">    final Thread mThread;</span><br><span class="line">    public ViewRootImpl(Context context, Display disp</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 mThread 是在生成 ViewRootImpl 对象的时候赋值的。</p>
<p>上篇文章我们讲了在子线程中更新 UI 必须在 onResume 之前，就是因为在 onResume 之前 ViewRootImpl 还没生成，所以没法检查更新 UI 操作是不是在主线程，所以不会报错。</p>
<p>鉴于篇幅原因，这里不再过多介绍 ViewRootImpl，建议大家看下<a href="https://juejin.im/entry/58d36b27128fe1006cb056a6" target="_blank" rel="noopener">这篇文章</a>，里面讲到了 ViewRootImpl 相关的内容，后面我也会写下我对 ViewRootImpl 的认识。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>到此，希望你能对 Android 中的消息机制有了进一步的认识。另外，看源码的时候一定不能着急，并且不要每个地方都看明白，找到重点看就行了，不然你会哭的。。。</p>
<p>其实关于 Handler 的文章很早就想写来总结下，但是一直没有写，一忙起来就懒得写东西了，以后还得坚持记录。</p>

    </div>

    <div class="post-footer">   
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">smartsean</a>
            
        </div>
        <div>
            
        </div>  
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2018/04/09/从一个异常认识Android中的-commit-和-commitAllowingStateLoss/" class="pre-post btn btn-default"><i class="fa fa-angle-left fa-fw"></i>上一篇</a>
    
    
        <a href="/2018/04/08/Handler系列-源码分析的副本/" class="next-post btn btn-default">下一篇<i class="fa fa-angle-right fa-fw"></i></a>
    
</div>


    <div id="comments">
        
	
<div id="lv-container" data-id="city" data-uid="MTAyMC8zMzA1MS85NjEz">
  <script type="text/javascript">
     (function(d, s) {
         var j, e = d.getElementsByTagName(s)[0];
         if (typeof LivereTower === 'function') { return; }
         j = d.createElement(s);
         j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
         j.async = true;
         e.parentNode.insertBefore(j, e);
     })(document, 'script');
  </script>
</div>


    </div>





                </main>
                
    <aside class="col-md-4 sidebar">
        
        
    <div class="widget">    
        <h3 class="title">搜索</h3>
        <div id="search-form">
            <div id="result-mask" class="hide"></div>
            <div class="search-area">
                
                    <input id="search-key" type="search" autocomplete="off" placeholder="搜点什么呢?">
                    <button type="button" class="search-form-submit" id="search-local">站内搜索</button>
                
                
            </div>
            <div id="result-wrap" class="hide">
                <div id="search-result"></div>
            </div>
            <div class="hide">
                <template id="search-tpl">
                    <div class="item">
                        <a href="/{path}" title="{title}">
                            <div class="title">{title}</div>
                            <div class="content">{content}</div>
                        </a>
                    </div>
                </template>
            </div>
        </div>
    </div>

        
        
    <div class="widget">
      <h3 class="title">社交</h3> 
        <div class="content social">
            
	            <a href="https://github.com/smartsean" rel="external nofollow" title="Github" target="_blank">
			    	<i class="git fa fa-git"></i>
			    </a>
            
        </div>
    </div>


        
        
    <div class="widget">
        <h3 class="title">分类</h3>
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/"><i class="fa" aria-hidden="true">Android</i></a><span class="category-list-count">48</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ionic/"><i class="fa" aria-hidden="true">Ionic</i></a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/"><i class="fa" aria-hidden="true">工具</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/我/"><i class="fa" aria-hidden="true">我</i></a><span class="category-list-count">6</span></li></ul>
    </div>


        
        
  <div class="widget">
    <h3 class="title">标签云</h3>
    <div class="content tag-cloud">
        <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/AndroidStudio/" style="font-size: 12px;">AndroidStudio</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Ionic/" style="font-size: 18px;">Ionic</a> <a href="/tags/Java/" style="font-size: 12px;">Java</a> <a href="/tags/Java-Java基础/" style="font-size: 10px;">Java Java基础</a> <a href="/tags/工具/" style="font-size: 16px;">工具</a> <a href="/tags/异常/" style="font-size: 12px;">异常</a> <a href="/tags/我/" style="font-size: 14px;">我</a> <a href="/tags/模拟器/" style="font-size: 10px;">模拟器</a> <a href="/tags/自定义View/" style="font-size: 12px;">自定义View</a>
    </div>
  </div>


        
        
    <div class="widget notification">
        <h3 class="title">网站公告</h3>
        <div>
            <p>暂无公告~ <br/>
        </div>
    </div>

        
        
    <div class="widget">
      <h3 class="title">归档</h3>
        <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/"><i class="fa" aria-hidden="true">四月 2018</i></a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/"><i class="fa" aria-hidden="true">三月 2018</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/"><i class="fa" aria-hidden="true">二月 2018</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/"><i class="fa" aria-hidden="true">一月 2018</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/"><i class="fa" aria-hidden="true">十二月 2017</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/"><i class="fa" aria-hidden="true">九月 2017</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/"><i class="fa" aria-hidden="true">八月 2017</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/"><i class="fa" aria-hidden="true">七月 2017</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/"><i class="fa" aria-hidden="true">五月 2017</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/"><i class="fa" aria-hidden="true">四月 2017</i></a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/"><i class="fa" aria-hidden="true">三月 2017</i></a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/"><i class="fa" aria-hidden="true">二月 2017</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/"><i class="fa" aria-hidden="true">一月 2017</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/"><i class="fa" aria-hidden="true">十二月 2016</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/"><i class="fa" aria-hidden="true">十一月 2016</i></a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/"><i class="fa" aria-hidden="true">十月 2016</i></a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/"><i class="fa" aria-hidden="true">九月 2016</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/"><i class="fa" aria-hidden="true">八月 2016</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/"><i class="fa" aria-hidden="true">六月 2016</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/"><i class="fa" aria-hidden="true">四月 2016</i></a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/"><i class="fa" aria-hidden="true">三月 2016</i></a><span class="archive-list-count">3</span></li></ul>
    </div>


        
        
    <div class="widget">
        <h3 class="title">友链</h3>
        <div class="content friends-link">
        
            <a href="http://www.shenliyang.com" class="fa" target="_blank">个人博客</a>
        
        </div>
    </div>


        
    </aside>

            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12"> 
                <span>Copyright &copy; 2018
                </span> | 
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> | 
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



	<script src="/js/search.js?rev=@@hash"></script>


<script src="/js/app.js?rev=@@hash"></script>


</body>
</html>