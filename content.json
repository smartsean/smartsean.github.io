{"meta":{"title":"SmartSean的小站","subtitle":"每天进步一点点。","description":null,"author":"smartsean","url":"https://github.com/smartsean/smartsean.github.io"},"pages":[{"title":"","date":"2018-01-15T13:47:47.305Z","updated":"2018-01-15T13:47:47.305Z","comments":true,"path":"404.html","permalink":"https://github.com/smartsean/smartsean.github.io/404.html","excerpt":"","text":"404"}],"posts":[{"title":"Java常用集合框架(一)","slug":"Java常用集合框架-一","date":"2018-03-29T05:35:12.000Z","updated":"2018-03-29T05:38:28.938Z","comments":true,"path":"2018/03/29/Java常用集合框架-一/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2018/03/29/Java常用集合框架-一/","excerpt":"","text":"[TOC] Java常用集合框架(一)前言Java 集合框架在我们日常的开发学习中应该是经常用到。那么什么是集合框架呢？ 从字面意思来看，就是集合的框架。 网友给出了以下解释： 数据结构是以某种形式将数据组织在一起的集合，它不仅存储数据，还支持访问和处理数据的操作。Java提供了几个能有效地组织和操作数据的数据结构，这些数据结构通常称为Java集合框架。 有人可能会说，数组不也是把数据组织在一起的集合吗？有什么区别？ 实际上数组长度在初始化时指定，只能保存定长的数据，另外它可以保存基本数据类型和对象引用。 但是集合就不一样了，它可以保存数量不确定的数据，同时可以保存具有映射关系的数据（比如Map），另外只能保存对象引用，不能保存基本数据类型; 我们常见的集合框架大体分为两种： 1、实现 Collection 接口的 123456// 实现List接口List&lt;String&gt; lists = new ArrayList&lt;&gt;();// 实现Set接口Set&lt;String&gt; sets = new HashSet&lt;&gt;();// 实现Quene接口Queue&lt;String&gt; queues = new LinkedList&lt;&gt;(); 2、实现 Map 接口的 1Map&lt;String,String&gt; maps = new HashMap&lt;&gt;(); 其中： Set 代表无序、不可重复的集合； List 代表有序、重复的集合； Queue 代表一种队列集合实现； Map 代表具有映射关系的集合，键值对存在 先来看下我画的集合框架的大体结构（一些不常用的没列出来）： 看不清的，请点击看大图：大图地址 其中可以看到我们经常用到的 ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap等集合框架 一、实现了 Collection 接口先来看下 Collection 这个接口： 可以看到，这个接口继承了 Iterable 这个接口，那么这个接口是干啥的呢？我们进去看一下： 我们在 Api 文档看到了这样一句话: 官方的描述是：通过实现这个接口允许一个对象成为for-each循环语句的目标。并且是从 1.5 引入的 这个地方对应的就是我们使用迭代器（Iterator）进行集合遍历，比如: 1234567Set&lt;String&gt; set = new HashSet&lt;&gt;();set.add(&quot;11111&quot;);set.add(&quot;22222&quot;);Iterator&lt;String&gt; iterator = set.iterator();while (iterator.hasNext())&#123; System.out.println(iterator.next());&#125; 另外我们可以看到他有超多的子接口和实现类，其中就包括我们下面要分析的。 再来看下 Collection 的方法： 我们经常使用的 add 、remove、clear 等方法，都是在这个地方定义的，我们使用的实现类都是要直接或间接实现这些接口。 好了，接下来就来看下具体的List、 Map、 Queue 等接口。 1.1、List 接口 看下官方 Api ： 最下面的那段官方说明:该接口的用户对插入的每个元素的位置有精确的控制。用户可以通过其整数索引(列表中的位置)访问元素，并搜索列表中的元素。 可以看到 List 接口扩展自 Collection 接口，它主要定义了一个允许重复的有序集合，并且增加了面向位置的操作，允许在指定位置上进行操作。比如：add(int index,E element )、addAll(int index,Collection c)、get(int index)等。 结合上面的思维导图可以看到，List 接口扩展自 Collection 接口，而 Collection 接口继承于 Iterable 接口，那么可以知道，实现了 List 接口的子类也是可以使用迭代器进行遍历的。此外，还增加了一个能够双向遍历线性表迭代器 ListIterator。 List 接口有一个很重要的抽象实现类： AbstractList ，它实现了 List 的大部分方法。 List 承诺可以将元素维护在特定的序列中，List 在 Collection 接口的基础上添加了大量的方法，使得可以在 List 的中间插入和移除元素。 有两种类型的 List ： ArrayList 数组实现，它的长项在于随机访问元素，但是在 List 的中间插入和移除元素时较慢 LinkedList 链表实现，它通过代价较低的在 List 中间进行插入和移除操作，提供了优化的顺序访问，LinekedList 在随机访问方面比较慢，但是它的特性集较 ArrayList 大（提供了更多的操作控件） 下面具体看下这两个 List 的实现类。 1.1.1 ArrayListArrayList 是一个有序的集合，随机访问元素比较快，但是往 List 中间插入和移除元素较慢。 ArrayList 是一个其容量能够动态增长的动态数组。它继承了 AbstractList ，实现了 List、RandomAccess, Cloneable, java.io.Serializable。 为什么说 ArrayList 实际上是个数组呢？ 我们通过源码来看下: 先看下成员变量： 123456789101112131415161718192021222324252627282930313233343536public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; /** * 默认的数组容量大小 */ private static final int DEFAULT_CAPACITY = 10; /** * 定义的一个空数组， */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 这个也是个空数组，是为了和 EMPTY_ELEMENTDATA 空数组区分，用来知道当第一个元素被添加的时候，数组会增大多少 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * 用于保存ArrayList中数据的数组 */ transient Object[] elementData; // non-private to simplify nested class access /** * The size of the ArrayList (the number of elements it contains). * 数组的大小 */ private int size; /** * 数组最大长度 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;&#125; 再来通过一个我们常用的 add 方法来分析下。 add方法： 1234567891011/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 来看下 ensureCapacityInternal(size + 1) 方法: 123private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125; 此时 minCapacity 为数组大小加1.在 ensureCapacityInternal 方法里面又先调用了 calculateCapacity 方法: 123456private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125; 可以看到在 calculateCapacity 方法里面会拿 elementData 数组和默认的空数组进行比较： 如果是相等的，也就是说 elementData 是个空数组，那么 calculateCapacity() 返回默认数组大小和此时 minCapacity 之间的最大值，也就是 DEFAULT_CAPACITY 的值 8 ， 如果不相等，说明数组不为空，那么就返回 minCapacity 的值，即当前数组 size + 1; 然后把返回的值给 ensureExplicitCapacity() : 1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; modCount 这个字段我们不需关心，是给迭代器用的。重要看下面: 如果说 minCapacity 减去当前数组的长度大于0，就去执行 grow（）方法： 1234567891011121314151617/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 我们一行一行来分析: 首先，把当前数组长度赋值给 oldCapacity 接着用 oldCapacity 加上 oldCapacity / 2 计算出来的值为 newCapacity 如果 newCapacity 小于 minCapacity,那么把大的值 minCapacity 赋值给 newCapacity 如果 newCapacity 大于数组的最大长度 MAX_ARRAY_SIZE，去执行：hugeCapacity(minCapacity)： 1234567private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 如果是 minCapacity 大于最大数组长度，那么返回 Integer 的最大值，否则返回 最大数组长度 MAX_ARRAY_SIZE。 继续看 grow 方法的最后一句： 1elementData = Arrays.copyOf(elementData, newCapacity); 很清晰了，调用 Arrays.copyOf 方法，生成 一个长度为 newCapacity 的新数组，赋值给 elementData。 好了，add方法已经分析完了。 总结下： ArrayList 是用数组实现的，并且是动态的，默认长度为 8，如果当前长度已用完，那么每次增长的长度为当前长度的一半。 1.1.2 LinkedListLinkedList 也像 ArrayList 一样实现了基本的 List 接口，但是它执行某些操作（在 List 的中间插入和移除）相比 ArrayList 更高效，但是在随机访问逊色于 ArrayList。 这是因为 LinkedList 的实现机制与 ArrayList 完全不同。 ArrayList 内部是以数组的形式来保存集合中的元素的，因此随机访问集合元素时有较好的性能； LinkedList内部以双向链表的形式来保存集合中的元素，因此随机访问集合元素时性能较差，但在插入、删除元素时性能比较出色。它也可以被当作堆栈、队列或双端队列进行操作。 由于内部是使用链表实现的，那么必然会增加一些有链表特性的方法，比如: void addFirst(E e):将指定元素插入此列表的开头。 void addLast(E e): 将指定元素添加到此列表的结尾。 E getFirst(E e): 返回此列表的第一个元素。 E getLast(E e): 返回此列表的最后一个元素。 boolean offerFirst(E e): 在此列表的开头插入指定的元素。 boolean offerLast(E e): 在此列表末尾插入指定的元素。 E peekFirst(E e): 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。 E peekLast(E e): 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。 E pollFirst(E e): 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。 E pollLast(E e): 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。 E removeFirst(E e): 移除并返回此列表的第一个元素。boolean removeFirstOccurrence(Objcet o): 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。 E removeLast(E e): 移除并返回此列表的最后一个元素。 boolean removeLastOccurrence(Objcet o): 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。 这里我们就不过多的分析，有兴趣的可以自己去看下 LinkedList 的源码 1.1.3 ArrayList LinkedList 使用场景 对于需要快速插入，删除元素，使用LinkedList。 对于需要快速随机访问元素，使用ArrayList。 1.2、 Set 接口Set 不保存重复的元素，所以你可以件容易的得到一个对象是否存在某个 Set 中，正因为如此，查找是 Set 中最重要的操作，因此通常通过实现类 HashSet 来优化查找的速度。 Set 与 List 不同的是，List 继承与 Collection，并且有自己的实现，Set 具有和 Collection 一样的接口，没有特殊的功能，实际上 Set 就是 Collection，只是他们的行为不同（Set 用来存放无序的、不重复的对象的集合，这是典型的多态，Set 用来表现不同的行为）。 存入 Set 的每个元素都必须是唯一的，因为 Set 不保存重复元素，加入 Set 的元素必须定义 equals 方法以确保对象的唯一性（正常情况下最好同时重写 hashCode方法）。Set 和 Collection 有完全一样的接口，Set 接口不保证维护元素的次序。 Set 接口主要有三个实现类： HashSet 散列集，查找速度快 LinkedHashSet 链式散列集，查找速度快，遍历时会按照插入的顺序显示，底层为 链表维护 TreeSet 树形集，有序的 Set，底层为树结构 1.2.1 HashSetHashSet 是专门为快速查找而设计的 Set，存入 HashSet 的元素必须重新定义 hashCode（）。 1.2.2 LinkedHashSet 具有HashSet的查询速度，且内部使用链表维护元素的顺序（插入的次序）。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示。也必须重新定义 hashCode（）。 1.2.3 TreeSet保存次序的Set, 底层为树结构。使用它可以从Set中提取有序的序列。 1.3、 QueueQueue 是一个后进先出的容器，即从容器的一端放入事物，从另一端取出，并且事物放入容器的顺序与取出的顺序是相同的，队列通常被当做一种可靠的将对象从程序的某个区域传输到另一个区域的途径。队列在并发编程中特别重要，因为他们可以安全第一将对象从一个任务传输给另一个任务。 从 思维导图中可以看出，LinkedList 不仅继承自 AbstractList。并且还实现了 Queue 接口。因此 LinkedList 可以作为 Queue 的一种实现。 如果你将 LinkedList 向上转型为 Queue，那么转换后的 对象会不能使用 LinkedList 的部分功能（继承于 AbstractList 的功能）。 二、实现了 Map 接口Map 是一种将对象与对象相关联的设计。 Map 提供 key 到 value 的映射，你可以通过“键”查找“值”。一个 Map 中不能包含相同的 key ，每个 key 只能映射一个 value 所以 key 不可以相同，但是 value 是可以相同的。 常见以下几种不同的 Map ： HashMap, TreeMap, LinkedHashMap 它们都有同样的基本接口 Map ，但是行为、效率、排序策略、保存对象的生命周期和判定“键”等价的策略等各不相同。 我们注意到在讲实现 Collection 接口的集合的时候，通过继承于 Iterable 接口，我们让实现了 Collection 的集合框架具有了使用迭代器的能力，但是这里的 Map 接口好像没有继承与 Iterable 接口，那么，我们是否可以也让 Map 接口具有使用迭代器的能力呢？ 答案是肯定的，只是要通过 Map 里面的一个内部接口来实现。 Map 接口有一个重要的泛型内部接口 Entry，它表示 Map 中的一个实体（一个 key-value 对）。接口中有 getKey(),getValue 方法。 我们可以通过 Map 的 keySet() 方法获取 Map 中的 K（key） 值集合（Set 类型）， 通过 values() 方法 获得 Map 中的 V（value） 类型的集合 Collection 通过 entrySet() 方法获取 Map 的 Entry 集合 Set&lt;Map.Entry&gt;。 即： 1234567Map&lt;Integer,String&gt; map = new HashSet&lt;&gt;();// 获取 key 集合Set&lt;Integer&gt; keys = map.keySet();// 获取 value 集合Collection&lt;String&gt; values = map.values();// 获取 Entry 集合Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entrys = map.entrySet(); 细心的你可能已经发现了：存储 key 的集合和 存储 Entry 的集合使用的都是 Set 接口，而存储 value 的集合使用的是 Collection 接口。 原因前面已经说了：在 Map 中，不允许存在重复元素，key 是唯一的，Entry 也是唯一的，不存在重复值，正好 Set 是不允许重复值的，所以 key 和 Entry 都是使用的 Set 接口；然后在 Map 中 value 是可以重复的（只要 key 不重复），那么自然就可以使用 Collection 接口了。 也就是说，要遍历 Map，就要借助这个很重要的内部接口 Map.Entry 2.1、 HashMapHashMap 基于散列表实现（它取代了Hashtable），它存储的内容是键值对 (key-value) 映射，插入和查询键值对的开销是固定的，可以通过构造器设置容量和敷在因子，已调整容器的性能。 该类实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null ，不支持线程同步。 2.2、 LinkedHashMap类似于 HashMap，但是迭代遍历它时，取得键值对的顺序是其 插入顺序，或者是最近最少使用的次序，只比 HashMap 慢一点，而在迭代访问时反而更快，因为是通过链表维护内部次序。 2.3、 TreeMap基于红黑树实现，查看 键 或者 键值对 时，他们会被排序，（排序规则由 Comparable 或 Comparator 决定），TreeMap 的特点是，得到的结果是经过排序的，TreeMap 是唯一带有 subMap() 方法的 Map，可返回一个子树。","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Java反射笔记","slug":"Java反射笔记","date":"2018-03-27T12:53:52.000Z","updated":"2018-03-27T12:55:15.248Z","comments":true,"path":"2018/03/27/Java反射笔记/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2018/03/27/Java反射笔记/","excerpt":"","text":"[toc] Java反射笔记Class的获取1、 Object.getClass() 12Car car = new Car();Class clazz = car.getClass(); 这种方式不适合基本数据类型比如 int float等 2、 String.class 123Class clazz = Car.class;Class cls1 = int.class;Class cls2 = String.class; 3、 Class.forName() 1Class clz = Class.forName(&quot;com.frank.test.Car&quot;); “com.frank.test.Car” 就是 Car 这个类的全限定名称，它包括包名+类名。 Class 的名字这里放一个 Car 类，做 Demo 123456789101112131415161718192021222324252627282930313233package cn.smartsean;public class Car &#123; private String mBand; private Color mColor; public enum Color &#123; RED, WHITE, BLACK, BLUE, YELLOW &#125; public Car() &#123; super(); &#125; public Car(String band) &#123; mBand = band; &#125; public void drive()&#123; System.out.println(\"滴滴滴滴，开车了\"); &#125; @Override public String toString() &#123; return \"Car [mBand=\" + mBand + \", 车的颜色是=\" + mColor + \"]\"; &#125;&#125; 测试类： 1234567891011121314Class clz = Car.class;System.out.println(clz.getName());Class clz1 = float.class;System.out.println(clz1.getName());Class clz2 = Void.class;System.out.println(clz2.getName());Class clz3 = new int[]&#123;&#125;.getClass();System.out.println(clz3.getName());Class clz4 = new Car[]&#123;&#125;.getClass();System.out.println(clz4.getName()); 1、 Class.getName(); 当 Class 代表一个引用时 getName() 方法返回的是一个二进制形式的字符串 比如 cn.smartsean.Car 当 Class 代表一个基本数据类型 getName() 方法返回的是他们的关键字，比如 int.class 返回的是 int 当 Class 代表的是基础数据类型的数组时 比如 int[][][] 这样的 3 维数组时, getName() 返回的是 [[[I 这样的字符串这种情况的规则： 最后上面的测试类运行结果: 12345cn.smartsean.Carfloatjava.lang.Void[I[Lcn.smartsean.Car; 2、 Class.getSimpleName();顾名思义，就是获取简易名字的。上面测试类运行结果: 12345678910cn.smartsean.CarCarfloatfloatjava.lang.VoidVoid[Iint[][Lcn.smartsean.Car;Car[] 需要注意的是对于匿名内部类。返回的是一个空的字符串（注意不是null是””） 3、 Class.getCanonicalName();Canonical 是官方、标准的意思，那么 getCanonicalName() 自然就是返回一个 Class 对象的官方名字，这个官方名字 canonicalName 是 Java 语言规范制定的，如果 Class 对象没有 canonicalName 的话就返回 null。 getCanonicalName() 是 getName() 和 getSimpleName() 的结合。 getCanonicalName() 返回的也是全限定类名，但是对于内部类，不用 $ 开头，而用 .。 getCanonicalName() 对于数组类型的 Class，同 simplename 一样直接在后面添加 [] 。 getCanonicalName() 不同于 simplename 的地方是，不存在 canonicalName 的时候返回 null 而不是空字符串。 局部类和匿名内部类不存在 canonicalName。 上面测试类的运行结果： 12345678910111213141516171819getName()：cn.smartsean.CargetSimpleName()：CargetCanonicalName()：cn.smartsean.CargetName()：floatgetSimpleName()：floatgetCanonicalName()：floatgetName()：java.lang.VoidgetSimpleName()：VoidgetCanonicalName()：java.lang.VoidgetName()：[IgetSimpleName()：int[]getCanonicalName()：int[]getName()：[Lcn.smartsean.Car;getSimpleName()：Car[]getCanonicalName()：cn.smartsean.Car[] Class 的修饰符通常情况下，Java 类的修饰符有以下几种： 限定作用域的 public private protected 用来限制子类必须复写的 abstract 用来标记静态的 static 注解 123Class clz = Test.class;System.out.println(\"修饰符的id：\" + clz.getModifiers());System.out.println(\"修饰符的实际值：\" + Modifier.toString(clz.getModifiers())); 12修饰符的id：1025修饰符的实际值：public abstract 可以看出，通过 Modifier.toString()方法可以获得实际的修饰符 一个类定义的时候可能会被多个修饰符修饰，为了一并获取，所以 Java 工程师考虑到了位运算，用一个 int 数值来记录所有的修饰符，然后不同的位对应不同的修饰符，这些修饰符对应的位都定义在 Modifier 这个类当中。 Modifier 还提供了一系列的静态工具方法用来对修饰符进行操作: 比如 isPublic、isPrivate、isProtected、isStatic、isFinal、isSynchronized、isVolatile、isTransient、isNative、isInterface、isAbstract、isStrict等 获取 Class 的成员一个类的成员包括属性（有人翻译为字段或者域）、方法、构造方法（也是方法）。对应到 Class 中就是 Field、Method、Constructor。 获取 Filed获取指定名字的属性获取指定名字的属性有 2 个 API 1、 getDeclaredField(String name) getDeclaredField() 获取的是 Class 中被 private 修饰的属性 2、 getField(String name) getField() 方法获取的是非私有属性，并且 getField() 在当前 Class 获取不到时会向祖先类获取 获取所有属性1、getDeclaredFields（）获取所有的属性， 比如private、protected、public 和 default 修饰的属性，但不包括从父类继承下来的属性2、getFields（）获取自身的所有的 public 属性(仅获取被 public 修饰的)，包括从父类继承下来的。 上面两个都是返回 Field[] 数组，存放所有获取到的值。 测试代码： 12345678910111213141516171819202122232425public class Father &#123; private String father; protected String father1; public String father2;&#125;public class Son extends Father &#123; private String son; protected String son1; public String son2l;&#125;Class clz1 = Son.class;System.out.println(\"getDeclaredFields:\");System.out.println();for (Field field : clz1.getDeclaredFields()) &#123; System.out.println(field.getName());&#125;System.out.println();System.out.println(\"getFields:\");System.out.println();for (Field field : clz1.getFields()) &#123; System.out.println(field.getName());&#125; 运行结果： 12345678910getDeclaredFields:sonson1son2lgetFields:son2lfather2 获取 Method和上面的获取 Field 基本类似 12345678//获取指定方法public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)//获取指定方法public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)//获取**所有**方法public Method[] getDeclaredMethods() throws SecurityException//获取**所有**方法public Method[] getMethods() throws SecurityException 获取 ConstructorJava 反射把构造器从方法中单独拎出来了，用 Constructor 表示 Constructor 不能从父类继承，所以就没有办法通过 getConstructor() 获取到父类的 Constructor 12345678//获取指定的构造方法public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)//获取指定的构造方法public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)//获取**所有**的构造方法public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException //获取**所有**的构造方法public Constructor&lt;?&gt;[] getConstructors() throws SecurityException Field 的操控Field 要么是 8 种基础类型 int、long、float、double、boolean、char、byte 和 short。或者是引用，所有的引用都是 Object 的后代。 Field 类型的获取获取 Field 的类型，通过 2 个方法： 1234//能够获取到泛型类型,比getType更加的详细public Type getGenericType() &#123;&#125;public Class&lt;?&gt; getType() &#123;&#125; 测试代码： 123456789101112131415public class Test &#123; private Car mCar; private int[] mInts; private List&lt;String&gt; mStrings; private Map&lt;String, Car&gt; mMap;&#125;Class clz = Test.class;for (Field field : clz.getDeclaredFields()) &#123; System.out.println(\"name :\" + field.getName() + \" getType() :\" + field.getType() + \" getGenericType() :\" + field.getGenericType());&#125; 输出: name type() genericType() mCar class cn.smartsean.Car class cn.smartsean.Car mInts class [I class [I mStrings interface java.util.List java.util.List mMap interface java.util.Map java.util.Map Field 修饰符的获取同 Class 一样，Field 也有很多修饰符。通过 getModifiers() 方法就可以轻松获取。和获取 Class 的修饰符一样 Field 内容的读取与赋值这个是反射机制中对 Field 最主要的目的。 Field 这个类定义了一系列的 get 方法来获取不同类型的值 Field 也定义了一系列的 set 方法用来对其自身进行赋值。与上面的基本对应。 其中Object 是类的实例引用。 Class 本身不对成员进行储存，它只提供检索，所以需要用 Field、Method、Constructor 对象来承载这些成员，所以，针对成员的操作时，一般需要为成员指定类的实例引用。如果难于理解的话，可以这样理解，班级这个概念是一个类，一个班级有几十名学生，现在有A、B、C 3 个班级，将所有班级的学生抽出来集合到一个场地来考试，但是学生在试卷上写上自己名字的时候，还要指定自己的班级，这里涉及到的 Object 其实就是类似的作用，表示这个成员是具体属于哪个 Object。这个是为了精确定位。 下面以实例说明对 Filed 的操控（设置一个String的值） 1234567891011121314public class Test1 &#123; private String mString = \"father\";&#125;Test1 test1 = new Test1();Class clz1 = test1.getClass();Field field = clz1.getDeclaredField(\"mString\");System.out.println(field.getName());//反射中访问了 private 修饰的成员(String)，如果要消除异常的话，需要添加一句代码,如果是其他修饰符可以不加这一句field.setAccessible(true);System.out.println(\"mString的值=\"+field.get(test1));field.set(test1,\"son\");System.out.println(\"====修改 father 为 son====\");System.out.println(\"mString的值=\"+field.get(test1)); 结果为: 1234mStringmString的值=father====修改 father 为 son====mString的值=son Method 的操控方法由下面几个要素构成： 方法名 方法参数 方法返回值 方法的修饰符 方法可能会抛出的异常 Method 获取方法名getName() 方法 Method 获取方法参数1public Parameter[] getParameters() &#123;&#125; 返回的是一个 Parameter 数组，在反射中 Parameter 对象就是用来映射方法中的参数。经常使用的方法有： Parameter 常用方法 12345678// 获取参数名字public String getName() &#123;&#125;// 获取参数类型public Class&lt;?&gt; getType() &#123;&#125;// 获取参数的修饰符public int getModifiers() &#123;&#125; 有时候我们不需要参数的名字，只要参数的类型就好了，通过 Method 中下面的方法获取。 12345// 获取所有的参数类型，不包括泛型public Class&lt;?&gt;[] getParameterTypes() &#123;&#125;// 获取所有的参数类型，包括泛型public Type[] getGenericParameterTypes() &#123;&#125; Method 获取返回值类型12345// 获取返回值类型public Class&lt;?&gt; getReturnType() &#123;&#125;// 获取返回值类型包括泛型public Type getGenericReturnType() &#123;&#125; Method 获取修饰符public int getModifiers() {}然后通过 Modifier 类去获取 Method 获取异常类型123public Class&lt;?&gt;[] getExceptionTypes() &#123;&#125;public Type[] getGenericExceptionTypes() &#123;&#125; Method 方法的执行是整个反射机制的核心内容了，很多时候运用反射目的其实就是为了以常规手段执行 Method。Method 调用 invoke() 的时候，存在许多细节： invoke() 方法中第一个参数 Object 实质上是 Method 所依附的 Class 对应的类的实例，如果这个方法是一个静态方法，那么 ojb 为 null，后面的可变参数 Object 对应的自然就是参数。 invoke() 返回的对象是 Object，所以实际上执行的时候要进行强制转换。 在对 Method 调用 invoke() 的时候，如果方法本身会抛出异常，那么这个异常就会经过包装，由 Method 统一抛出 InvocationTargetException。而通过 InvocationTargetException.getCause() 可以获取真正的异常。 Constructor 的操控Constructor 同 Method 差不多，但是它特别的地方在于，它能够创建一个对象。 在 Java 反射机制中有两种方法可以用来创建类的对象实例： Class.newInstance() Constructor.newInstance()。 官方文档建议开发者使用后面这种方法，下面是原因。 Class.newInstance() 只能调用无参的构造方法，而 Constructor.newInstance() 则可以调用任意的构造方法。 Class.newInstance() 通过构造方法直接抛出异常，而 Constructor.newInstance() 会把抛出来的异常包装到 InvocationTargetException 里面去，这个和 Method 行为一致。 Class.newInstance() 要求构造方法能够被访问，而 Constructor.newInstance() 却能够访问 private 修饰的构造器。 下面实例说明： 1234567891011121314151617181920212223242526272829public class TestConstructor &#123; private String self; public TestConstructor() &#123; self = \" Frank \"; &#125; public TestConstructor(String self) &#123; this.self = self; &#125; @Override public String toString() &#123; return \"TestConstructor [self=\" + self + \"]\"; &#125;&#125;public class Main &#123; public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; Class clz = TestConstructor.class; TestConstructor test1 = (TestConstructor) clz.newInstance(); System.out.println(test1.toString()); Constructor constructor = clz.getConstructor(String.class); TestConstructor testConstructor = (TestConstructor) constructor.newInstance(\"smrtsean\"); System.out.println(testConstructor.toString()); &#125;&#125; 结果： 12TestConstructor [self= Frank ]TestConstructor [self=smrtsean] 反射中的数组数组的类型数组本质上是一个 Class，而在 Class 中存在一个方法用来识别它是否为一个数组 Class.java 1public native boolean isArray(); 测试代码： 1234567891011121314151617181920public class ShuZu &#123; private int[] array; private Car[] cars;&#125;public class Main &#123; public static void main(String[] args)&#123; ShuZu shuZu = new ShuZu(); Class clz = shuZu.getClass(); Field[] fields = clz.getDeclaredFields(); for (Field field : fields) &#123; Class c = field.getType(); if (c.isArray())&#123; System.out.println(\"type是：\"+c.getName()); System.out.println(\"ComponentType type is :\"+c.getComponentType()); &#125; &#125; &#125;&#125; 结果： 1234type是：[IComponentType type is :inttype是：[Lcn.smartsean.Car;ComponentType type is :class cn.smartsean.Ca 反射中动态创建数组反射创建数组是通过 Array.newInstance() 这个方法。 Array.java 12public static Object newInstance(Class&lt;?&gt; componentType, int... dimensions) throws IllegalArgumentException, NegativeArraySizeException &#123;&#125; 第一个参数指定的是数组内的元素类型，后面的是可变参数，表示的是相应维度的数组长度限制。 比如，我要创建一个 int[2][3] 的数组。 1Array.newInstance(int.class,2,3); Array 的读取与赋值反射中的枚举 Enum反射中的枚举 Enum同数组一样，枚举本质上也是一个 Class 而已，但反射中还是把它单独提出来了 在 Java 反射中，可以把枚举看成一般的 Class，但是反射机制也提供了 3 个特别的的 API 用于操控枚举。 123456789// 用来判定 Class 对象是不是枚举类型Class.isEnum()// 获取所有的枚举常量Class.getEnumConstants()// 判断一个 Field 是不是枚举常量java.lang.reflect.Field.isEnumConstant() 枚举的获取与设定因为等同于 Class，所以枚举的获取与设定就可以通过 Field 中的 get() 和 set() 方法。 需要注意的是，如果要获取枚举里面的 Field、Method、Constructor 可以调用 Class 的通用 API。 实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public enum State &#123; IDLE, DRIVING, STOPPING, test(); int test1()&#123; return 1; &#125;&#125;public class Meiju &#123; private State state = State.DRIVING; public State getState() &#123; return state; &#125; public void setState(State state) &#123; this.state = state; &#125;&#125;public class Main &#123; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; Class clz = State.class; if (clz.isEnum()) &#123; System.out.println(clz.getName() + &quot; is Enum&quot;); System.out.println(Arrays.asList(clz.getEnumConstants())); Field[] fields = clz.getDeclaredFields(); for (Field field : fields) &#123; if (field.isEnumConstant()) &#123; System.out.println(field.getName() + &quot;is EnumConstant&quot;); &#125; else &#123; System.out.println(field.getName() + &quot;is not EnumConstant&quot;); &#125; &#125; &#125; Class cMeiJu = Meiju.class; Meiju meiju = new Meiju(); Field field = cMeiJu.getDeclaredField(&quot;state&quot;); field.setAccessible(true); State state = (State) field.get(meiju); System.out.println(&quot;state:=====&quot;+state); field.set(meiju, State.STOPPING); System.out.println(&quot;State current is &quot;+meiju.getState()); &#125;&#125; 结果: 123456789cn.smartsean.enumreflect.State is Enum[IDLE, DRIVING, STOPPING, test]IDLEis EnumConstantDRIVINGis EnumConstantSTOPPINGis EnumConstanttestis EnumConstant$VALUESis not EnumConstantstate:=====DRIVINGState current is STOPPING 反射总结1、Java 中的反射是非常规编码方式。2、Java 反射机制的操作入口是获取 Class 文件。 有 Class.forName()、 .class 和 Object.getClass() 3 种。3、获取 Class 对象后还不够，需要获取它的 Members，包含 Field、Method、Constructor。4、Field 操作主要涉及到类别的获取，及数值的读取与赋值。5、Method 算是反射机制最核心的内容，通常的反射都是为了调用某个 Method 的 invoke() 方法。6、通过 Class.newInstance() 和 Constructor.newInstance() 都可以创建类的对象实例，但推荐后者。因为它适应于任何构造方法，而前者只会调用可见的无参数的构造方法。7、数组和枚举可以被看成普通的 Class 对待。最后，需要注意的是。 反射是非常规开发手段，它会抛弃 Java 虚拟机的很多优化，所以同样功能的代码，反射要比正常方式要慢，所以考虑到采用反射时，要考虑它的时间成本。另外，就如无人驾驶之于汽车一样，用着很爽的同时，其实风险未知。","categories":[],"tags":[],"keywords":[]},{"title":"自定义 View 实战（一）做一个简单的进度条","slug":"自定义-View-实战（一）做一个简单的进度条-1","date":"2018-02-06T02:23:02.000Z","updated":"2018-02-06T08:20:41.475Z","comments":true,"path":"2018/02/06/自定义-View-实战（一）做一个简单的进度条-1/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2018/02/06/自定义-View-实战（一）做一个简单的进度条-1/","excerpt":"","text":"自定义 View 实战（一）做一个简单的进度条前言自定义 View 是每个 Android 程序员走向高级必经之路，本篇通过实现一个非常简单的自定义 View ，来简单了解下自定义 View 的流程。（最后会给出源码） 先看下效果： 录制的 gif 可能看不清，欢迎去 Github下载项目运行查看。 一、分析需求这个 View 是我前段时间做公司项目的时候写的，要求的功能比较简单: 根据给出的百分比显示进度条 中间一直存在的线条 进度条的颜色 线条的颜色 进度条是否有动画效果 需求简单，所以实现起来也很简单的，接下来就一步一步的实现。 二、定义属性并获取根据上面的分析，我们在 res/values 下面新建文件 attrs.xml，定义我们需要的属性如下： 12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"LineProgressBar\"&gt; &lt;!--进度条颜色--&gt; &lt;attr name=\"progress_color\" format=\"color\" /&gt; &lt;!--中间线的颜色--&gt; &lt;attr name=\"progress_line_color\" format=\"color\" /&gt; &lt;!--进度条的值--&gt; &lt;attr name=\"progress\" format=\"integer\" /&gt; &lt;!--是否有动画效果--&gt; &lt;attr name=\"is_smooth_progress\" format=\"boolean\" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 上面的属性的定义是在布局文件中使用的。 然后我们需要在自定义的 View 里面对应获取 xml 中定义的属性。 由于我们定义的是进度条，需要有最大值，根据百分比来显示进度。 新建 LineProgressBar 继承于 View： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @author smartsean */public class LineProgressBar extends View &#123; //进度条的最大值 private static final int MAX_PROGRESS = 100; //默认中间线颜色 private static final int DEFAULT_LINE_COLOR = Color.parseColor(\"#e6e6e6\"); //默认进度条颜色 private static final int DEFAULT_PROGRESS_COLOR = Color.parseColor(\"#71db77\"); /** * progress底部线的画笔 */ private Paint linePaint; /** * progress画笔 */ private Paint progressPaint; /** * progress底部线的颜色 */ private int lineColor; /** * progress的颜色 */ private int progressColor; /** * 进度值 百分比 */ private float progress; /** * 是否平滑显示progress */ private boolean isSmoothProgress; public LineProgressBar(Context context) &#123; this(context, null); &#125; public LineProgressBar(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public LineProgressBar(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context, attrs); &#125;&#125; 接下来，我们需要在 init(context, attrs) 里面获取 attrs.xml 中定义的属性，并进行一些初始化。 123456789101112/** * 初始化参数 */private void init(Context context, AttributeSet attrs) &#123; TypedArray attributes = context.obtainStyledAttributes(attrs, R.styleable.LineProgressBar); lineColor = attributes.getColor(R.styleable.LineProgressBar_progress_line_color, DEFAULT_LINE_COLOR); progressColor = attributes.getColor(R.styleable.LineProgressBar_progress_color, DEFAULT_PROGRESS_COLOR); progress = attributes.getInteger(R.styleable.LineProgressBar_progress, 0) / MAX_PROGRESS; isSmoothProgress = attributes.getBoolean(R.styleable.LineProgressBar_is_smooth_progress, true); attributes.recycle(); initializePainters();&#125; 三、测量重写 onMeasure 方法，测量 View 的真实宽高 12345678910111213141516171819202122232425@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(measure(widthMeasureSpec, true), measure(heightMeasureSpec, false));&#125;private int measure(int measureSpec, boolean isWidth) &#123; int result; int mode = MeasureSpec.getMode(measureSpec); int size = MeasureSpec.getSize(measureSpec); int padding = isWidth ? getPaddingLeft() + getPaddingRight() : getPaddingTop() + getPaddingBottom(); if (mode == MeasureSpec.EXACTLY) &#123; result = size; &#125; else &#123; result = isWidth ? getSuggestedMinimumWidth() : getSuggestedMinimumHeight(); result += padding; if (mode == MeasureSpec.AT_MOST) &#123; if (isWidth) &#123; result = Math.max(result, size); &#125; else &#123; result = Math.min(result, size); &#125; &#125; &#125; return result;&#125; 分析之前先看几个概念： 一个 MeasureSpec 被分为两部分 mode 用来存储测量模式，由 MeasureSpec 的高两位存储 size 用来存储大小，由 MeasureSpec 的低30位存储 mode 模式分为三种： UNSPECIFIED 未指定模式，View 想多大就多大，父容器不做限制，一般用于系统内部的测量 AT_MOST ：最大模式，对应于 layout_width 或者 layout_height 设置为 wrap_content ，子 View 的最终大小是最终父 View 指定的 size 值，并且子 View 的最终大小不能大于这个 size 值。 EXACTLY 精确模式，对应于layout_width 或者 layout_height 设置为 match_parent 或者 具体的值（比如12dp），父容器测量出 View 所需的大小，也就是 size 的值。 接下来开始具体的测量，首先 measure 是一个公共方法，用来测量 View 宽和高。 这里以测量宽为例分析下 measure 方法： 12int mode = MeasureSpec.getMode(measureSpec);int size = MeasureSpec.getSize(measureSpec); MeasureSpec.getMode(measureSpec) 获得测量模式 modeMeasureSpec.getSize(measureSpec) 大小 size。\u0011 1int padding = isWidth ? getPaddingLeft() + getPaddingRight() : getPaddingTop() + getPaddingBottom(); 如果是测量宽，获取左侧和右侧的 padding 之和赋值给 padding。如果是测量高，获取底部和顶部的 padding 之和赋值给 padding。 12345678910111213if (mode == MeasureSpec.EXACTLY) &#123; result = size;&#125; else &#123; result = isWidth ? getSuggestedMinimumWidth() : getSuggestedMinimumHeight(); result += padding; if (mode == MeasureSpec.AT_MOST) &#123; if (isWidth) &#123; result = Math.max(result, size); &#125; else &#123; result = Math.min(result, size); &#125; &#125;&#125; 如果测量值为精确模式 MeasureSpec.EXACTLY ，View 已经明确了自己的大小，那么直接返回 size。 如果测量模式是 UNSPECIFIED 或者 AT_MOST，取 getSuggestedMinimumWidth ，那么这个 getSuggestedMinimumWidth（） 是什么呢？ 来看下源码： 123protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125; 可以看到，先判断了背景 mBackground 是不是为空 如果为空，就直接取 mMinWidth 的值，也就是对应 xml 中的 android:minWidth 如果不为空，取 mMinWidth 和 mBackground 背景的最小宽度。 具体到本实例就是说：如果你设置了 wrap_content， 设置了 minWidth ，没有设置背景，就按照 minWidth 设置了 minWidth ，有设置背景，就取 minWidth 和 mBackground.getMinimumWidth() 的最大值 没设置 minWidth ，没有设置背景，就取 minWidth 的默认值0. 没设置了 minWidth ，有设置背景，就取 minWidth（默认值为0） 和 mBackground.getMinimumWidth() 的最大值 mBackground.getMinimumWidth() 就是背景 Drawable 的原始宽高。 有可能我们的 View 设置了 leftPadding 或者 rightPadding，然后再把上面计算的 padding 加到 result 上。 如果测量模式是 UNSPECIFIED ，那么本次测量就结束了。 但是如果测量模式是 AT_MOST，也就是设置了 MATCH_PARENT 或者设置了具体的值（比如12dp），还得继续取 result 和 size 中的最大值作为 View 最终的宽。 最后返回 result。 View 的宽度测量完毕，高度测量和宽度测量差不多，可以仔细体会下。 四、绘制绘制就比较简单了，只有两行代码： 123456@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawLine(0, getHeight() / 2.0f, getWidth(), getHeight() / 2.0f, linePaint); canvas.drawRoundRect(new RectF(0, 0, progress * getWidth(), getHeight()), getHeight() / 2.0f, getHeight() / 2.0f, progressPaint);&#125; 先来看第一行代码： 1canvas.drawLine(0, getHeight() / 2.0f, getWidth(), getHeight() / 2.0f, linePaint); 通过 canvas 的 drawLine 方法画出中间的线。 前两个参数表示画线的起点 0代表从 x 轴的起点开始画 getHeight() / 2.0f 表示从 y 轴向下 getHeight() / 2.0f 开始画。 后两个参数表示画线的终点 getWidth() 也就是整个 View 的宽度 getHeight() / 2.0f 依旧表示从 y 轴向下 getHeight() / 2.0f 开始画。 再来看第二行代码： 1canvas.drawRoundRect(new RectF(0, 0, progress * getWidth(), getHeight()), getHeight() / 2.0f, getHeight() / 2.0f, progressPaint); 第一个参数： 12//表示整个View的所在的矩形new RectF(0, 0, progress * getWidth(), getHeight()) 第二个参数和第三个参数都是 getHeight() / 2.0f ，表示的是 View 在 x 轴和 y 轴上的圆角半径。 最后一个参数是画进度条的画笔。 只有这两行代码就可以实现整个自定义 View 的绘制。 整个核心绘制已经结束了。 但是我们需要在 Java 代码中动态的更改 View 的进度，所以需要在 View 添加 setProgress 方法如下： 123456789101112131415161718/** * 设置进度 * * @param pProgress */public void setProgress(float pProgress) &#123; if (pProgress &gt; 1) &#123; pProgress = 1; &#125; else if (pProgress &lt; 0) &#123; pProgress = 0; &#125; if (isSmoothProgress) &#123; smoothRun(this.progress, pProgress); &#125; else &#123; this.progress = pProgress; invalidate(); &#125;&#125; 很简单，如果大于 1，那么就绘制最大进度值 1，如果小于 0，就绘制最小进度值 0.如果在 0 和 1 之间： 设置带动画的滑动就调用 smoothRun 这个方法。 如果不带动画，就直接 invalidate 刷新。 看下 smoothRun 方法： 12345678910111213141516171819/** * 设置平滑滑动 * * @param currentProgress * @param targetProgress */private void smoothRun(float currentProgress, float targetProgress) &#123; ValueAnimator valueAnimator = ValueAnimator.ofFloat(currentProgress, targetProgress); valueAnimator.setTarget(this.progress); valueAnimator.setDuration(1000); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; progress = (float) animation.getAnimatedValue(); invalidate(); &#125; &#125;); valueAnimator.start();&#125; 首先根据传入的当前的进度值和要显示的进度值创建 ValueAnimator 对象。 设置操作的动画属性为 this.progress。 设置动画时长 1000 毫秒。 然后监听动画过程，动态的给 progress 赋值，不断的刷新 View ，达到动画效果。 最后再开始动画。 最后前面就是绘制一个简单的自定义 View 的全部过程，虽然代码量不多，但是要考虑的东西还是不少的。接下来还会继续把项目中用到的自定义 View 分享出来。 代码地址如下：attrs.xml LineProgressBar.java 使用实例 你可以通过以下方式关注我： CSDN 掘金 个人博客","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"},{"name":"自定义View","slug":"自定义View","permalink":"https://github.com/smartsean/smartsean.github.io/tags/自定义View/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"我追求的高效之路","slug":"我追求的高效之路","date":"2018-02-02T08:26:11.000Z","updated":"2018-02-02T08:27:50.217Z","comments":true,"path":"2018/02/02/我追求的高效之路/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2018/02/02/我追求的高效之路/","excerpt":"","text":"我追求的高效之路一、先说下我自己吧。我这个人比较追求效率，我认为工作中不应该被我们使用的工具所浪费时间，高效才是最终致胜的法宝。 电脑我用来学习和工作的电脑，不仅要运行速度快，还得用起来舒适，不喜欢学习、工作的时候被一些外在因素所限制进度，所以卡顿是我绝对不能忍受的。所以在我忍受不了公司的 ThinkPad 之后，用上了 MacBookPro，虽说是 2015 年的低配，但是用起来不卡顿，各种效率工具配合起来，比以前用 windows 电脑，效率最起码提升了 20%。所以我觉得这方便还是要有点追求的。 事项管理前面说了我追求效率，所以我会去寻找一些工具去提高我的学习和工作效率，用的最多的就是滴答清单了，滴答清单是我在筛选了好久之后选出来了。用了一年多了，感觉非常不错，我可以随时记录下当天或者第二天有什么事情要干，先随手记录到收集箱，每天到公司稍作整理就可以愉快的工作，基本不会遗漏一些重要的事情，现在已经付费使用，配合我 Android 手机上的 Widget，可以很方便不用打开 App 看到这个月有什么代办事项，美滋滋，真是感觉应该早点付费。 记录反馈这个方面就比较尴尬了，我用了好多软件，有 MWeb、印象笔记（我还付了费）、有道云笔记、OneNote、博客。导致我的文档比较混乱，不易管理。没有一个清晰的工作流。为了避免这种尴尬的情况，必须要定制一个软件使用规范： 每天使用 OneNote 进行琐碎记录。 每周末对 OneNote 上本周的记录进行归纳整理到印象笔记。 MWeb 只用来写博客，因为可以方便的把图片一键传到自己的七牛云。 那如何保证上面的规范的执行呢。这就要用到我上面提到的滴答清单。 针对第一条，我会创建一个任务，每天循环，告诉我每天用 OneNote 记录笔记。 针对第二条，我会创建一个任务，每周循环，在每个周末提醒我整理笔记。 针对第三条，我会在有写博客计划的时候，创建一个任务，任务里面描述使用 MWeb 来写博客。 以后坚决不被其他 MarkDown 写作工具吸引，老老实实使用 MWeb。 博客发布通过前段时间的简书程序员事件之后，我已经提不起在简书发表文章的欲望了，决定从今天起，认真的维护好我的博客，主要发布到三个地方： CSDN 掘金 个人博客 那流程是怎样的呢？ 博客在 MWeb 完成之后， 新博客：MWeb 来写博客，写完成之后，发布到 CSDN 和个人博客，然后去掘金分享文章，绝不拖拉。 编辑博客：MWeb 来编辑，编辑完成之后，发布到 CSDN 和个人博客，绝不拖拉。 哦，对了，博客写完之后，一定得自己读一遍再发布，有的很明显的错误，自己看了都尴尬。 先写这么多吧，有新的想法再随时更新吧。","categories":[{"name":"我","slug":"我","permalink":"https://github.com/smartsean/smartsean.github.io/categories/我/"}],"tags":[{"name":"我","slug":"我","permalink":"https://github.com/smartsean/smartsean.github.io/tags/我/"}],"keywords":[{"name":"我","slug":"我","permalink":"https://github.com/smartsean/smartsean.github.io/categories/我/"}]},{"title":"一步一步使用 DialogFragment 封装链式调用 Dialog","slug":"一步一步使用 DialogFragment 封装链式调用 Dialog","date":"2018-01-29T11:17:48.000Z","updated":"2018-01-31T10:12:13.099Z","comments":true,"path":"2018/01/29/一步一步使用 DialogFragment 封装链式调用 Dialog/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2018/01/29/一步一步使用 DialogFragment 封装链式调用 Dialog/","excerpt":"","text":"一步一步使用 DialogFragment 封装链式调用 Dialog前言日常开发中，Dialog 是一个每个 app 所必备的。 2018-01-31更新最后封装好的 BaseDialogFragment 已经添加到我的快速开发 lib 包中。 可以通过：implementation cn.smartsean:lib:0.0.7 快速引入， 也可以去 AndroidCode 查看示例源码。 通常来说，每个 app 的Dialog 的样式一般都是统一风格的，比如说有： 确认、取消的 Dialog 提示性的 Dialog 列表选择的 Dialog 版本更新的 Dialog 带输入框的 Dialog 如果每个都要单独写，就显得有点浪费了，一般情况下，我们都需要进行封装，便于使用和阅读。 那为什么要使用 DialogFragment 呢？ 使用 DialogFragment 来管理对话框，当旋转屏幕和按下后退键时可以更好的管理其生命周期，它和 Fragment 有着基本一致的生命周期。 并且 DialogFragment 也允许开发者把 Dialog 作为内嵌的组件进行重用，类似 Fragment （可以在大屏幕和小屏幕显示出不同的效果） 那么接下来我们就一步一步的来封装出一个便于我们使用的 DialogFragment。 还是先看下效果图吧，可能有点不是很好看，毕竟没有 ui，哈哈 一、构建 BaseDialogFragment1.1 明确我们需要的属性在构建 BaseDialogFragment 之前，我们先分析下正常情况下，我们使用 Dialog 都需要哪些属性： Dialog 的宽和高 Dialog 的对其方式 Dialog 在 x 和 y 坐标系的偏移量 Dialog 的显示隐藏的动画 Dialog 给调用者的回调 Dialog 消失时候的回调 Dialog 是否可以点击外部消失 当然，有的需求要不了这么多的属性，也有的人需要更多的属性，那就需要自己去探索了，我就讲下基于上面这些属性的封装，然后你可以基于我的 BaseDialogFragment 进行扩展。 有了上面的属性，我们就明白了在 BaseDialogFragment 中我们需要的字段:新建 BaseDialogFragment 1234567891011public abstract class BaseDialogFragment extends DialogFragment &#123; private int mWidth = WRAP_CONTENT; private int mHeight = WRAP_CONTENT; private int mGravity = CENTER; private int mOffsetX = 0; private int mOffsetY = 0; private int mAnimation = R.style.DialogBaseAnimation; protected DialogResultListener mDialogResultListener; protected DialogDismissListener mDialogDismissListener;&#125; mWidth 是 Dialog 的宽 mHeight 是 Dialog 的高 mGravity 是 Dialog 的出现位置 mOffsetX 是 Dialog 在 x 方向上的偏移 mOffsetY 是 Dialog 在 y 方向上的偏移 mAnimation 是 Dialog 的动画 mDialogResultListener 是 Dialog 返回结果的回调 mDialogDismissListener 是 Dialog 取消时的回调 DialogBaseAnimation 是我自己定义的基本的动画样式，在 res-value-styles 下： 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;style name=\"DialogBaseAnimation\"&gt; &lt;item name=\"android:windowEnterAnimation\"&gt;@anim/dialog_enter&lt;/item&gt; &lt;item name=\"android:windowExitAnimation\"&gt;@anim/dialog_out&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 在 res下新建文件夹 anim ，然后在里面新建两个文件：1、dialog_enter.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate android:fromYDelta=&quot;100%p&quot; android:toYDelta=&quot;0%p&quot; android:duration=&quot;200&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;/translate&gt; 2、dialog_out.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate android:fromYDelta=&quot;0%p&quot; android:toYDelta=&quot;100%p&quot; android:duration=&quot;200&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;/translate&gt; 我们需要的基本属性已经好了，接下来就是如何通过构建者模式来赋值了。 1.2 构建 Builder我们在 BaseDialogFragment 中新建 Builder: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * @author SmartSean */public abstract class BaseDialogFragment extends DialogFragment &#123; private int mWidth = WRAP_CONTENT; private int mHeight = WRAP_CONTENT; private int mGravity = CENTER; private int mOffsetX = 0; private int mOffsetY = 0; private int mAnimation = R.style.DialogBaseAnimation; protected DialogResultListener mDialogResultListener; protected DialogDismissListener mDialogDismissListener; public static abstract class Builder&lt;T extends Builder, D extends BaseDialogFragment&gt; &#123; private int mWidth = WRAP_CONTENT; private int mHeight = WRAP_CONTENT; private int mGravity = CENTER; private int mOffsetX = 0; private int mOffsetY = 0; private int mAnimation = R.style.DialogBaseAnimation; public T setSize(int mWidth, int mHeight) &#123; this.mWidth = mWidth; this.mHeight = mHeight; return (T) this; &#125; public T setGravity(int mGravity) &#123; this.mGravity = mGravity; return (T) this; &#125; public T setOffsetX(int mOffsetX) &#123; this.mOffsetX = mOffsetX; return (T) this; &#125; public T setOffsetY(int mOffsetY) &#123; this.mOffsetY = mOffsetY; return (T) this; &#125; public T setAnimation(int mAnimation) &#123; this.mAnimation = mAnimation; return (T) this; &#125; protected abstract D build(); protected void clear() &#123; this.mWidth = WRAP_CONTENT; this.mHeight = WRAP_CONTENT; this.mGravity = CENTER; this.mOffsetX = 0; this.mOffsetY = 0; &#125; &#125;&#125; 可以看到： Builder 是一个泛型抽象类，可以传入当前 Buidler 的子类 T 和 BaseDialogFragment 的子类 D， 我们在 Builder 中对可以在 Bundle 中存储的变量都进行了赋值，并且返回泛型 T,在最终的抽象方法 build() 中返回泛型 D。 这里使用抽象的 build() 方法是因为：每个最终的 Dialog 返回的内容是不一样的，需要子类去实现。 你可能会问，前面定义的 mDialogResultListener 和 mDialogDismissListener 怎么没在 Buidler 中出现呢？ 我们知道 接口类型是不能存储在 Bundle 中的，所以我们放在了 BaseDialogFragment 中，后面你会看到，不要急。。。 1.3 让子类也能使用这些属性为了能够让子类也能使用我们在上面 Builder 中构建的属性，我们需要写一个方法，把 Builder 中获取到的值放到 Bundle 中，然后在 Fragment 的 onCreate 方法中进行赋值， 获取 Bundle ： 12345678910protected static Bundle getArgumentBundle(Builder b) &#123; Bundle bundle = new Bundle(); bundle.putInt(\"mWidth\", b.mWidth); bundle.putInt(\"mHeight\", b.mHeight); bundle.putInt(\"mGravity\", b.mGravity); bundle.putInt(\"mOffsetX\", b.mOffsetX); bundle.putInt(\"mOffsetY\", b.mOffsetY); bundle.putInt(\"mAnimation\", b.mAnimation); return bundle;&#125; 在 onCreate 中赋值： 123456789101112@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (getArguments() != null) &#123; mWidth = getArguments().getInt(\"mWidth\"); mHeight = getArguments().getInt(\"mHeight\"); mOffsetX = getArguments().getInt(\"mOffsetX\"); mOffsetY = getArguments().getInt(\"mOffsetY\"); mAnimation = getArguments().getInt(\"mAnimation\"); mGravity = getArguments().getInt(\"mGravity\"); &#125;&#125; 这样我们就可以在子类中 通过 getArgumentBundle 方法拿到 通过 Builder 拿到的值了。并且不需要在每个子 Dialog 中获取这些值了，因为父类已经在 onCreate 中取过了。 1.4 重写 onCreateView 方法使用 DialogFragment 必须重写 onCreateView 或者 onCreateDialog ，我们这里选择使用重写 onCreateView，因为我觉得一个项目中的 Dialog 中的样式不会有太多，重写 onCreateView 这样灵活性高，复用起来很方便。 123456@Nullable@Overridepublic View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123; setStyle(); return setView(inflater, container, savedInstanceState);&#125; 首先我们通过 style() 设置了 Dialog 所要遵循的样式： 123456789101112131415161718192021222324/** * 设置统一样式 */private void setStyle() &#123; //获取Window Window window = getDialog().getWindow(); //无标题 getDialog().requestWindowFeature(STYLE_NO_TITLE); // 透明背景 getDialog().getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)); //设置宽高 window.getDecorView().setPadding(0, 0, 0, 0); WindowManager.LayoutParams wlp = window.getAttributes(); wlp.width = mWidth; wlp.height = mHeight; //设置对齐方式 wlp.gravity = mGravity; //设置偏移量 wlp.x = DensityUtil.dip2px(getDialog().getContext(), mOffsetX); wlp.y = DensityUtil.dip2px(getDialog().getContext(), mOffsetY); //设置动画 window.setWindowAnimations(mAnimation); window.setAttributes(wlp);&#125; 而 setView 则是一个抽象方法，让子类根据实际需求去实现： 1protected abstract View setView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState); 1.5 实现 Dialog 回调事件看下我们定义的两个回调： 123public interface DialogResultListener&lt;T&gt; &#123; void result(T result);&#125; 123public interface DialogDismissListener&#123; void dismiss(DialogFragment dialog);&#125; 给我们的 DialogFragment 回调赋值： 123456789public BaseDialogFragment setDialogResultListener(DialogResultListener dialogResultListener) &#123; this.mDialogResultListener = dialogResultListener; return this;&#125;public BaseDialogFragment setDialogDismissListener(DialogDismissListener dialogDismissListener) &#123; this.mDialogDismissListener = dialogDismissListener; return this;&#125; 这里我们通过 set 方法给两个回调监听赋值，并且最终都返回 this，但是这里并不是真的返回 BaseDialogFragment，而是调用该方法的 BaseDialogFragment 的子类。 至于为什么不放到 Builder 里面，前面已经说了，接口实例不能放到 Bundle 中。 然后在 onDismiss 中回调我们的 DialogDismissListener 1234567@Overridepublic void onDismiss(DialogInterface dialog) &#123; super.onDismiss(dialog); if (mDialogDismissListener != null) &#123; mDialogDismissListener.dismiss(this); &#125;&#125; 至于 DialogResultListener 则需要根据具体的 Dialog 实现去回调不同的内容。 至此，我们的基础搭建已经完成，这里再贴下完整的代码，不需要的直接略过，往后翻去看具体实现。 BaseDialogFragment 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/** * @author SmartSean */public abstract class BaseDialogFragment extends DialogFragment &#123; private int mWidth = WRAP_CONTENT; private int mHeight = WRAP_CONTENT; private int mGravity = CENTER; private int mOffsetX = 0; private int mOffsetY = 0; private int mAnimation = R.style.DialogBaseAnimation; protected DialogResultListener mDialogResultListener; protected DialogDismissListener mDialogDismissListener; protected static Bundle getArgumentBundle(Builder b) &#123; Bundle bundle = new Bundle(); bundle.putInt(\"mWidth\", b.mWidth); bundle.putInt(\"mHeight\", b.mHeight); bundle.putInt(\"mGravity\", b.mGravity); bundle.putInt(\"mOffsetX\", b.mOffsetX); bundle.putInt(\"mOffsetY\", b.mOffsetY); bundle.putInt(\"mAnimation\", b.mAnimation); return bundle; &#125; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (getArguments() != null) &#123; mWidth = getArguments().getInt(\"mWidth\"); mHeight = getArguments().getInt(\"mHeight\"); mOffsetX = getArguments().getInt(\"mOffsetX\"); mOffsetY = getArguments().getInt(\"mOffsetY\"); mAnimation = getArguments().getInt(\"mAnimation\"); mGravity = getArguments().getInt(\"mGravity\"); &#125; &#125; protected abstract View setView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState); @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123; setStyle(); return setView(inflater, container, savedInstanceState); &#125; /** * 设置统一样式 */ private void setStyle() &#123; //获取Window Window window = getDialog().getWindow(); //无标题 getDialog().requestWindowFeature(STYLE_NO_TITLE); // 透明背景 getDialog().getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)); //设置宽高 window.getDecorView().setPadding(0, 0, 0, 0); WindowManager.LayoutParams wlp = window.getAttributes(); wlp.width = mWidth; wlp.height = mHeight; //设置对齐方式 wlp.gravity = mGravity; //设置偏移量 wlp.x = DensityUtil.dip2px(getDialog().getContext(), mOffsetX); wlp.y = DensityUtil.dip2px(getDialog().getContext(), mOffsetY); //设置动画 window.setWindowAnimations(mAnimation); window.setAttributes(wlp); &#125; @Override public void onDismiss(DialogInterface dialog) &#123; super.onDismiss(dialog); if (mDialogDismissListener != null) &#123; mDialogDismissListener.dismiss(this); &#125; &#125; public BaseDialogFragment setDialogResultListener(DialogResultListener dialogResultListener) &#123; this.mDialogResultListener = dialogResultListener; return this; &#125; public BaseDialogFragment setDialogDismissListener(DialogDismissListener dialogDismissListener) &#123; this.mDialogDismissListener = dialogDismissListener; return this; &#125; public static abstract class Builder&lt;T extends Builder, D extends BaseDialogFragment&gt; &#123; private int mWidth = WRAP_CONTENT; private int mHeight = WRAP_CONTENT; private int mGravity = CENTER; private int mOffsetX = 0; private int mOffsetY = 0; private int mAnimation = R.style.DialogBaseAnimation; public T setSize(int mWidth, int mHeight) &#123; this.mWidth = mWidth; this.mHeight = mHeight; return (T) this; &#125; public T setGravity(int mGravity) &#123; this.mGravity = mGravity; return (T) this; &#125; public T setOffsetX(int mOffsetX) &#123; this.mOffsetX = mOffsetX; return (T) this; &#125; public T setOffsetY(int mOffsetY) &#123; this.mOffsetY = mOffsetY; return (T) this; &#125; public T setAnimation(int mAnimation) &#123; this.mAnimation = mAnimation; return (T) this; &#125; protected abstract D build(); protected void clear() &#123; this.mWidth = WRAP_CONTENT; this.mHeight = WRAP_CONTENT; this.mGravity = CENTER; this.mOffsetX = 0; this.mOffsetY = 0; &#125; &#125;&#125; 二、如何方便的构建 Dialog这里我们以确认、取消选择框为例： 2.1 首先，我们需要新建 ConfirmDialog 继承于 我们的 BaseDialogFragment：1234567public class ConfirmDialog extends BaseDialogFragment &#123; @Override protected View setView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123; return null; &#125;&#125; 2.2 构造 Dialog 正常显示需要的值在通常的确认、取消选择框中，我们需要传入的值有什么呢？ 来看下具体的展示： 标题 内容 取消的提示文字 确定的提示文字 这里我们定义四个 静态字符换常量: 1234private static final String LEFT_TEXT = \"left_text\";private static final String RIGHT_TEXT = \"right_text\";private static final String PARAM_TITLE = \"title\";private static final String PARAM_MESSAGE = \"message\"; 接下来我们需要在 Builder 中传入这些值： 新建 Buidler 继承于 BaseDialogFragment 的 Buidler： 1234567891011121314151617181920212223242526272829303132public static class Builder extends BaseDialogFragment.Builder&lt;Builder, ConfirmDialog&gt; &#123; private String mTitle; private String mMessage; private String leftText; private String rightText; public Builder setTitle(String title) &#123; mTitle = title; return this; &#125; public Builder setMessage(String message) &#123; mMessage = message; return this; &#125; public Builder setLeftText(String leftText) &#123; this.leftText = leftText; return this; &#125; public Builder setRightText(String rightText) &#123; this.rightText = rightText; return this; &#125; @Override protected ConfirmDialog build() &#123; return ConfirmDialog.newInstance(this); &#125;&#125; 在 build 方法中我们返回了 ConfirmDialog的实例，来看下 newInstance 方法： 12345678910private static ConfirmDialog newInstance(Builder builder) &#123; ConfirmDialog dialog = new ConfirmDialog(); Bundle bundle = getArgumentBundle(builder); bundle.putString(LEFT_TEXT, builder.leftText); bundle.putString(RIGHT_TEXT, builder.rightText); bundle.putString(PARAM_TITLE, builder.mTitle); bundle.putString(PARAM_MESSAGE, builder.mMessage); dialog.setArguments(bundle); return dialog;&#125; 可以看到，我们 new 出了一个 ConfirmDialog 实例，然后通过 getArgumentBundle(builder) 获得了在 BaseDialogFragment 中获取的到值，并且放到了 Bundle 中。 很显然，我们这个 ConfirmDialog 还需要 标题 builder.mTitle 内容 builder.mMessage 取消的提示文字 builder.leftText 确定的提示文字 builder.rightText 最后通过 dialog.setArguments(bundle);传入到 ConfirmDialog 中，返回我们新建的 dialog 实例。 2.3 把值展示到界面上我们新建 dialog_confirm.xml： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#ffffff&quot; android:orientation=&quot;vertical&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:background=&quot;#ffffff&quot;&gt; &lt;TextView android:background=&quot;#9d9d9d&quot; android:id=&quot;@+id/title&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; android:gravity=&quot;center&quot; android:text=&quot;我是标题&quot; /&gt; &lt;TextView android:padding=&quot;24dp&quot; android:id=&quot;@+id/message&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_below=&quot;@+id/title&quot; android:gravity=&quot;start&quot; android:text=&quot;我是message&quot; /&gt; &lt;/RelativeLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/cancel_btn&quot; android:layout_width=&quot;101dp&quot; android:layout_height=&quot;46dp&quot; android:layout_weight=&quot;1&quot; android:text=&quot;取消&quot; /&gt; &lt;Button android:id=&quot;@+id/confirm_btn&quot; android:layout_width=&quot;103dp&quot; android:layout_height=&quot;48dp&quot; android:layout_weight=&quot;1&quot; android:text=&quot;确定&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 这个时候就需要在 setView 方法中获取到 dialog_confirm.xml 的控件，然后进行赋值和事件操作： setView() 方法如下: 123456789101112131415161718192021222324252627282930313233343536373839404142@Overrideprotected View setView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.dialog_confirm, container, false); TextView titleTv = view.findViewById(R.id.title); TextView messageTv = view.findViewById(R.id.message); if (!TextUtils.isEmpty(getArguments().getString(PARAM_TITLE))) &#123; titleTv.setText(getArguments().getString(PARAM_TITLE)); &#125; if (!TextUtils.isEmpty(getArguments().getString(PARAM_MESSAGE))) &#123; messageTv.setText(getArguments().getString(PARAM_MESSAGE)); &#125; setBottomButton(view); return view;&#125;protected void setBottomButton(View view) &#123; Button cancelBtn = view.findViewById(R.id.cancel_btn); Button confirmBtn = view.findViewById(R.id.confirm_btn); if (getArguments() != null) &#123; cancelBtn.setText(getArguments().getString(LEFT_TEXT)); confirmBtn.setText(getArguments().getString(RIGHT_TEXT)); cancelBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (mDialogResultListener != null) &#123; mDialogResultListener.result(false); dismiss(); &#125; &#125; &#125;); confirmBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (mDialogResultListener != null) &#123; mDialogResultListener.result(true); dismiss(); &#125; &#125; &#125;); &#125;&#125; 3.4 最后的调用：在 MainActivity 中: 1234567891011121314151617181920ConfirmDialog.newConfirmBuilder() .setTitle(\"这是一个带有确认、取消的dialog\") .setMessage(\"这是一个带有确认、取消的dialog的message\") .setLeftText(\"我点错了\") .setRightText(\"我确定\") .setAnimation(R.style.DialogAnimFromCenter) .build() .setDialogResultListener(new DialogResultListener&lt;Boolean&gt;() &#123; @Override public void result(Boolean result) &#123; Toast.makeText(mContext, \"你点击了：\" + (result ? \"确定\" : \"取消\"), Toast.LENGTH_SHORT).show(); &#125; &#125;) .setDialogDismissListener(new DialogDismissListener() &#123; @Override public void dismiss(DialogFragment dialog) &#123; Toast.makeText(mContext, \"我的tag：\" + dialog.getTag(), Toast.LENGTH_SHORT).show(); &#125; &#125;) .show(getFragmentManager(), \"confirmDialog\"); 是不是调用起来很简单，当项目中的 Dialog 样式统一的时候，用这种封装是很方便的，我们只用更改传入的值就可以得到不同的 Dialog，不用写那么多的重复代码，省下的时间可以让我们做很多事情。 如果你有更好的想法，欢迎提出来~~~","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Dagger2 + MVP的简单封装","slug":"Dagger2-MVP的简单封装","date":"2018-01-25T05:03:26.000Z","updated":"2018-03-20T05:04:23.727Z","comments":true,"path":"2018/01/25/Dagger2-MVP的简单封装/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2018/01/25/Dagger2-MVP的简单封装/","excerpt":"","text":"Dagger2 + MVP的简单封装现在很多 Android 开发都在用 MVP 模式，并且现在 Dagger2 注入依赖也挺方便的，所以就简单的对两者做了个封装，这样使用起来会更加方便。我们这里不对 MVP 做具体的讲解，只是简单的封装一下，便于使用，具体的 MVP 使用请参考其他文章。 代码已上传到 Github，有兴趣的可以去下载运行。 准备工作Dagger引入123compile &apos;com.google.dagger:dagger:2.10&apos;compile &apos;com.google.dagger:dagger-android-support:2.10&apos; // if you use the support librariesannotationProcessor &apos;com.google.dagger:dagger-compiler:2.10&apos; M层Model 层主要的职责有： 从网络，数据库，文件，传感器，第三方等数据源读写数据。 对外部的数据类型进行解析转换为APP内部数据交由上层处理。 对数据的临时存储,管理，协调上层数据请求。 我们首先来定义接口 IModel ： 123public interface IModel &#123; void onDestroy();&#125; 创建接口 BaseModel 继承于 IModel： 12public interface BaseModel extends IModel&#123;&#125; 这里在 IModel 中定义了 onDestroy（） 方法，我们知道，M 层主要是负责对数据进行操作的，我们难免会持有网络请求等其他的对象的引用，为了防止内存泄漏，我们需要在 Model 销毁的时候，通过 onDestroy（）方法中释放持有的引用。 V层在 MVP 开发中，View 层通常指的是 Activity 、Fragment、View、ViewGroup 等。 主要职责： 提供 UI 交互 在 Presenter 的控制下修改 UI。 将业务事件交由 Presenter 处理 View 层持有 Presenter 的引用，所以我们创建一个 BaseMvpActivity 如下： 1234567891011121314public abstract class BaseMvpActivity&lt;P extends BasePresenter&gt; extends AppCompatActivity &#123; @Inject protected P mPresenter; @Override protected void onDestroy() &#123; super.onDestroy(); if (null != mPresenter) &#123; mPresenter.onDestroy(); &#125; this.mPresenter = null; &#125;&#125; 可以看到，我们创建了个泛型 P ，并且这个泛型必须是 BasePresenter 的子类，可以看到定义 Presenter 的时候，上面有个注解是 @Inject ，这个注解就是 Dagger2 中的注解，使用这个注解就表示 mPresenter 是通过 Dagger2 注入的。另外在 Activity 销毁的时候，我们对持有的 Presenter 释放，防止内存泄漏。 然后我们再来定义一个接口 BaseView： 12public interface BaseView &#123;&#125; 这个接口就代表 View 层，我们使用的时候，一般需要针对每个页面都有一个接口继承于 BaseView，然后需要在具体的 Activity 中实现新定义的这个接口（比如 public interface IMainView estends BaseView ，我们就要实现 IMainView 这个接口，而不是 BaseView 这个接口）。也就是说我们平时写的页面都要继承于 BaseMvpActivity 并且 实现 BaseView 接口的子类。比如： 12345678public interface IMainView extends BaseView&#123;&#125;public class MainActivity extends BaseMvpActivity implements IMainView&#123;&#125; P层Presenter 层主要是连接 View 层和 Model 层的桥梁，负责把 View 层需要数据从 Model 层拿到，返回给 View 层； 所以我们在 P（Presenter） 层要持有 View 和 Model 层的引用。如下所示： 12345678910111213141516171819202122232425public class BasePresenter&lt;M extends BaseModel, V extends BaseView&gt; implements IPresenter &#123; protected M mModel; protected V mView; public BasePresenter(M model, V view) &#123; mModel = model; mView = view; &#125; public BasePresenter(V view) &#123; mView = view; &#125; @Override public void onDestroy() &#123; if (mModel != null) &#123; mModel.onDestroy(); &#125; this.mModel = null; this.mView = null; &#125;&#125; 可以看到，我们分别持有 View 层的引用 mView，Model 层的引用 mModel，为了防止内存泄漏，我们定义了一个 Ipresenter 接口， 123public interface IPresenter &#123; void onDestroy();&#125; 在 onDestroy() 方法中释放 View 层和 Model 层的引用。 使用现在我们基本的已经封装好了，那么下面就通过一个实例来试用下： 创建 Component1234@Component(modules = Login1Module.class)public interface Login1Component &#123; void inject(Login1Activity login1Activity);&#125; 创建 Module12345678910111213141516171819@Modulepublic class Login1Module &#123; private Login1Contract.ILoginView mILoginView; public Login1Module(Login1Contract.ILoginView ILoginView) &#123; mILoginView = ILoginView; &#125; @Provides Login1Contract.ILoginView getView() &#123; return mILoginView; &#125; @Provides Login1Contract.ILoginModel getModel(Login1Model model) &#123; return model; &#125;&#125; 创建契约来规定 Model 和 View分析 View 层和 Model 层需要的操作，定义接口如下： 1234567891011121314151617181920212223242526272829303132333435/** * 定义 View 和 Model 层规则 * Created by smartsean on 2018/1/10. */public interface Login1Contract &#123; interface ILoginModel extends BaseModel&#123; void login(String username, String password, OnLoginListener loginListener); &#125; interface ILoginView extends BaseView&#123; String getUserName(); String getPassword(); void clearUserName(); void clearPassword(); void showLoading(); void hideLoading(); void toMainActivity(UserInfoModel userInfoModel); void showFailedError(); &#125; interface OnLoginListener&#123; void loginSuccess(UserInfoModel userInfoModel); void loginFailed(); &#125;&#125; 创建 ModelModel 层主要是对数据操作的，我们这里开启线程模拟登录操作: 1234567891011121314151617181920212223242526272829303132333435363738/** * @author SmartSean Created on 2018/1/25 16:49. */public class Login1Model implements Login1Contract.ILoginModel &#123; @Inject public Login1Model() &#123; &#125; @Override public void login(final String username, final String password, final Login1Contract.OnLoginListener loginListener) &#123; new Thread() &#123; @Override public void run() &#123; super.run(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (\"sean\".equals(username) &amp;&amp; \"2\".equals(password)) &#123; UserInfoModel userInfoModel = new UserInfoModel(); userInfoModel.setUsername(username); userInfoModel.setPassword(password); loginListener.loginSuccess(userInfoModel); &#125; else &#123; loginListener.loginFailed(); &#125; &#125; &#125;.start(); &#125; @Override public void onDestroy() &#123; // TODO: 2018/1/25 销毁持有的引用 &#125;&#125; 创建 PresenterPresenter 层主要是连接 View 层和 Model 层的桥梁： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Login1Presenter extends BasePresenter&lt;Login1Contract.ILoginModel, Login1Contract.ILoginView&gt; &#123; @Inject public Login1Presenter(Login1Contract.ILoginModel model, Login1Contract.ILoginView view) &#123; super(model, view); &#125; private Handler mHandler = new Handler(); /** * 模拟登陆 */ public void login() &#123; mView.showLoading(); mModel.login(mView.getUserName(), mView.getPassword(), new Login1Contract.OnLoginListener() &#123; @Override public void loginSuccess(final UserInfoModel userInfoModel) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mView.toMainActivity(userInfoModel); mView.hideLoading(); &#125; &#125;); &#125; @Override public void loginFailed() &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mView.showFailedError(); mView.hideLoading(); &#125; &#125;); &#125; &#125;); &#125; @Override public void onDestroy() &#123; super.onDestroy(); // TODO: 2018/1/25 销毁持有的引用 &#125; /** * 清除账户名和密码 */ public void clear() &#123; mView.clearUserName(); mView.clearPassword(); &#125;&#125; 创建Activity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class Login1Activity extends BaseMvpActivity&lt;Login1Presenter&gt; implements Login1Contract.ILoginView &#123; private EditText usernameEt, passwordEt; private Button loginBtn, clearBtn; private ProgressDialog progressDialog; private Context mContext; private static final String TAG = \"Login1Activity\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login1); initView(); mContext = this; DaggerLogin1Component.builder().login1Module(new Login1Module(this)).build().inject(this); &#125; private void initView() &#123; usernameEt = findViewById(R.id.username_et); passwordEt = findViewById(R.id.password_et); loginBtn = findViewById(R.id.login_btn); clearBtn = findViewById(R.id.clear_btn); loginBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; mPresenter.login(); &#125; &#125;); clearBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; mPresenter.clear(); &#125; &#125;); progressDialog = new ProgressDialog(this); progressDialog.setTitle(\"加载中\"); &#125; @Override public String getUserName() &#123; return usernameEt.getText().toString().trim(); &#125; @Override public String getPassword() &#123; return passwordEt.getText().toString().trim(); &#125; @Override public void clearUserName() &#123; usernameEt.setText(\"\"); &#125; @Override public void clearPassword() &#123; passwordEt.setText(\"\"); &#125; @Override public void showLoading() &#123; progressDialog.show(); &#125; @Override public void hideLoading() &#123; progressDialog.dismiss(); &#125; @Override public void toMainActivity(UserInfoModel userInfoModel) &#123; MainActivity.startAction(this, userInfoModel.getUsername()); finish(); &#125; @Override public void showFailedError() &#123; Log.d(TAG, \"showFailedError: 登陆失败\"); Toast.makeText(mContext, \"登陆失败，请重新尝试\", Toast.LENGTH_SHORT).show(); &#125;&#125; 具体的代码 地址","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"清晰的Retrofit使用案例","slug":"清晰的Retrofit使用案例","date":"2018-01-17T15:50:21.000Z","updated":"2018-01-18T02:24:13.900Z","comments":true,"path":"2018/01/17/清晰的Retrofit使用案例/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2018/01/17/清晰的Retrofit使用案例/","excerpt":"","text":"清晰的 Retrofit 使用教程 这篇博客主要是为了记录描述下前段写的一个 Retrofit 使用 Demo 的，前段时间写了一个基本涵盖日常使用的 Rtrofit 使用的项目，但是发现当时是会了，后来就忘记了，还得去翻以前的项目，很是痛苦，所以决定写这篇博客记录下。 顺便说下，现在的很多介绍 Retrofit 的文章大多都是说的很理论，但我觉得实践才能出真知，所以本篇博客主要是通过一个个实例来让你知道怎么用的。 另外，看这篇博客需要先了解下 Retrofit，推荐看下 Carson_Ho大神的文章。 一、前期准备1、 首先创建一个新项目，然后更改 targetSdkVersion 为 22（因为涉及到文件上传） 2、 添加使用的依赖：（建议全部添加） 123456789//添加 Retrofitimplementation 'com.squareup.retrofit2:retrofit:2.1.0'//转换请求结果为 String 的implementation 'com.squareup.retrofit2:converter-scalars:2.1.0'//转换请求结果为 JSON 的implementation 'com.squareup.retrofit2:converter-gson:2.1.0'//获取七牛上传文件的 Token 的compile 'com.qiniu:qiniu-java-sdk:7.1.+' 3、新建 ApiStore 接口如下： 1234public interface ApiStores &#123;&#125; 4、 新建 Logger 工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438//建议直接复制public class Logger &#123; private static final boolean DEBUG = true; private static final String TAG = \"smartlog\"; public static void v(String s) &#123; v(TAG, s); &#125; public static void v(String tag, String s) &#123; if (DEBUG) Log.v(tag, s); &#125; public static void d(String s) &#123; d(TAG, s); &#125; public static void d(String tag, String s) &#123; if (DEBUG) Log.d(tag, s); &#125; public static void i(String s) &#123; i(TAG, s); &#125; public static void i(String tag, String s) &#123; if (DEBUG) Log.i(tag, s); &#125; public static void w(String s) &#123; w(TAG, s); &#125; public static void w(String tag, String s) &#123; if (DEBUG) Log.w(tag, s); &#125; public static void e(String s) &#123; e(TAG, s); &#125; public static void e(String tag, String s) &#123; if (DEBUG) Log.e(tag, s); &#125;&#125;``` ok，接下来就是实例。## 二、实例### 2.1 使用最普通的 GET 请求我们使用的 api 请求地址：[豆瓣电影Top250](https://developers.douban.com/wiki/?title=movie_v2#top250)[直接点击这里](https://api.douban.com/v2/movie/top250)可以看到我们即将请求得到的数据,然后我们新建返回的数据 Model ：MovieModel``` java//这个Model有点长，建议直接复制public class MovieModel &#123; private int count; private int start; private int total; private String title; private List&lt;SubjectsBean&gt; subjects; public int getCount() &#123; return count; &#125; public void setCount(int count) &#123; this.count = count; &#125; public int getStart() &#123; return start; &#125; public void setStart(int start) &#123; this.start = start; &#125; public int getTotal() &#123; return total; &#125; public void setTotal(int total) &#123; this.total = total; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public List&lt;SubjectsBean&gt; getSubjects() &#123; return subjects; &#125; public void setSubjects(List&lt;SubjectsBean&gt; subjects) &#123; this.subjects = subjects; &#125; public static class SubjectsBean &#123; private RatingBean rating; private String title; private int collect_count; private String original_title; private String subtype; private String year; private ImagesBean images; private String alt; private String id; private List&lt;String&gt; genres; private List&lt;CastsBean&gt; casts; private List&lt;DirectorsBean&gt; directors; public RatingBean getRating() &#123; return rating; &#125; public void setRating(RatingBean rating) &#123; this.rating = rating; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public int getCollect_count() &#123; return collect_count; &#125; public void setCollect_count(int collect_count) &#123; this.collect_count = collect_count; &#125; public String getOriginal_title() &#123; return original_title; &#125; public void setOriginal_title(String original_title) &#123; this.original_title = original_title; &#125; public String getSubtype() &#123; return subtype; &#125; public void setSubtype(String subtype) &#123; this.subtype = subtype; &#125; public String getYear() &#123; return year; &#125; public void setYear(String year) &#123; this.year = year; &#125; public ImagesBean getImages() &#123; return images; &#125; public void setImages(ImagesBean images) &#123; this.images = images; &#125; public String getAlt() &#123; return alt; &#125; public void setAlt(String alt) &#123; this.alt = alt; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public List&lt;String&gt; getGenres() &#123; return genres; &#125; public void setGenres(List&lt;String&gt; genres) &#123; this.genres = genres; &#125; public List&lt;CastsBean&gt; getCasts() &#123; return casts; &#125; public void setCasts(List&lt;CastsBean&gt; casts) &#123; this.casts = casts; &#125; public List&lt;DirectorsBean&gt; getDirectors() &#123; return directors; &#125; public void setDirectors(List&lt;DirectorsBean&gt; directors) &#123; this.directors = directors; &#125; public static class RatingBean &#123; private int max; private double average; private String stars; private int min; public int getMax() &#123; return max; &#125; public void setMax(int max) &#123; this.max = max; &#125; public double getAverage() &#123; return average; &#125; public void setAverage(double average) &#123; this.average = average; &#125; public String getStars() &#123; return stars; &#125; public void setStars(String stars) &#123; this.stars = stars; &#125; public int getMin() &#123; return min; &#125; public void setMin(int min) &#123; this.min = min; &#125; &#125; public static class ImagesBean &#123; private String small; private String large; private String medium; public String getSmall() &#123; return small; &#125; public void setSmall(String small) &#123; this.small = small; &#125; public String getLarge() &#123; return large; &#125; public void setLarge(String large) &#123; this.large = large; &#125; public String getMedium() &#123; return medium; &#125; public void setMedium(String medium) &#123; this.medium = medium; &#125; &#125; public static class CastsBean &#123; private String alt; private AvatarsBean avatars; private String name; private String id; public String getAlt() &#123; return alt; &#125; public void setAlt(String alt) &#123; this.alt = alt; &#125; public AvatarsBean getAvatars() &#123; return avatars; &#125; public void setAvatars(AvatarsBean avatars) &#123; this.avatars = avatars; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public static class AvatarsBean &#123; private String small; private String large; private String medium; public String getSmall() &#123; return small; &#125; public void setSmall(String small) &#123; this.small = small; &#125; public String getLarge() &#123; return large; &#125; public void setLarge(String large) &#123; this.large = large; &#125; public String getMedium() &#123; return medium; &#125; public void setMedium(String medium) &#123; this.medium = medium; &#125; &#125; &#125; public static class DirectorsBean &#123; private String alt; private AvatarsBeanX avatars; private String name; private String id; public String getAlt() &#123; return alt; &#125; public void setAlt(String alt) &#123; this.alt = alt; &#125; public AvatarsBeanX getAvatars() &#123; return avatars; &#125; public void setAvatars(AvatarsBeanX avatars) &#123; this.avatars = avatars; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public static class AvatarsBeanX &#123; private String small; private String large; private String medium; public String getSmall() &#123; return small; &#125; public void setSmall(String small) &#123; this.small = small; &#125; public String getLarge() &#123; return large; &#125; public void setLarge(String large) &#123; this.large = large; &#125; public String getMedium() &#123; return medium; &#125; public void setMedium(String medium) &#123; this.medium = medium; &#125; &#125; &#125; &#125;&#125; 在 ApiStore 中添加： 1234//使用最普通的方式进行GET请求@GET(\"v2/movie/top250\")Call&lt;MovieModel&gt; getMovieMsg(); 此时可以在 Activity 中的请求代码为： 1234567891011121314151617181920private void getMovieModelGet() &#123; Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.douban.com/\") .addConverterFactory(GsonConverterFactory.create()) .build(); ApiStores apiStores = retrofit.create(ApiStores.class); Call&lt;MovieModel&gt; call = apiStores.getMovieMsg(); call.enqueue(new Callback&lt;MovieModel&gt;() &#123; @Override public void onResponse(Call&lt;MovieModel&gt; call, Response&lt;MovieModel&gt; response) &#123; Logger.d(response.body().getTitle()); &#125; @Override public void onFailure(Call&lt;MovieModel&gt; call, Throwable t) &#123; Logger.d(t.getMessage()); &#125; &#125;);&#125; 结果: 1D/smartlog: 豆瓣电影Top250 接下来分析下: 首先看下 ApiStore 中的方法： 1、整个请求url分为两部分 BaseUrl： https://api.douban.com/ path：v2/movie/top250 所以整个的 url 是 https://api.douban.com/v2/movie/top250 2、@GET 是表示的此次网络请求是通过 get 请求发出的。3、“v2/movie/top250” 是表示此次请求的 path ，和 base4、Call 是表示此次的返回结果是 MovieModel ，如果是 Call 则表示是返回的结果是 String 字符串。这个地方和新建 Retrofit 的时候设置的 ConverterFactory 有关的， 如果是 .addConverterFactory(GsonConverterFactory.create()) ，则必须是 Call 如果是 .addConverterFactory(ScalarsConverterFactory.create())，则必须是 Call 再来看下在 Activity 中的请求代码： 首先我们创建了 Retrofit 的实例 retrofit。 通过创建的 retrofit的 create() 方法，传入我们前面写的 ApiStores.class，得到 apiStore实例。 然后通过 apiStore 的 getMovieMsg()方法得到 call 然后再执行 call 的 enqueue() 方法执行异步请求。 分析到此结束。 2.2 使用 @Path 的 GET 请求首先在 ApiStore 中添加： 123//使用Path进行GET请求@GET(\"v2/&#123;path&#125;/top250\")Call&lt;MovieModel&gt; getMoviePathMsg(@Path(\"path\") String path); 在 Activity 中的代码: 123456789101112131415161718private void getMoviePathGet() &#123; Retrofit retrofit = new Retrofit.Builder().baseUrl(\"https://api.douban.com/\") .addConverterFactory(GsonConverterFactory.create()) .build(); ApiStores apiStores = retrofit.create(ApiStores.class); Call&lt;MovieModel&gt; call = apiStores.getMoviePathMsg(\"movie\"); call.enqueue(new Callback&lt;MovieModel&gt;() &#123; @Override public void onResponse(Call&lt;MovieModel&gt; call, Response&lt;MovieModel&gt; response) &#123; Logger.d(\"通过path获取\"+response.body().getTitle()); &#125; @Override public void onFailure(Call&lt;MovieModel&gt; call, Throwable t) &#123; Logger.d(t.getMessage()); &#125; &#125;);&#125; 运行结果: 1D/smartlog: 通过path获取豆瓣电影Top250 继续来分析： {path} 对应的是 @Path 标记里面的 “path”，不一定叫 path ，也可以是其他的，也可以是 {a}和”a”。方法里面的 String 类型的 path 就是要把 {path} 替换掉，组成新的 path。 结合 Activity 中的 apiStores.getMoviePathMsg(&quot;movie&quot;);，那么最终的请求链接如下： BaseUrl： https://api.douban.com/ path：v2/movie/top250最终 url 为： https://api.douban.com/v2/movie/top250 所以这种和2.1中的的最终请求 url 是一样的。所以最终结果也是一样的。 1Call&lt;MovieModel&gt; call = apiStores.getMoviePathMsg(&quot;movie&quot;); 这段代码中的 “movie” 最终是把{path}替换掉，拼接成 v2/movie/top250。 3、使用 @Query 的 GET 请求4、使用 @QueryMap 的 GET 请求5、使用 @Body 类型为 String 的 POST 请求6、使用 @Body 类型为 JavaBean 的 POST 请求7、使用 @Body 类型为 RequestBody 的 POST 请求8、使用 @Filed 的 POST 请求9、使用 @Part 的 POST 请求上传文件10、使用 @PartMap 的 POST 请求上传文件","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android 上传 Library 到 JCenter","slug":"Android-上传-Library-到-JCenter","date":"2017-12-21T03:25:41.000Z","updated":"2018-02-02T06:15:00.969Z","comments":true,"path":"2017/12/21/Android-上传-Library-到-JCenter/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/12/21/Android-上传-Library-到-JCenter/","excerpt":"","text":"现在不喜欢废话了，直接干货吧 1、注册注册地址： 认清地址：https://bintray.com/signup/oss 认清地址：https://bintray.com/signup/oss 认清地址：https://bintray.com/signup/oss 2、新建仓库注册成功登陆之后，点击主页面的 Add New Repository 选择 Public - anyone can download your files.（当然，private 是收费的） Name填 maven Type 选择 Maven Default Licenses (Optional) 一般选择 Apache-2.0 Description (Optional) 随便填 Create 3、新建包新建完 maven 仓库以后，点进去 maven 仓库，选择 Add New Package Name 必填 小写 一般和第四步的 publish 标签内的 artifactId 一致 Description 选填 Licenses * 是 Apache-2.0 Tags 可填可不填，建议 Android Maturity 默认 none Website 建议 github 仓库地址 Issues tracker github仓库的 issues 地址 Version control * github 仓库的git地址（就是Git clone 后面跟的地址，以.git结尾） Create Package 4、新建要上传的 Android Library并配置 1、新建Android 项目 2、新建 Module 选择 AndroidLibrary 3、在项目的根目录的 build.gradle 中 12345678910buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.0.0&apos; classpath &apos;com.novoda:bintray-release:0.5.0&apos;//新增这行 &#125;&#125; 注意：bintray-releas的版本 依赖，对应你项目使用 Gradle 版本 bintray-releas version 0.5.0 对应 Gradle 是 version 3.4+ (包括3.4) bintray-releas version 0.4.0 对应 Gradle 是 version 3.3+ (包括3.3) bintray-releas version 0.3.4 对应 Gradle 是 version 1.3.0+(包括1.3) 在要上传的 Library 的 build.gradle 中12345678910111213141516171819apply plugin: &apos;com.android.library&apos;apply plugin: &apos;com.novoda.bintray-release&apos;//新增//新增android &#123; lintOptions &#123; abortOnError false &#125;&#125;//新增publish &#123; userOrg = &apos;derekcao&apos; //bintray注册的用户名 groupId = &apos;cn.smartsean&apos; //compile引用时的第1部分 groupId artifactId = &apos;lib&apos; //compile引用时的第2部分项目名(一般和上面新建包那一步的 Name 一样) publishVersion = &apos;0.0.1&apos; //compile引用时的第3部分版本号 desc = &apos;This is a utils lib&apos;//d项目描述 repoName=&quot;maven&quot; //你的仓库名称，没有填写默认仓库是maven//这也是很多人上传仓库不对名问题最多情况， website = &apos;https://github.com/smartsean/AndroidCode&apos; //github 托管地址&#125; 5、执行上传命令首先获取你的 ApiKey ，在 EditProfile 中左侧的 API KEY选项找。 Mac： 1./gradlew clean build bintrayUpload -PbintrayUser=&quot;derekcap&quot; -PbintrayKey=&quot;你的ApiKey&quot; -PdryRun=false 然后进入第三部新建的包中，点击 Add To JCenter ，填写你的简介，很简单的英文介绍即可，然后耐心等待就好了。至于等待多久，看运气了，我的半个小时就好了。 6、使用然后再使用：1234compile &apos;groupId:artifactId:publishVersion&apos;//我的是compile &apos;cn.smartsean:lib:0.0.1&apos; groupId 第四步的 publish 中的 groupId artifactId 第四步的 publish 中的 artifactId publishVersion 第四步的 publish 中的 publishVersion 至此就可以愉快的使用了。 如果你遇到，有问题的请联系我，很乐意帮你解决： 邮箱：smartsean.vip@gmail.com","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"},{"name":"工具","slug":"工具","permalink":"https://github.com/smartsean/smartsean.github.io/tags/工具/"},{"name":"我","slug":"我","permalink":"https://github.com/smartsean/smartsean.github.io/tags/我/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android基础 Android EditText禁止输入空格","slug":"Android基础-Android-EditText禁止输入空格","date":"2017-12-20T03:27:30.000Z","updated":"2018-01-16T03:28:24.190Z","comments":true,"path":"2017/12/20/Android基础-Android-EditText禁止输入空格/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/12/20/Android基础-Android-EditText禁止输入空格/","excerpt":"","text":"1、定义公共InputFilter1234567891011121314/*** 禁止输入空格** @return*/public class SpaceFilter implements InputFilter &#123; @Override public SpaceFilter filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) &#123; //返回null表示接收输入的字符,返回空字符串表示不接受输入的字符 if (source.equals(&quot; &quot;)) return &quot;&quot;; return null; &#125;&#125; 2、EditText使用该InputFilter12testEt = (EditText)findViewById(R.id.test_et);testEt.setFilters(new InputFilter[]&#123;new SpaceFilter()&#125;); 特此记录,其他类似功能，可以自行扩展实现。","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android打开指定文件实践 --- 工具类","slug":"Android打开指定文件实践-工具类","date":"2017-12-12T08:57:03.000Z","updated":"2018-02-02T06:15:00.967Z","comments":true,"path":"2017/12/12/Android打开指定文件实践-工具类/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/12/12/Android打开指定文件实践-工具类/","excerpt":"","text":"项目中有下载文件的功能，但是有点 low，就是单纯的下载，下载成功提示用户文件下载在哪，需要用户手动去文件管理器找这些文件，不是很人性化，于是决定新增下载文件以后让用户直接能打开文件，友好型会好很多 前言首先在实现打开指定文件之前，我尝试过打开指定的文件夹，但是并没有成功，研究了大半天的时间，发现是不可行的，这是个坑，希望不要有人再踩这个坑了，（当然，也有可能是我没找到打开文件夹的方法，如果有人知道，希望能够赐教下，先谢谢了） 文末会给出封装好的代码，OpenFileUtils 和 FileProviderUtils 类，可以直接使用。 判断文件类型我们在打开文件之前，首先得知道文件的类型，才能指定 Intent 的 Data ，才能实现打开文件的功能。 常见的文件类型以及对应的 DataType 如下： 123456789101112131415161718/** * 声明各种类型文件的dataType **/private static final String DATA_TYPE_APK = &quot;application/vnd.android.package-archive&quot;;private static final String DATA_TYPE_VIDEO = &quot;video/*&quot;;private static final String DATA_TYPE_AUDIO = &quot;audio/*&quot;;private static final String DATA_TYPE_HTML = &quot;text/html&quot;;private static final String DATA_TYPE_IMAGE = &quot;image/*&quot;;private static final String DATA_TYPE_PPT = &quot;application/vnd.ms-powerpoint&quot;;private static final String DATA_TYPE_EXCEL = &quot;application/vnd.ms-excel&quot;;private static final String DATA_TYPE_WORD = &quot;application/msword&quot;;private static final String DATA_TYPE_CHM = &quot;application/x-chm&quot;;private static final String DATA_TYPE_TXT = &quot;text/plain&quot;;private static final String DATA_TYPE_PDF = &quot;application/pdf&quot;;/** * 未指定明确的文件类型，不能使用精确类型的工具打开，需要用户选择 */private static final String DATA_TYPE_ALL = &quot;*/*&quot;; 然后我们得根据要打开的文件名，获取文件的类型： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 取得文件扩展名String end = file.getName().substring(file.getName().lastIndexOf(&quot;.&quot;) + 1, file.getName().length()).toLowerCase();// 依扩展名的类型决定MimeTypeswitch (end) &#123; case &quot;3gp&quot;: case &quot;mp4&quot;: openVideoFileIntent(mContext, file); break; case &quot;m4a&quot;: case &quot;mp3&quot;: case &quot;mid&quot;: case &quot;xmf&quot;: case &quot;ogg&quot;: case &quot;wav&quot;: openAudioFileIntent(mContext, file); break; case &quot;doc&quot;: case &quot;docx&quot;: commonOpenFileWithType(mContext, file, DATA_TYPE_WORD); break; case &quot;xls&quot;: case &quot;xlsx&quot;: commonOpenFileWithType(mContext, file, DATA_TYPE_EXCEL); break; case &quot;jpg&quot;: case &quot;gif&quot;: case &quot;png&quot;: case &quot;jpeg&quot;: case &quot;bmp&quot;: commonOpenFileWithType(mContext, file, DATA_TYPE_IMAGE); break; case &quot;txt&quot;: commonOpenFileWithType(mContext, file, DATA_TYPE_TXT); break; case &quot;htm&quot;: case &quot;html&quot;: commonOpenFileWithType(mContext, file, DATA_TYPE_HTML); break; case &quot;apk&quot;: commonOpenFileWithType(mContext, file, DATA_TYPE_APK); break; case &quot;ppt&quot;: commonOpenFileWithType(mContext, file, DATA_TYPE_PPT); break; case &quot;pdf&quot;: commonOpenFileWithType(mContext, file, DATA_TYPE_PDF); break; case &quot;chm&quot;: commonOpenFileWithType(mContext, file, DATA_TYPE_CHM); break; default: commonOpenFileWithType(mContext, file, DATA_TYPE_ALL); break;&#125; 根据文件名拿到 DataType 之后，我们就可以把 DataType 传入 Intent 来打开文件了。下面以打开 Video 为例： 1234567891011121314/** * Android打开Video文件 * @param mContext * @param file */public static void openVideoFileIntent(Context mContext, File file) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); intent.putExtra(&quot;oneshot&quot;, 0); intent.putExtra(&quot;configchange&quot;, 0); FileProviderUtils.setIntentDataAndType(mContext, intent, DATA_TYPE_VIDEO, file, false); mContext.startActivity(intent);&#125; 只要传入 Context 和 File 就可以使用了。 相关代码上面的代码是不完整的，下面我贴出有关的类的代码： 首先是：OpenFileUtils 类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * @author SmartSean * @date 17/12/11 16:04 */public class OpenFileUtils &#123; /** * 声明各种类型文件的dataType **/ private static final String DATA_TYPE_APK = &quot;application/vnd.android.package-archive&quot;; private static final String DATA_TYPE_VIDEO = &quot;video/*&quot;; private static final String DATA_TYPE_AUDIO = &quot;audio/*&quot;; private static final String DATA_TYPE_HTML = &quot;text/html&quot;; private static final String DATA_TYPE_IMAGE = &quot;image/*&quot;; private static final String DATA_TYPE_PPT = &quot;application/vnd.ms-powerpoint&quot;; private static final String DATA_TYPE_EXCEL = &quot;application/vnd.ms-excel&quot;; private static final String DATA_TYPE_WORD = &quot;application/msword&quot;; private static final String DATA_TYPE_CHM = &quot;application/x-chm&quot;; private static final String DATA_TYPE_TXT = &quot;text/plain&quot;; private static final String DATA_TYPE_PDF = &quot;application/pdf&quot;; /** * 未指定明确的文件类型，不能使用精确类型的工具打开，需要用户选择 */ private static final String DATA_TYPE_ALL = &quot;*/*&quot;; /** * 打开文件 * @param mContext * @param file */ public static void openFile(Context mContext, File file) &#123; if (!file.exists()) &#123; return; &#125; // 取得文件扩展名 String end = file.getName().substring(file.getName().lastIndexOf(&quot;.&quot;) + 1, file.getName().length()).toLowerCase(); // 依扩展名的类型决定MimeType switch (end) &#123; case &quot;3gp&quot;: case &quot;mp4&quot;: openVideoFileIntent(mContext, file); break; case &quot;m4a&quot;: case &quot;mp3&quot;: case &quot;mid&quot;: case &quot;xmf&quot;: case &quot;ogg&quot;: case &quot;wav&quot;: openAudioFileIntent(mContext, file); break; case &quot;doc&quot;: case &quot;docx&quot;: commonOpenFileWithType(mContext, file, DATA_TYPE_WORD); break; case &quot;xls&quot;: case &quot;xlsx&quot;: commonOpenFileWithType(mContext, file, DATA_TYPE_EXCEL); break; case &quot;jpg&quot;: case &quot;gif&quot;: case &quot;png&quot;: case &quot;jpeg&quot;: case &quot;bmp&quot;: commonOpenFileWithType(mContext, file, DATA_TYPE_IMAGE); break; case &quot;txt&quot;: commonOpenFileWithType(mContext, file, DATA_TYPE_TXT); break; case &quot;htm&quot;: case &quot;html&quot;: commonOpenFileWithType(mContext, file, DATA_TYPE_HTML); break; case &quot;apk&quot;: commonOpenFileWithType(mContext, file, DATA_TYPE_APK); break; case &quot;ppt&quot;: commonOpenFileWithType(mContext, file, DATA_TYPE_PPT); break; case &quot;pdf&quot;: commonOpenFileWithType(mContext, file, DATA_TYPE_PDF); break; case &quot;chm&quot;: commonOpenFileWithType(mContext, file, DATA_TYPE_CHM); break; default: commonOpenFileWithType(mContext, file, DATA_TYPE_ALL); break; &#125; &#125; /** * Android传入type打开文件 * @param mContext * @param file * @param type */ public static void commonOpenFileWithType(Context mContext, File file, String type) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.addCategory(Intent.CATEGORY_DEFAULT); FileProviderUtils.setIntentDataAndType(mContext, intent, type, file, true); mContext.startActivity(intent); &#125; /** * Android打开Video文件 * @param mContext * @param file */ public static void openVideoFileIntent(Context mContext, File file) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); intent.putExtra(&quot;oneshot&quot;, 0); intent.putExtra(&quot;configchange&quot;, 0); FileProviderUtils.setIntentDataAndType(mContext, intent, DATA_TYPE_VIDEO, file, false); mContext.startActivity(intent); &#125; /** * Android打开Audio文件 * @param mContext * @param file */ private static void openAudioFileIntent(Context mContext, File file) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); intent.putExtra(&quot;oneshot&quot;, 0); intent.putExtra(&quot;configchange&quot;, 0); FileProviderUtils.setIntentDataAndType(mContext, intent, DATA_TYPE_AUDIO, file, false); mContext.startActivity(intent); &#125;&#125; 接下来是洪洋大神写的 Android 7.0 适配类 FileProviderUtils（使用前先需要先了解下 FileProvider 的使用） 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author SmartSean * @date 17/12/11 14:23 */public class FileProviderUtils &#123; public static Uri getUriForFile(Context mContext, File file) &#123; Uri fileUri = null; if (Build.VERSION.SDK_INT &gt;= 24) &#123; fileUri = getUriForFile24(mContext, file); &#125; else &#123; fileUri = Uri.fromFile(file); &#125; return fileUri; &#125; public static Uri getUriForFile24(Context mContext, File file) &#123; Uri fileUri = android.support.v4.content.FileProvider.getUriForFile(mContext, BuildConfig.APPLICATION_ID + &quot;.provider&quot;, file); return fileUri; &#125; public static void setIntentDataAndType(Context mContext, Intent intent, String type, File file, boolean writeAble) &#123; if (Build.VERSION.SDK_INT &gt;= 24) &#123; intent.setDataAndType(getUriForFile(mContext, file), type); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); if (writeAble) &#123; intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION); &#125; &#125; else &#123; intent.setDataAndType(Uri.fromFile(file), type); &#125; &#125;&#125; 调用1234567File file = new File(Environment.getExternalStorageDirectory()+&quot;/AA/q.xlsx&quot;);try &#123; OpenFileUtils.openFile(mContext, file);&#125; catch (Exception e) &#123; ToastUtil.toastError(mContext, &quot;无可用打开方式&quot;); e.printStackTrace();&#125; 这样就可以实现打开文件功能了。 最后最后，唠叨下，好久没写博客，感觉都不知道怎么写了，慢慢找感觉吧。。。","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"},{"name":"工具","slug":"工具","permalink":"https://github.com/smartsean/smartsean.github.io/tags/工具/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android Studio 使用","slug":"Android Studio 使用","date":"2017-09-11T16:00:00.000Z","updated":"2018-01-16T01:48:03.553Z","comments":true,"path":"2017/09/12/Android Studio 使用/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/09/12/Android Studio 使用/","excerpt":"","text":"Android Studio 使用：参考地址 1、移除无用的导入包control+option+o 1Optimize Imports 2、查看一个类的继承关系control+h 1Type Hierarchy 3、快速预览方法command+y 1Quick Definition 4、快速查看选中方法的参数command+p 1Parameter Info 5、最近操作、修改的文件Commond+E1Recent Files 6、查找文件option+f1Mainmenu--》Navigate--》files 7、快速预览当前类的变量、方法和内部类Commond+F121Mainmenu--》Navigate--》Files Structure 8、切换已打开的标签Back ： Commond+[ 或 Comond+option+leftForward： Commond+] 或 Comond+option+right1Mainmenu--》Navigate--》Back 或 Forward 9、查看变量或者方法在什么地方使用option+F71Find Usages 10、快速查看方法文档 显示参数、说明等F11Quick Documentation 11、快速补全完成command + shift + enter方法体大括号的添加、行尾分号的添加、自动格式化改行操作等1Complete Current Statement 12、粘贴板管理command + shift + v 13、书签添加书签：F3调出面板：Commond+F3 14、代码重构比如改名等重构入口：control+t 15、surround With包裹代码command + option + T 16、Extract 提取代码option+commond+m 17、调出代码模板Commond+J 18、大小写不敏感 Editor –&gt; General –&gt; Code Completion 设置为None 19、自动导包 Settings –&gt; Editor –&gt; Auto Import All:有需要导入的包名时，会自动导入，不会弹提示框 ASK:有需要导入的包名时，会弹提示框，问你要不要导入 None:有需要导入的包名时，不会弹提示框，也不会自动导入。 Optimize imports on fly 这个其实和快捷键Ctrl+Shift+O/Ctrl+Alt+O是一样的，就是把不用的声明移除掉。 Add unambiguous imports on the fly 这个就是自动导入功能了，当你输入类名后，声明就被自动导入了。 Exclude from Import and Completion 这个其实就是你自定义import。可以不用关注，一般来说你是用不上的。","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"},{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"https://github.com/smartsean/smartsean.github.io/tags/AndroidStudio/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android Studio清除垃圾资源","slug":"Android-Studio清除垃圾资源","date":"2017-08-31T09:18:56.000Z","updated":"2018-02-02T06:15:00.970Z","comments":true,"path":"2017/08/31/Android-Studio清除垃圾资源/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/08/31/Android-Studio清除垃圾资源/","excerpt":"","text":"日常开发中，我们可能新建了很多资源文件，然后之后就忘记删除，会造成一些垃圾资源存在项目中，最近发现可以使用 Android Studio 自带的 Analyze 来找到这些资源，然后删除： 点开菜单栏 Analyze 下面的 Run Inspection by Name… 出现这个输入框： 然后输入 Unused Resuroces ，稍等片刻便可以把项目中的无用资源列出来，然后按需删除就行了。 除了这个里面还有很多查找的东西，有兴趣的可以去研究下。","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"},{"name":"工具","slug":"工具","permalink":"https://github.com/smartsean/smartsean.github.io/tags/工具/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"记一次页面有EditText时，键盘弹出的问题","slug":"记一次页面有EditText时，键盘弹出的问题","date":"2017-08-26T14:43:54.000Z","updated":"2018-01-16T03:18:21.656Z","comments":true,"path":"2017/08/26/记一次页面有EditText时，键盘弹出的问题/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/08/26/记一次页面有EditText时，键盘弹出的问题/","excerpt":"","text":"记一次页面有EditText时，键盘弹出的问题先来看一下在 Manifest 文件里面的 Activity 里面的这个属性 1android:windowSoftInputMode=&quot;adjustPan|stateHidden&quot; 以下介绍部分属于来自官方文档 这个属性是 Android 1.5之后推出的，主要是为了 Activity 与软键盘的交互，主要的作用有两个： 当 Activity 成为用户注意的焦点时软键盘的状态 — 隐藏还是可见。 对 Activity 主窗口所做的调整 — 是否将其尺寸调小以为软键盘腾出空间，或者当窗口部分被软键盘遮挡时是否平移其内容以使当前焦点可见。 该设置必须是下表所列的值之一，或者是一个“state…”值加上一个“adjust…”值的组合。 在任一组中设置多个值（例如，多个“state…”值）都会产生未定义结果。各值之间使用垂直条 (|) 分隔。 这里的意思就是，正常会有下面的几种组合形式 adjust… adjust…+state… state… 而不能写成 adjust… state… 比如 1&lt;activity android:windowSoftInputMode=&quot;stateVisible|adjustResize&quot; . . . &gt; 属性介绍： stateUnspecified：不指定软键盘的状态（隐藏还是可见）。 将由系统选择合适的状态，或依赖主题中的设置。这是对软键盘行为的默认设置。 stateUnchanged：当这个 activity 出现时，软键盘将一直保持在上一个 activity 里的状态，无论是隐藏还是显示 stateHidden：用户选择打开新 activity 时，软键盘总是被隐藏,如果是从另外一个 Activity 返回时，采用默认值(官网描述：当用户选择 Activity 时 — 也就是说，当用户确实是向前导航到 Activity，而不是因离开另一 Activity 而返回时 — 隐藏软键盘。) stateAlwaysHidden：当该 Activity 主窗口获取焦点时，软键盘也总是被隐藏的 stateVisible：在正常的适宜情况下（当用户向前导航到 Activity 的主窗口时）显示软键盘。 stateAlwaysVisible：当用户选择 Activity 时 — 也就是说，当用户确实是向前导航到 Activity，而不是因离开另一 Activity 而返回时 — 显示软键盘。 adjustUnspecified：默认设置，通常由系统自行决定是隐藏还是显示（官网描述：不指定 Activity 的主窗口是否调整尺寸以为软键盘腾出空间，或者窗口内容是否进行平移以在屏幕上显露当前焦点。 系统会根据窗口的内容是否存在任何可滚动其内容的布局视图来自动选择其中一种模式。 如果存在这样的视图，窗口将进行尺寸调整，前提是可通过滚动在较小区域内看到窗口的所有内容。这是对主窗口行为的默认设置。） adjustResize：该 Activity 总是调整屏幕的大小以便留出软键盘的空间 adjustPan：当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分（官网描述：不调整 Activity 主窗口的尺寸来为软键盘腾出空间， 而是自动平移窗口的内容，使当前焦点永远不被键盘遮盖，让用户始终都能看到其输入的内容。 这通常不如尺寸调正可取，因为用户可能需要关闭软键盘以到达被遮盖的窗口部分或与这些部分进行交互。） 我遇到的问题我在首页点击按钮进入下个页面，进去之后自动弹出软键盘，返回页主页面有两种方式 方式一按返回键，先收起软键盘，再按一次，返回主页面，这种情况是没有问题的 方式二直接点击导航栏的返回按钮，返回主页面，这种情况确实返回了主页面，但是软键盘却没有自动收起。我主页面的 Activity 是设置的 1android:windowSoftInputMode=&quot;adjustPan|stateHidden&quot; 设置成这两个属性是因为主页面有个输入框，如果不设置的话，输入框弹起的时候，会把底部的 tab 栏顶上来。 从上面的属性说明来看，adjustPan 是正常的，可以很好的解决我键盘弹出时，把底部 tab 栏顶上来的 bug， 那么问题主要就出在 stateHiden 这里，由于我这个是主页面，首次进来的时候软键盘是被隐藏的，如果我从主页面进入 ActivityA ，在ActivityA 里面有输入框，我直接点击左上角的返回按钮回到主页面，软键盘并不会被隐藏，还是出现在页面中， 最终解决办法：由于这个是主页面，我们想要每次进来的时候，软键盘都是被隐藏的，只需要把 stateHidden 换成 stateAlwaysHidden 或者直接删掉就好了。 最后，如果需要 梯子的朋友，可以看看这里Vpn强势推荐","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"记一次ionic使用file插件cordova-plugin-file的坑","slug":"记一次ionic使用file插件cordova-plugin-file的坑","date":"2017-07-25T10:10:00.000Z","updated":"2018-02-02T06:15:00.966Z","comments":true,"path":"2017/07/25/记一次ionic使用file插件cordova-plugin-file的坑/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/07/25/记一次ionic使用file插件cordova-plugin-file的坑/","excerpt":"","text":"今天要做一个附件下载的功能，首先我得先在本地建立一个文件夹，用来存放下载的附件，那么我得先判断这个文件夹存在不存在，如果存在的话，就直接放在里面，如果不存在，就需要新建这个文件夹。 在 Android 原生里面判断很简单，但是由于没有使用过这个 cordova-plugin-file 插件,还是有点坑的。 首先，我找到了官网的介绍： 看到没，就是这么的高贵冷艳，对于一个一直写原生的我来说，真的是： 好吧，那就现在代码里面找到这个玩意： 现在来分析下： 首先，会用正则判断我们传入的 dir ，接下来会拼接路径和目录，生成一个 directory ， 然厚再去调用 $window.resolveLocalFileSystemURL 这个方法去判断 directory ，如果返回的成功，那么就会 resolve ，失败会返回我们 err 的 code 和 message ； code 和 message 也给我们定义了 现在很开心，那么继续往下写。 看起来好像没什么问题，cordova.file.externalRootDirectory 是获取手机的根目录，&#39;i5sesol&#39;是我们文件夹的名字。但是你一运行就会得到一个 ENCODING_ERR 的错误，那么我们进行修改： 这次就可以成功运行了。所以以后写代码的时候，还是要多看源码，源码才是最好的文档。","categories":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Ionic/"}],"tags":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Ionic/"}],"keywords":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Ionic/"}]},{"title":"我项目中会用到的开源项目（都是精品）---持续更新","slug":"我项目中会用到的开源项目（都是精品）-持续更新","date":"2017-07-12T09:41:43.000Z","updated":"2018-02-02T06:15:00.965Z","comments":true,"path":"2017/07/12/我项目中会用到的开源项目（都是精品）-持续更新/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/07/12/我项目中会用到的开源项目（都是精品）-持续更新/","excerpt":"","text":"想要 vpn 的朋友可以去这里看看Vpn强势推荐 一、刷新框架1、SmartRefreshLayout2、android-Ultra-Pull-To-Refresh二、图片1、Glide2、PhotoView可缩放的ImageView 3、CircleImageView圆角图片 4、uCrop图片裁剪 5、KenBurnsView视差图片控件 6、PinchImageView体验非常好的Android图片手势控件。 7、PictureSelector 8、ImagePicker 三、实例化 View1、butterknife四、数据解析1、fastjson五、消息传递1、EventBus2、 AndroidEventBus (暂时没用过，以后可以考虑)六、沉浸式1、ImmersionBarandroid 4.4以上沉浸式状态栏和沉浸式导航栏管理，一句代码轻松实现，以及对bar的其他设置. 七、banner1、banner支持的类型如下： 2、Android-ConvenientBanner3、BGABanner-Android 八、Loading1、AVLoadingIndicatorView里面有各种View，效果图如下： 2、NumberProgressBar进度条，可以用到下载页面，效果图如下： 3、mkloader效果图： 九、RecyclerView相关1、BaseRecyclerViewAdapterHelper号称可以少写70%的代码，很强大 十、二维码1、BGAQRCode-Android很简单的一个集成二维码的框架，目前在使用，扫描速度有待提升 2、barcodescanner3、zxing十一、本地数据库1、GreenDao十二、异常捕获1、acra十三、对话框1、FlycoDialog_Master2、material-dialogs3、 sweet-alert-dialog14、 角标1、BadgeView 15、Material Design1、搜索框—MaterialSearchBar 16、Android6.0权限处理1、RxPermissions和RxJava更配哦。 2、easypermissions谷歌推出的一个权限处理框架 17、下载1、RxDownload和RxJava更配哦。 2、FileDownloader18、内存泄漏检查1、leakcanarySquare出品 19、状态监控1、ReactiveNetwork监控网络状态，with RxJava Observables 20、动画效果1、SlidingLayout实现类似微信WebView的上拉下拉弹跳效果和iOS的ListView的果冻效果 21、引导页1、SlidingTutorial-Android 22、消息数量角标1、BadgeView 想要 vpn 的朋友可以去这里看看Vpn强势推荐","categories":[{"name":"我","slug":"我","permalink":"https://github.com/smartsean/smartsean.github.io/categories/我/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"},{"name":"工具","slug":"工具","permalink":"https://github.com/smartsean/smartsean.github.io/tags/工具/"}],"keywords":[{"name":"我","slug":"我","permalink":"https://github.com/smartsean/smartsean.github.io/categories/我/"}]},{"title":"WebView使用","slug":"WebView使用","date":"2017-07-03T13:47:41.000Z","updated":"2018-01-16T03:22:14.098Z","comments":true,"path":"2017/07/03/WebView使用/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/07/03/WebView使用/","excerpt":"","text":"由于前段时间的项目对WebView的使用较多，因此总结一下项目中WebView的使用使用过程，以及一些值得注意的地方 WebView 在大部分的WebApp中使用相当广泛，处理好WebView也是一个WebApp的关键 目前的WebView是基于webkit 内核浏览器并且封装在android 的sdk 当中，并且WebView包括以下几个功能 加载网站url和加载本地html页面 可以与JavaScript代码进行交互 webview控件可以高度进行定制 在WebView使用过程中应当注意一下几点： 在AndroidManifest.xml 中添加网络访问权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;在WebView中有一个辅助类WebSettings，通过他管理WebView的一些状态以及插件12// webview启用javascript支持 用于访问页面中的javascriptwebSettings.setJavaScriptEnabled(true); 12//设置WebView缓存模式 默认断网情况下不缓存webSettings.setCacheMode(WebSettings.LOAD_DEFAULT); 12//断网情况下加载本地缓存webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);&#125; 12//让WebView支持DOM storage APIwebSettings.setDomStorageEnabled(true); 12//让WebView支持缩放webSettings.setSupportZoom(true); 12//启用WebView内置缩放功能webSettings.setBuiltInZoomControls(true); 12//让WebView支持可任意比例缩放webSettings.setUseWideViewPort(true); 12//让WebView支持播放插件webSettings.setPluginState(WebSettings.PluginState.ON); 12//设置WebView使用内置缩放机制时，是否展现在屏幕缩放控件上webSettings.setDisplayZoomControls(false); 12//设置在WebView内部是否允许访问文件webSettings.setAllowFileAccess(true); 12//设置WebView的访问UserAgentwebSettings.setUserAgentString(WebViewUtil.getUserAgent(getActivity(), webSettings)); 12//设置脚本是否允许自动打开弹窗webSettings.setJavaScriptCanOpenWindowsAutomatically(true); 123456// 加快HTML网页加载完成速度 if (Build.VERSION.SDK_INT &gt;= 19) &#123; settings.setLoadsImagesAutomatically(true);&#125; else &#123; settings.setLoadsImagesAutomatically(false); &#125; 12// 开启Application H5 Caches 功能 settings.setAppCacheEnabled(true); 12// 设置编码格式settings.setDefaultTextEncodingName(&quot;utf-8&quot;); 3.当页面需要调用我们一些原生native的功能时候，可以通过我们自定义的JS接口去实现 12//设置WebView JavaScript接口可以供页面JS调用mWebView.addJavascriptInterface(new JsInterface(), AppUtil.KEY_JS_INTERFACE_NAME); 通过下面定义接口中的方法，如果涉及到一些ui界面上的处理和操作的话，需要在主线程中进行 123456789101112//接口类public class JsInterface &#123; public JsInterface() &#123; @JavascriptInterface public void showToast(String msg, int delayType) &#123; Message message = new Message(); message.what = SHOW_TOAST; message.arg1 = delayType; message.obj = msg;mHandler.sendMessage(message); &#125; &#125;&#125; 4.设定WebViewClient和WebChromeClient实现WebView更多功能 通过设置WebViewClient获取页面标题与页面中连接跳转的处理 123456789101112131415161718192021mWebView.setWebViewClient(new WebViewClient() &#123; @Override public void onPageFinished(WebView view, String url) &#123; //可以获取到WebView的标题Title setTitle(view.getTitle()); super.onPageFinished(view, url); &#125; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; //WebVeiw中连接跳转进行处理跳转到新的Activity if (WebIntentUtil.isDetailsPage(url)) &#123; Intent intent = new Intent(EmbeddedBrowserActivity.this, DetailsActivity.class); intent.putExtra(BbsServerUtil.KEY_URL, url); startActivity(intent); return true; &#125; else &#123; return super.shouldOverrideUrlLoading(view, url); &#125; &#125;&#125;);","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Java多线程","slug":"Java多线程","date":"2017-05-09T08:39:00.000Z","updated":"2018-01-16T03:15:27.751Z","comments":true,"path":"2017/05/09/Java多线程/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/05/09/Java多线程/","excerpt":"","text":"写在前面的话：这篇博客是我从这里“转载”的，为什么转载两个字加“”呢？因为这绝不是简单的复制粘贴，我花了五六个小时对其中每一行的代码都有认真的练习，对其中的一些小错误进行调整，并且重新排版，希望通过本篇博客可以让自己对 Java 多线程有更好的理解，同时也希望能够帮助正在学习多线程的你。 此文只能说是 Java 多线程的一个入门，其实Java里头线程完全可以写一本书了，但是如果最基本的你都没掌握好，又怎么能更上一个台阶呢？如果你觉得此文很简单，那推荐你看看Java并发包的的线程池（Java 并发编程与技术内幕:线程池深入理解），或者看这个专栏：Java 并发编程与技术内幕。你将会对 Java 里头的高并发场景下的线程有更加深刻的理解 本文主要讲了 Java 中多线程的使用方法、线程同步、线程数据传递、线程状态及相应的一些线程函数用法、概述等。在这之前，首先让我们来了解下在操作系统中进程和线程的区别： 进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（进程是资源分配的最小单位） 线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是 cpu 调度的最小单位） 线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。 多进程是指操作系统能同时运行多个任务（程序）。 多线程是指在同一程序中有多个顺序流在执行。 在 Java 中要想实现多线程，有两种手段： 一种是继承 Thread 类； 一种是实现 Runnable 接口. 其实准确来讲，应该有三种，还有一种是实现 Callable 接口，并与 Future、线程池结合使用，此文不讲这个，有兴趣看这里 Java 并发编程与技术内幕：Callable、Future、FutureTask、CompletionService 一、扩展java.lang.Thread类这里继承 Thread 类的方法是比较常用的一种，如果说你只是想重新开启一条线程。没有什么其它特殊的要求，那么可以使用 Thread ，（笔者推荐使用 Runnable ，后头会说明为什么）。下面来看一个简单的实例： 12345678910111213141516171819202122232425262728293031323334/** * Created by Sean on 2017/5/9. */class Thread1 extends Thread &#123; private String threadName; // 用于标示不同的线程 public Thread1(String threadName) &#123; this.threadName = threadName; &#125; @Override public void run() &#123; super.run(); for (int i = 0; i &lt; 5; i++) &#123; System.out.println(threadName + &quot;运行，此时的 i = &quot; + i); try &#123; sleep((int) Math.random() * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello World!&quot;); Thread1 thread1 = new Thread1(&quot;我是A线程&quot;); Thread1 thread2 = new Thread1(&quot;我是B线程&quot;); thread1.start(); thread2.start(); &#125;&#125; 运行结果： 说明： 程序启动运行 main 时候， java 虚拟机启动一个进程，主线程 main 在 main() 调用时候被创建。随着调用 Thread1 的两个对象的 start 方法，另外两个线程也启动了，这样，整个应用就在多线程下运行。 注意： start() 方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。 从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。 Thread.sleep() 方法调用目的是不让当前线程独自霸占该进程所获取的 CPU 资源，以留出一定时间给其他线程执行的机会。 实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。 此外 start() 方法重复调用的话，会出现java.lang.IllegalThreadStateException异常。 比如把 Main 类代码改成下面：12345678public class Main &#123; public static void main(String[] args) &#123; Thread1 thread1 = new Thread1(&quot;我是A线程&quot;); thread1.start(); thread1.start(); &#125;&#125; 结果如下： 二、实现 java.lang.Runnable 接口采用 Runnable 也是非常常见的一种，我们只需要重写 run() 即可。下面也来看个实例。 使用继承 Thread 实现共享的错误示范1234567891011121314151617181920212223242526272829303132/** * Created by Sean on 2017/5/9. */class Thread2 implements Runnable &#123; private String threadName; public Thread2(String threadName) &#123; this.threadName = threadName; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(threadName + &quot;运行，此时的 i = &quot; + i); try &#123; Thread.sleep((int) Math.random() * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Main2 &#123; public static void main(String[] args) &#123; new Thread(new Thread2(&quot;我是在A线程中&quot;)).start(); new Thread(new Thread2(&quot;我是在B线程中&quot;)).start(); &#125;&#125; 结果： 说明： Thread2 类是通过实现 Runnable 接口，使该类有了多线程类的特征， run() 方法是多线程程序的一个约定，所有的多线程代码都在 run() 方法里面， 事实上， Thread 类也是实现了 Runnable 接口的类。 在启动实现了 Runnable 接口的类的多线程的时候，需要先通过 Thread 类的构造方法 Thread(Runanable target) 构造出 Thread 对象，然后调用 Thread 对象的 start() 方法来开启线程，运行 run() 方法里面的多线程代码（这个run() 方法不需要开发者手动调用，会在操作系统分给该线程时间片的时候自动运行） 实际上所有的多线程代码都是通过运行 Thread 的 start() 方法来运行的。因此，不管是扩展 Thread 类还是实现 Runnable 接口来实现多线程，最终还是通过 Thread 的对象的 API 来控制线程的，熟悉 Thread 类的 API 是进行多线程编程的基础。 三、Thread和Runnable的区别 如果一个类继承 Thread，则不适合资源共享。但是如果实现了 Runable 接口的话，则很容易的实现资源共享。 上面这句话是原博客里面给出的，我认为是有瑕疵的。 以卖票程序为例，下面来说明为什么这样说： 使用继承 Thread 的方式共享的错误示例1234567891011121314151617181920212223242526272829303132333435363738/** * Created by Sean on 2017/5/9. */class Thread3 extends Thread &#123; private String threadName; private int ticket = 5; public Thread3(String threadName) &#123; this.threadName = threadName; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; synchronized (this) &#123; if (ticket &gt; 0)&#123; System.out.println(threadName + &quot;运行，此时的 i = &quot; + i+&quot; 剩余票数&quot; + this.ticket--); &#125; &#125; try &#123; sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Main3 &#123; public static void main(String[] args)&#123; Thread3 thread1 = new Thread3(&quot;我是在A线程中&quot;); Thread3 thread2 = new Thread3(&quot;我是在B线程中&quot;); Thread3 thread3 = new Thread3(&quot;我是在C线程中&quot;); thread1.start(); thread2.start(); thread3.start(); &#125;&#125; 结果： 从上面的结果可以看到，开启了三个线程，每个线程都卖了5张票，这明显是不合理的，接下来看看用 Runnable 来实现共享 5 张票的例子 使用实现 Runnable 实现共享票数1234567891011121314151617181920212223242526272829303132333435import static java.lang.Thread.currentThread;import static java.lang.Thread.sleep;/** * Created by Sean on 2017/5/9. */class Thread4 implements Runnable &#123; private int ticket = 5; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; synchronized (this) &#123; if (ticket &gt; 0) &#123; System.out.println(currentThread().getName() + &quot;运行，此时的 i = &quot; + i + &quot; 剩余票数&quot; + this.ticket--); &#125; &#125; try &#123; sleep(400); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Main4 &#123; public static void main(String[] args) &#123; Thread4 thread1 = new Thread4(); new Thread(thread1, &quot;我是在A线程中&quot;).start(); new Thread(thread1, &quot;我是在B线程中&quot;).start(); new Thread(thread1, &quot;我是在C线程中&quot;).start(); &#125;&#125; 运行结果： 可以看到，我们用实现 Runnable 接口的方式实现了资源的共享。 那么我们使用继承 Thread 的方式就真的没法实现资源共享吗？ 答案是 NO！ 往下看。 使用继承 Thread 的方式共享的正确示例我们先看下面的代码： 1234567891011121314151617181920212223242526272829303132/** * Created by Sean on 2017/5/9. */class Thread5 extends Thread &#123; private int ticket = 5; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; synchronized (this) &#123; if (ticket &gt; 0) &#123; System.out.println(currentThread().getName() + &quot;运行，此时的 i = &quot; + i + &quot; 剩余票数&quot; + this.ticket--); &#125; &#125; try &#123; sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Main5 &#123; public static void main(String[] args) &#123; Thread5 thread1 = new Thread5(); new Thread(thread1, &quot;我是在A线程中&quot;).start(); new Thread(thread1, &quot;我是在B线程中&quot;).start(); new Thread(thread1, &quot;我是在C线程中&quot;).start(); &#125;&#125; 运行结果： 可以看到，虽然我们使用了继承 Thread 的方式来实现线程类，最后我们也同样实现了多线程中资源的共享。 从而可以判断，原博客的话是有一定错误的。 下面看一下总结： 实现 Runnable 接口比继承 Thread 类所具有的优势： 可以避免java中的单继承的限制 线程池只能放入实现 Runable 或 callable 类线程，不能直接放入继承Thread 的类 两者都有的： 适合多个相同的程序代码的线程去处理同一个资源 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立 提醒一下大家： main() 方法其实也是一个线程，在 java 中所有的线程都是同时启动的，至于什么时候启动，哪个线程先执行，完全是看哪个线程先从 cpu 哪里获取时间片资源。 此外：在 java 中，每次程序运行至少启动两个线程， 一个是 main 线程， 一个是垃圾回收线程。因为每当使用 java 命令执行一个类的时候，实际上都会启动一个 JVM ，每一个 JVM 实际就是在操作系统中启动了一个进程。 四、线程状态转换下面的这个图非常重要！你如果看懂了这个图，那么对于多线程的理解将会更加深刻！ 学过操作系统的同学应该看起来很容易的，毕竟当初考试的时候这一块是个重点，没少复习这一块。 新建状态（New）：新创建了一个线程对象 就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的 start() 方法，该状态的线程位于可运行的线程池中，变为可运行状态，这个时候，只要获取了 cpu 的执行权，就可以运行，进入运行状态。 运行状态（Running）： 就绪状态的线程从 cpu 获得了执行权之后，便可进入此状态，执行 run() 方法里面的代码。 阻塞状态（Blocked）：阻塞状态是线程因为某种原因失去了 cpu 的使用权，暂时停止运行，一直等到线程进入就绪状态，才有机会转到运行状态，阻塞一般分为下面三种： 等待阻塞 ：运行的线程执行了 wait() 方法， JVM 会把该线程放入线程等待池中，（wait() 会释放持有的锁 ） 同步阻塞：运行的线程在获取对象的同步锁时，如果该同步锁被其他线程占用，这时此线程是无法运行的，那么 JVM 就会把该线程放入锁池中，导致阻塞 其他阻塞：运行的线程执行 sleep() 或者 join() 方法，或者发出了 I/O 请求，JVM 会把该线程置为阻塞状态，当 sleep() 状态超时、join() 等待线程终止或者超时、或者 I/O 处理完毕时，线程会重新进入就绪状态，（注意：sleep() 是不会释放本身持有的锁的） 死亡状态（Dead）：线程执行完了之后或者因为程序异常退出了 run() 方法，结束该线程的生命周期。 五、线程调度1. 调整线程优先级Java 线程有优先级，优先级高的线程会获得较多的运行机会，Java 线程的优先级用整数表示，取值范围是 1~10 ，Thread 类有以下三个静态常量：123static int MAX_PRIORITY 线程可以具有的最高优先级，取值为10。 static int MIN_PRIORITY 线程可以具有的最低优先级，取值为1。 static int NORM_PRIORITY 分配给线程的默认优先级，取值为5。 Thread 类的 setPriority() 和 getPriority() 分别用于设置和获取线程的优先级。 每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。 线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。 JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。 2. 线程睡眠Thread.sleep(long millis) 方法，使线程转到阻塞状态。millis 参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep() 平台移植性好。 3. 线程等待Object 类中的 wait() 方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是 Object 类中的方法，行为等价于调用 wait(0) 一样。 4. 线程让步Thread.yield()方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。 5. 线程加入join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。 6. 线程唤醒Object 类中的 notify() 方法，唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。 例如：唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或者劣势， 类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程， 注意： Thread 中 suspend() 和 resume() 两个方法已经在 JDK 1.5 中废除，此处不做介绍，因为有死锁倾向。 六、常用函数说明1. sleep(long millis): 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）2. join() 指等待t线程终止。使用方式123Thread6 thread1 = new Thread6();thread1.start();thread1.join(); 为什么要用join()方法很多情况下，主线程生成并启动了子线程，如果子线程需要大量的耗时运算，主线程往往将于子线程结束之前结束，但是如果主线程处理完了其他事务后，需要用到子线程返回的结果，也就是需要主线程需要在子线程结束后再结束，这时候就要用到 join() 方法。 先看下不加 join() 的代码： 12345678910111213141516171819202122232425262728293031323334/** * Created by Sean on 2017/5/9. */class Thread6 extends Thread &#123; @Override public void run() &#123; super.run(); System.out.println(Thread.currentThread().getName() + &quot;运行开始!&quot;); for (int i = 0; i &lt; 5; i++) &#123; System.out.println(currentThread().getName() + &quot;======&gt;&quot; + i); try &#123; sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + &quot;运行结束!&quot;); &#125;&#125;public class Main6 &#123; public static void main(String[] args) throws InterruptedException &#123; System.out.println(Thread.currentThread().getName() + &quot;线程运行开始!&quot;); Thread6 thread1 = new Thread6(); Thread6 thread2 = new Thread6(); thread1.setName(&quot;线程A&quot;); thread2.setName(&quot;线程B&quot;); thread1.start(); thread2.start(); System.out.println(&quot;这时thread1 和 thread2 都执行完毕之后才能执行主线程打印此句话因为两个子线程都被主线程调用了join() 方法&quot;); System.out.println(Thread.currentThread().getName() + &quot;线程运行结束!&quot;); &#125;&#125; 结果： 从结果中可以看到我们打印的 main 线程运行结束之后，两个子线程才开始执行，这和上面说的是对照的， 下面演示下等待两个子线程结束之后再结束主线程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Created by Sean on 2017/5/9. */class Thread6 extends Thread &#123; @Override public void run() &#123; super.run(); System.out.println(Thread.currentThread().getName() + &quot;运行开始!&quot;); for (int i = 0; i &lt; 5; i++) &#123; System.out.println(currentThread().getName() + &quot;======&gt;&quot; + i); try &#123; sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + &quot;运行结束!&quot;); &#125;&#125;public class Main6 &#123; public static void main(String[] args) throws InterruptedException &#123; System.out.println(Thread.currentThread().getName() + &quot;线程运行开始!&quot;); Thread6 thread1 = new Thread6(); Thread6 thread2 = new Thread6(); thread1.setName(&quot;线程A&quot;); thread2.setName(&quot;线程B&quot;); thread1.start(); try &#123; thread1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; thread2.start(); try &#123; thread2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;这时thread1 和 thread2 都执行完毕之后才能执行主线程打印此句话因为两个子线程都被主线程调用了join() 方法&quot;); System.out.println(Thread.currentThread().getName() + &quot;线程运行结束!&quot;); &#125;&#125; 运行结果： 这个时候不论执行多少遍，都是主线程等待子线程结束后才结束。 如果主线程的执行需要依赖于子线程中的完整数据的时候，这种方法就可以很好的确保两个线程的同步性。 3. yield():暂停当前正在执行的线程对象，并执行其他线程。注意：yield() 应该做的是让当前运行线程回到可运行状态（就绪状态），以允许具有相同优先级的其他线程获得运行机会。因此，使用 yield() 的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证 yield() 达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。 结论：yield() 从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield() 将导致线程从运行状态转到可运行状态（就绪状态），但有可能没有效果。可看上面的图。 看下面的例子： 12345678910111213141516171819202122232425262728/** * yield()的用法 * Created by Sean on 2017/5/9. */class Thread7 extends Thread &#123; @Override public void run() &#123; for (int i = 1; i &lt;= 50; i++) &#123; System.out.println(&quot;&quot; + this.getName() + &quot;-----&quot; + i); // 当i为30时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行） if (i == 30) &#123; this.yield(); &#125; &#125; &#125;&#125;public class Main7 &#123; public static void main(String[] args) &#123; Thread7 thread1 = new Thread7(); Thread7 thread2 = new Thread7(); thread1.setName(&quot;A线程&quot;); thread2.setName(&quot;B线程&quot;); thread1.start(); thread2.start(); &#125;&#125; 运行结果： 第一种情况：A线程当执行到30时会CPU时间让掉，这时A线程抢到 CPU 的时间片执行。第二种情况：B线程当执行到30时会CPU时间让掉，这时A线程抢到 CPU 的时间片执行。第二种情况：从一开始就交替执行，当到30的时候进行一次让步。 sleep()和yield()的区别 sleep() 使当前线程进入停滞状态，所以执行 sleep() 的线程在指定的时间内肯定不会被执行 yield() 只是使当前线程重新回到可执行状态，所以执行 yield() 的线程有可能在进入到可执行状态后马上又被执行。 sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield() 方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程 另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield() 方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。 4. setPriority(): 更改线程的优先级。12345678MIN_PRIORITY = 1NORM_PRIORITY = 5MAX_PRIORITY = 10用法：Thread4 t1 = new Thread4(&quot;t1&quot;);Thread4 t2 = new Thread4(&quot;t2&quot;);t1.setPriority(Thread.MAX_PRIORITY);t2.setPriority(Thread.MIN_PRIORITY); 5. interrupt()不要以为它是中断某个线程！它只是线线程发送一个中断信号，让线程在无限等待时（如死锁时）能抛出抛出，从而结束线程，但是如果你吃掉了这个异常，那么这个线程还是不会中断的！ 6. wait() 暂停线程，释放 cpu 控制权，同时释放对象锁的控制Obj.wait() 与 Obj.notify() 必须要与 synchronized(Obj) 一起使用，也就是 wait 与 notify 是针对已经获取了 Obj 锁进行操作，从语法角度来说就是 Obj.wait()、Obj.notify 必须在 synchronized(Obj){…} 语句块内。从功能上来说 wait 就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的 notify() 就是对对象锁的唤醒操作。但有一点需要注意的是 notify() 调用后，并不是马上就释放对象锁的，而是在相应的 synchronized(){} 语句块执行结束，自动释放锁后， JVM会在wait() 对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。 Thread.sleep() 与 Object.wait() 二者都可以暂停当前线程，释放 CPU 控制权，主要的区别在于 Object.wait() 在释放 CPU 同时，释放了对象锁的控制。 单单在概念上理解清楚了还不够，需要在实际的例子中进行测试才能更好的理解。对 Object.wait() 、Object.notify() 的应用最经典的例子，应该是三线程打印 ABC 的问题了吧，这是一道比较经典的面试题，题目要求如下： 建立三个线程，A线程打印 10 次 A、B 线程打印 10 次 B、C 线程打印 10 次 C，要求线程同时运行，交替打印 10 次 ABC 。这个问题用 Object 的 wait() ， notify() 就可以很方便的解决。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * wait() 练习 * Created by Sean on 2017/5/9. */class Thread8 implements Runnable &#123; private String name; private Object prev; private Object self; private Thread8(String name, Object prev, Object self) &#123; this.name = name; this.prev = prev; this.self = self; &#125; @Override public void run() &#123; int count = 10; while (count &gt; 0) &#123; synchronized (prev) &#123; //上一个对象锁，先申请上一个对象的锁，如果上个线程释放对象锁，则获取该对象锁 synchronized (self) &#123; // 当前对象锁 System.out.print(name + ((count == 1 &amp;&amp; name.equals(&quot;C&quot;)) ? &quot;&quot; : &quot;-&gt;&quot;)); count--; self.notify(); // 唤醒下一个等待线程 &#125; try &#123; prev.wait();// 释放当前线程 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Object a = new Object(); Object b = new Object(); Object c = new Object(); Thread8 threadA = new Thread8(&quot;A&quot;, c, a);//c是上个对象,a是当前对象 Thread8 threadB = new Thread8(&quot;B&quot;, a, b);//a是上个对象,b是当前对象 Thread8 threadC = new Thread8(&quot;C&quot;, b, c);//b是上个对象,c是当前对象 new Thread(threadA).start(); Thread.sleep(100); //确保按顺序A、B、C执行 new Thread(threadB).start(); Thread.sleep(100); //确保按顺序A、B、C执行 new Thread(threadC).start(); Thread.sleep(100); //确保按顺序A、B、C执行 &#125;&#125; 输出结果： 先来解释一下其整体思路，从大的方向上来讲，该问题为三线程间的同步唤醒操作，主要的目的就是 ThreadA -&gt; ThreadB -&gt; ThreadC -&gt; ThreadA 循环执行三个线程。为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是 prev ，就是前一个线程所持有的对象锁。还有一个就是自身对象锁。主要的思想就是，为了控制执行的顺序，必须要先持有 prev 锁，也就前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印，之后首先调用 self.notify() 释放自身对象锁，唤醒下一个等待线程，再调用 prev.wait() 释放 prev 对象锁，终止当前线程，等待循环结束后再次被唤醒。 通过上面代码可以看到， A、B、C 都被顺序打印了十次，过程是这样的： 打印A：A 线程先运行，A 线程持有 C、A对像锁，因为C对象锁对应上一个打印的线程，A 对象锁对应自己打印的线程。然后在自身对象锁中synchronized (self) { }执行完之后唤醒下一个打印线程，然后在上一个对象锁synchronized (prev) { }中暂停线程、释放 CPU 的控制权，同时释放 C 对象锁的控制权 打印B：拿到线程 A 释放的 A 对像锁，然后获取自身的 B 对象锁，重复上面“打印A”的步骤 打印C：拿到线程 B 释放的 B 对像锁，然后获取自身的 C 对象锁，重复上面“打印A”的步骤 打印A：拿到线程 C 释放的 C 对像锁，然后获取自身的 A 对象锁，重复上面“打印A”的步骤.....这样一直执行到程序结束全部打印完毕。 wait() 和 sleep() 区别 共同点： 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。 wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。 如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。 不同点： Thread类的方法：sleep(),yield()等Object的方法：wait()和notify()等 每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 所以sleep()和wait()方法的最大区别是： sleep()睡眠时，保持对象锁，仍然占有该锁； 而wait()睡眠时，释放对象锁。但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法） sleep() 方法sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会; sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。 在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。 wait() 方法wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问； wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。 wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。 七、常见线程名词解释以及常用方法1. 名词解释 主线程：JVM 调用程序 main() 所产生的线程。 当前线程：这个是容易混淆的概念。一般指通过 Thread.currentThread() 来获取的进程。 后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM 的垃圾回收线程就是一个后台线程。用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束 前台线程：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon() 和 setDaemon() 方法来判断和设置一个线程是否为后台线程。 2. 线程类的一些常用方法： sleep()：强迫一个线程睡眠Ｎ毫秒。 isAlive()： 判断一个线程是否存活。 join()： 等待线程终止。 activeCount()： 程序中活跃的线程数。 enumerate()： 枚举程序中的线程。 currentThread()： 得到当前线程。 isDaemon()： 一个线程是否为守护线程。 setDaemon()： 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) setName()： 为线程设置一个名称。 wait()： 强迫一个线程等待。 notify()： 通知一个线程继续运行。 setPriority()： 设置一个线程的优先级。 getPriority():：获得一个线程的优先级。 八、线程同步1、synchronized关键字的作用域 是某个对象实例内，synchronized aMethod(){} 可以防止多个线程同时访问这个对象的 synchronized 方法（如果一个对象有多个 synchronized 方法，只要一个线程访问了其中的一个 synchronized 方法，其它线程不能同时访问这个对象中任何一个 synchronized 方法）。这时，不同的对象实例的 synchronized 方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的 synchronized 方法； 是某个类的范围，synchronized static aStaticMethod{} 防止多个线程同时访问这个类中的 synchronized static 方法。它可以对类的所有对象实例起作用。 2、synchronized关键字实现互斥访问除了方法前用 synchronized 关键字， synchronized 关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){/*区块*/}，它的作用域是当前对象； 3. 不能继承synchronized 关键字是不能继承的，也就是说，基类的方法 synchronized f(){}在继承类中并不自动是synchronized f(){}，而是变成了 f(){} 。继承类需要你显式的指定它的某个方法为 synchronized 方法； 4. 用法Java对多线程的支持与同步机制深受大家的喜爱，似乎看起来使用了synchronized关键字就可以轻松地解决多线程共享数据同步问题。到底如何？――还得对synchronized关键字的作用进行深入了解才可定论。 总的说来，synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果再细的分类，synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。 在进一步阐述之前，我们需要明确几点： 无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。 每个对象只有一个锁（lock）与之相关联。 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。 接着来讨论synchronized用到不同地方对代码产生的影响： 假设P1、P2是同一个类的不同对象，这个类中定义了以下几种情况的同步块或同步方法，P1、P2就都可以调用它们。 把synchronized当作函数修饰符时示例代码如下：1234Public synchronized void methodAAA() &#123; //…. &#125; 这也就是同步方法，那这时 synchronized 锁定的是哪个对象呢？它锁定的是调用这个同步方法对象。也就是说，当一个对象 P1 在不同的线程中执行这个同步方法时，它们之间会形成互斥，达到同步的效果。但是这个对象所属的 Class 所产生的另一对象 P2 却可以任意调用这个被加了 synchronized 关键字的方法。上边的示例代码等同于如下代码：1234567public void methodAAA() &#123; synchronized (this) // (1) &#123; //….. &#125; &#125; (1)处的this指的是什么呢？它指的就是调用这个方法的对象，如P1。可见同步方法实质是将synchronized作用于object reference。――那个拿到了P1对象锁的线程，才可以调用P1的同步方法，而对P2而言，P1这个锁与它毫不相干，程序也可能在这种情形下摆脱同步机制的控制，造成数据混乱. 2. 同步块示例代码如下：12345public void method3(SomeObject so) &#123; synchronized (so) &#123; //….. &#125;&#125; 这时，锁就是so这个对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以这样写程序，但当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的 instance 变量（它得是一个对象）来充当锁：123456789class Foo implements Runnable &#123; private byte[] lock = new byte[0]; // 特殊的instance变量 public void methodA() &#123; synchronized (lock) &#123; //… &#125; &#125;//….. &#125;&#125; 注：零长度的 byte 数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的 byte[] 对象只需3条操作码，而Object lock = new Object()则需要7行操作码。 3. 将synchronized作用于static 函数示例代码如下： 12345678910class Foo &#123; public synchronized static void methodAAA() // 同步的static 函数 &#123;//…. &#125; public void methodBBB() &#123; synchronized (Foo.class) // class literal(类名称字面常量) &#125;&#125; 代码中的 methodBBB() 方法是把 class literal 作为锁的情况，它和同步的 static 函数产生的效果是一样的，取得的锁很特别，是当前调用这个方法的对象所属的类（Class，而不再是由这个 Class 产生的某个具体对象了）。记得在《Effective Java》一书中看到过将 Foo.class 和 P1.getClass() 用于作同步锁还不一样，不能用 P1.getClass() 来达到锁这个 Class 的目的。 P1 指的是由 Foo 类产生的对象。可以推断：如果一个类中定义了一个 synchronized 的 static 函数A，也定义了一个 synchronized 的 instance 函数B，那么这个类的同一对象 Obj 在多线程中分别访问 A 和 B 两个方法时，不会构成同步，因为它们的锁都不一样。 A 方法的锁是 Obj 这个对象，而 B 的锁是 Obj 所属的那个 Class 。 总结 线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。 线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他非同步方法 对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。 对于同步，要时刻清醒在哪个对象上同步，这是关键。 编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。 当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。 死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真让你写个死锁程序，不一定好使，呵呵。但是，一旦程序发生死锁，程序将死掉。 九、线程数据传递 在传统的同步开发模式下，当我们调用一个函数时，通过这个函数的参数将数据传入，并通过这个函数的返回值来返回最终的计算结果。但在多线程的异步开发模式下，数据的传递和返回和同步开发模式有很大的区别。由于线程的运行和结束是不可预料的，因此，在传递和返回数据时就无法象函数一样通过函数参数和 return 语句来返回数据。 1. 通过构造方法传递数据在创建线程时，必须要建立一个 Thread 类的或其子类的实例。因此，我们不难想到在调用 start 方法之前通过线程类的构造方法将数据传入线程。并将传入的数据使用类变量保存起来，以便线程使用(其实就是在 run 方法中使用)。下面的代码演示了如何通过构造方法来传递数据： 123456789101112131415161718192021/** * Created by Sean on 2017/5/9. */class Thread9 extends Thread &#123; private String threadName; public Thread9(String threadName) &#123; this.threadName = threadName; &#125; public void run() &#123; System.out.println(&quot;hello &quot; + threadName); &#125;&#125;public class Main9 &#123; public static void main(String[] args) &#123; Thread9 thread = new Thread9(&quot;world&quot;); thread.start(); &#125;&#125; 由于这种方法是在创建线程对象的同时传递数据的，因此，在线程运行之前这些数据就就已经到位了，这样就不会造成数据在线程运行后才传入的现象。如果要传递更复杂的数据，可以使用集合、类等数据结构。使用构造方法来传递数据虽然比较安全，但如果要传递的数据比较多时，就会造成很多不便。由于 Java 没有默认参数，要想实现类似默认参数的效果，就得使用重载，这样不但使构造方法本身过于复杂，又会使构造方法在数量上大增。因此，要想避免这种情况，就得通过类方法或类变量来传递数据。 2. 通过变量和方法传递数据向对象中传入数据一般有两次机会： 第一次机会是在建立对象时通过构造方法将数据传入； 另外一次机会就是在类中定义一系列的 public 的方法或变量（也可称之为字段）。然后在建立完对象后，通过对象实例逐个赋值。下面的代码是对Thread9 类的改版，使用了一个 setThreadName 方法来设置 threadName 变量： 1234567891011121314151617181920212223242526272829/** * Created by Sean on 2017/5/9. */class Thread9 extends Thread &#123; private String threadName; public Thread9(String threadName) &#123; this.threadName = threadName; &#125; public String getThreadName() &#123; return threadName; &#125; public void setThreadName(String threadName) &#123; this.threadName = threadName; &#125; public void run() &#123; System.out.println(&quot;hello &quot; + threadName); &#125;&#125;public class Main9 &#123; public static void main(String[] args) &#123; Thread9 thread = new Thread9(&quot;world&quot;); thread.start(); &#125;&#125; 3. 通过回调函数传递数据面讨论的两种向线程中传递数据的方法是最常用的。但这两种方法都是 main 方法中主动将数据传入线程类的。这对于线程来说，是被动接收这些数据的。然而，在有些应用中需要在线程运行的过程中动态地获取数据，如在下面代码的 run 方法中产生了 3 个随机数，然后通过 Work 类的 process 方法求这三个随机数的和，并通过 Data 类的 value 将结果返回。从这个例子可以看出，在返回 value 之前，必须要得到三个随机数。也就是说，这个 value 是无法事先就传入线程类的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 回调实现多线程传递数据 * Created by Sean on 2017/5/9. */class Data &#123; public int value = 0;&#125;class Work &#123; public void process(Data data, Integer[] numbers) &#123; for (int n : numbers) &#123; data.value += n; &#125; &#125;&#125;class Thread10 extends Thread &#123; private Work work; public Thread10(Work work) &#123; this.work = work; &#125; @Override public void run() &#123; super.run(); Integer[] numbers = new Integer[3]; java.util.Random random = new java.util.Random(); Data data = new Data(); for (int i = 0; i &lt; numbers.length; i++) &#123; numbers[i] = random.nextInt(100); &#125; work.process(data,numbers); System.out.println(String.valueOf(numbers[0]) + &quot;+&quot; + String.valueOf(numbers[1]) + &quot;+&quot; + String.valueOf(numbers[2]) + &quot;=&quot; + data.value); &#125; public static void main(String[] args) &#123; Thread thread = new Thread10(new Work()); thread.start(); &#125;&#125; 多线程就写到这里了，基本都是按照这篇博客敲的，每个贴的代码都是亲自重写、验证，都是可执行的，虽然花了很多时间，但是自己对多线程有了更深层次的认识，希望这篇文章可以帮到大家。 林炳文Evankaka原创作品。出处http://blog.csdn.net/evankaka","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Java Java基础","slug":"Java-Java基础","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Java-Java基础/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android基础---你必须了解的应用文件目录","slug":"Android基础-你必须了解的应用文件目录","date":"2017-05-02T09:29:32.000Z","updated":"2018-01-16T03:23:13.789Z","comments":true,"path":"2017/05/02/Android基础-你必须了解的应用文件目录/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/05/02/Android基础-你必须了解的应用文件目录/","excerpt":"","text":"在开发中一般会对手机的内存进行操作，比如在使用应用过程中产生的一些日志、图片等信息，我们有时候要对其进行必要的操作，所以要对文件这一块要有一个基础的理解。 概念1、内部存储：首先说明一个概念，内部存储不是内存，而是像磁盘一样可以存储数据的地方，他在手机内部，属于手机自带内存的一部分。 内部存储私有目录里面有一个 data/data 文件夹，下面存放是所有应用程序的包名文件夹，这部分的内容只有在手机 root 之后才能看得到，如果使用的是模拟器，可以在 Android Device Monitor 中看到。 比如一个应用的包名为 com.test.test 那么这个应用只能访问 /data/data/com.test.test 目录下面的文件，其他 data/data 目录下面的文件这个应用是访问不到的 方法： Environment.getDataDirectory(); 获取data根目录 getFilesDir() 方法用于获取 /data/data/&lt;application package&gt;/files 目录 getCacheDir() 方法用于获取 /data/data/&lt;application package&gt;/cache 目录 deleteFile() 删除文件 fileList() 列出所有文件 注意：当用户卸载 App 时，系统自动删除 data/data 目录下对应包名的文件夹及其内容。 2、外部存储这里不要被外部存储几个字所迷惑，这里说的外部存储其实不单单指的外置的内存卡， Android 手机在出厂的时候的内存，比如平常我们所说的 64G 、128G 内存，这个部分就是我们开发人员所说的外部存储。 那我们往手机里面插入的内存卡叫什么呢？对的，也是叫外部存储。 在参考文章看到一句话：只要是能看得到，都是外部存储。 外部存储私有目录 备注：一般设备都有内置 SD 卡，同时也提供外部 SD 卡拓展，可能对应路径的目录名有所差异。 如果没有插入内存卡的话，一般外部存储的私有目录就是：1/storage/emulated/0/Android/data/app package name 方法： Environment.getExternalStorageDirectory(); 获取 SD 卡根目录 getExternalFilesDir() 方法用于获取 /storage/emulated/0/Android/data/&lt;application package&gt;/files 目录 getExternalCacheDir() 方法用于获取 /storage/emulated/0/Android/data/&lt;application package&gt;/cache 目录 除了上面的files目录和cache目录，我们可以根据自己的分类建立其他的目录，便于我们更好的管理 3、内部存储私有目录 VS 外部存储私有目录不同点 默认情况下，系统并不会自动创建外部存储空间的应用私有目录。只有在应用需要的时候，开发人员通过 SDK 提供的 API 创建该目录文件夹和操作文件夹内容 自 Android 7.0 开始，系统对应用私有目录的访问权限进一步限制。其他 App 无法通过 file:// 这种形式的 Uri 直接读写该目录下的文件内容，而是通过 FileProvider 访问 宿主 App 可以直接读写内部存储空间中的应用私有目录；而在 4.4 版本开始，宿主 App 才可以直接读写外部存储空间中的应用私有目录，使开发人员无需在 Manifest 文件中或者动态申请外部存储空间的文件读写权限 相同点 同属于应用私有目录，当用户卸载 App 时，系统也会自动删除外部存储空间下的对应 App 私有目录文件夹及其内容。 4、最后内部存储私有目录： SharedPreferences SQLiteDatabase App 中的 WebView 缓存页面信息 不要往里面存放太多的数据 外部存储私有目录： 应用自己使用的图片等数据 缓存数据 日志数据 如果想被其他应用访问到的数据，在 SD 卡的根目录再新建一些文件夹，就不要写在外部存储私有目录下面了。 暂时写这么多，以后开发过程中继续填补。 参考文章： android中的文件操作详解以及内部存储和外部存储 了解 Android 应用的文件存储目录，掌握持久化数据的正确姿势 Android入门之文件系统操作（二）文件操作相关指令","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android基础---PopupWindow实现漂亮的搜索","slug":"Android基础-PopupWindow实现漂亮的搜索","date":"2017-04-21T06:27:37.000Z","updated":"2018-01-16T03:14:44.013Z","comments":true,"path":"2017/04/21/Android基础-PopupWindow实现漂亮的搜索/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/04/21/Android基础-PopupWindow实现漂亮的搜索/","excerpt":"","text":"当初做毕业设计的时候，就在毕业设计 App 上面实现了该功能，当初只是简单的堆积代码，代码都是从别处拷贝了，对具体代码的意思也不是很清楚，现在做了一个简单的开源项目，也实现了该搜索功能，现在对 PopupWindow 有了更新的认识。 本文会一步一步的教你实现效果图中的效果，包会。。。如果还是不会的话，欢饮点击下面的链接去看看我的项目中怎么用的。 我的开源项目：Gank.io客户端App 下载地址 ：App下载 密码：ckgd 效果图 一步步的具体实现1. 搜索框和搜索按钮的背景在 drawable 文件夹下新建文件 editsharp.xml123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;gradient android:angle=&quot;45&quot; android:endColor=&quot;#CCCCCC&quot; android:startColor=&quot;#CCCCCC&quot; /&gt; &lt;padding android:bottom=&quot;7dp&quot; android:left=&quot;7dp&quot; android:right=&quot;7dp&quot; android:top=&quot;7dp&quot; /&gt; &lt;!-- 设置圆角矩形 --&gt; &lt;corners android:radius=&quot;32dp&quot; /&gt; &lt;solid android:color=&quot;#FFFFFF&quot; /&gt;&lt;/shape&gt; 2.修改 EditText 光标的颜色在 drawable 文件夹下新建文件 color_cursor.xml12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;size android:width=&quot;1dp&quot; /&gt; &lt;solid android:color=&quot;@color/colorPrimary&quot; /&gt;&lt;/shape&gt; 3.新建 PopupWindow 的布局文件在 layout文件夹下新建文件 search_popup.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;@dimen/common_toolbar_height&quot; android:background=&quot;@color/colorPrimary&quot;&gt; &lt;RelativeLayout android:layout_marginLeft=&quot;12dp&quot; android:id=&quot;@+id/select_type_rl&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/select_type_tv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:drawableRight=&quot;@drawable/toward_bottom_ic&quot; android:gravity=&quot;center_vertical&quot; android:text=&quot;@string/all_text&quot; android:textColor=&quot;@color/white&quot; /&gt; &lt;/RelativeLayout&gt; &lt;EditText android:id=&quot;@+id/search_et&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_toLeftOf=&quot;@+id/search_bt&quot; android:layout_toRightOf=&quot;@+id/select_type_rl&quot; android:background=&quot;@drawable/editsharp&quot; android:drawableLeft=&quot;@drawable/common_search_ic&quot; android:hint=&quot;请输入关键字...&quot; android:imeOptions=&quot;actionSearch&quot; android:inputType=&quot;text&quot; android:singleLine=&quot;true&quot; android:textCursorDrawable=&quot;@drawable/color_cursor&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;Button android:id=&quot;@+id/search_bt&quot; android:layout_width=&quot;56dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignBottom=&quot;@+id/search_et&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_alignTop=&quot;@+id/search_et&quot; android:layout_marginLeft=&quot;12dp&quot; android:layout_marginRight=&quot;12dp&quot; android:background=&quot;@drawable/editsharp&quot; android:text=&quot;搜索&quot; android:textColor=&quot;@color/colorPrimary&quot; android:textSize=&quot;14sp&quot; /&gt;&lt;/RelativeLayout&gt; 4. 为 PopupWindow 设置的动画在 res 下面新建 anim 文件夹。 新建 inuptodown.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;translate android:duration=&quot;100&quot; android:fromYDelta=&quot;-100%&quot; android:toYDelta=&quot;0&quot; /&gt;&lt;/set&gt; 新建 outdowntoup.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration=&quot;100&quot; android:fromYDelta=&quot;0&quot; android:toYDelta=&quot;-100%&quot; /&gt;&lt;/set&gt; 然后在 styles 文件里面添加：12345&lt;!--淡入淡出效果--&gt;&lt;style name=&quot;AnimBottom&quot; parent=&quot;@android:style/Animation&quot;&gt; &lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@anim/inuptodown&lt;/item&gt; &lt;item name=&quot;android:windowExitAnimation&quot;&gt;@anim/outdowntoup&lt;/item&gt;&lt;/style&gt; 4.初始化 PopupWindow123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 初始化PopupWindow */ protected void initPopupWindow() &#123; final View view = getLayoutInflater().inflate(R.layout.search_popup, null, false); int height = commonTitleTb.getHeight(); // 获取当前页面ToolBar的高度 final EditText searchEt = (EditText) view.findViewById(R.id.search_et); popupWindow = new PopupWindow(view, ViewGroup.LayoutParams.MATCH_PARENT, height, true); final TextView selectTypeTv = (TextView) view.findViewById(R.id.select_type_tv); final RelativeLayout selectTypeRl = (RelativeLayout) view.findViewById(R.id.select_type_rl); popupWindow.setFocusable(true);//设置外部点击取消 popupWindow.setBackgroundDrawable(new BitmapDrawable());// 不设置的话不能关闭此 PopupWindow popupWindow.setAnimationStyle(R.style.AnimBottom); view.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; if (popupWindow != null &amp;&amp; popupWindow.isShowing()) &#123; popupWindow.dismiss(); popupWindow = null; &#125; return false; &#125; &#125;); searchEt.setOnEditorActionListener(new TextView.OnEditorActionListener() &#123; @Override public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123; if (actionId == EditorInfo.IME_ACTION_SEARCH) &#123; String searchContent = searchEt.getText().toString(); if (TextUtils.isEmpty(searchContent)) &#123; return false; &#125; else &#123; // todo someThing // getSearchData(selectType, searchContent); &#125; popupWindow.dismiss(); &#125; return false; &#125; &#125;); selectTypeRl.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // todo someThing &#125; &#125;); view.findViewById(R.id.search_bt).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // todo someThing popupWindow.dismiss(); &#125; &#125;); // PopupWindow的消失事件监听，消失的时候，关闭软键盘 popupWindow.setOnDismissListener(new PopupWindow.OnDismissListener() &#123; @Override public void onDismiss() &#123; KeyBoardUtils.closeKeybord(context); &#125; &#125;); &#125; 获取 PopupWindow 实例1234567891011/** * 获取PopipWinsow实例 */private void getPopupWindow() &#123; if (null != popupWindow) &#123; popupWindow.dismiss(); return; &#125; else &#123; initPopupWindow(); &#125;&#125; 5.调用 PopupWindow12345getPopupWindow();// 设置相对View的偏移，1、相对的view，2、相对view的x方向偏移，3、相对view的y方向偏移popupWindow.showAsDropDown(new View(this), 0, ScreenUtils.getStatusHeight(MainActivity.this));//打开软键盘KeyBoardUtils.openKeyboard(new Handler(), 0, context); 至此就可以完成效果图中的效果了。 与此相关的有： 我的第一个开源项目Android基础之—工具类 持续更新中…Android基础—淡入淡出、上下弹出动画的Android PopupWindow详解 我的博客：博客传送门 我的简书：简书传送门 我的CSDN：CSDN传送门 我的GitHub：GitHub传送门","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"我的第一个开源项目","slug":"我的第一个开源项目","date":"2017-04-19T13:43:30.000Z","updated":"2018-02-02T07:11:40.159Z","comments":true,"path":"2017/04/19/我的第一个开源项目/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/04/19/我的第一个开源项目/","excerpt":"前言从去年到现在学习 Android 到现在已经有一年时间了，都是靠自己自学在慢慢进步，虽说自己还没能力开发一些吊炸天的开源项目供大家使用，但是我懂在自学过程中需要一些什么，所以就有一个制作一个开源项目与一些朋友互相学习的想法，最近利用自己的工作之余写了这个简单的 Gank.io 客户端。虽然网上已经有很多类似的 Gank.io 客户端，但是我还是挺喜欢自己的写的这个，因为里面有自己的想要学习和复习的知识点，以后工作中遇到一些问题，亦或是想复习一些知识点，也许参考下这个项目就解决了。嗯，这个项目会一直被我写下去的。","text":"前言从去年到现在学习 Android 到现在已经有一年时间了，都是靠自己自学在慢慢进步，虽说自己还没能力开发一些吊炸天的开源项目供大家使用，但是我懂在自学过程中需要一些什么，所以就有一个制作一个开源项目与一些朋友互相学习的想法，最近利用自己的工作之余写了这个简单的 Gank.io 客户端。虽然网上已经有很多类似的 Gank.io 客户端，但是我还是挺喜欢自己的写的这个，因为里面有自己的想要学习和复习的知识点，以后工作中遇到一些问题，亦或是想复习一些知识点，也许参考下这个项目就解决了。嗯，这个项目会一直被我写下去的。 先贴上项目地址Gank.io客户端，希望能和大家互相学习。 App下载 密码：ckgd 效果图 画质有点渣，有兴趣的可以去下载 App 去体验下：安装包下载 密码：ckgd 通过这个项目我练习的知识点有： Syringe 一个将网络请求集中处理的库 RxJava + Retrofit 实现网络请求 图片瀑布流的实现 一个项目一个Toolbar Fragment 的复用 Fragment 和 TabLayout 的结合使用 WebView的使用 侧边栏 DrawerLayout 的使用 PopupWindow 实现美观的搜索界面 Glide 加载图片的一些坑 RecyclerView 和 CardView 结合实现美观的悬浮列表 RecyclerView 实现上垃加载和下拉刷新 本项目在继续完善中。 你可以通过以下方式关注我： CSDN 掘金 个人博客","categories":[{"name":"我","slug":"我","permalink":"https://github.com/smartsean/smartsean.github.io/categories/我/"}],"tags":[{"name":"我","slug":"我","permalink":"https://github.com/smartsean/smartsean.github.io/tags/我/"}],"keywords":[{"name":"我","slug":"我","permalink":"https://github.com/smartsean/smartsean.github.io/categories/我/"}]},{"title":"Ionic Angular 实现验证码倒计时功能","slug":"Ionic-Angular-实现验证码倒计时功能","date":"2017-04-19T10:42:32.000Z","updated":"2018-02-02T06:15:00.973Z","comments":true,"path":"2017/04/19/Ionic-Angular-实现验证码倒计时功能/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/04/19/Ionic-Angular-实现验证码倒计时功能/","excerpt":"","text":"前段时间分享了 Android 原生实现验证码倒计时，地址是这里，现在公司使用 Ionic 开发的 App 也要实现类似的功能，现在也记录下来，供大家参考： 效果图： 正文首先介绍下与本文相关的概念 $interval $interval 是 window.setInterval 的 Angular 包装形式，函数如果在没有被取消的时候会无限执行。（取消使用 cancel(promise) ） 用法：1$interval(fn,delay,[count],[invokeApply],[Pass]); 参数说明： fn : 无限执行的函数 必须参数，必传 delay : 每次调用的间隔毫秒数值 必须参数，必传 count : 循环次数的数值，如果没设置，则无限制循环 非必须参数，可不传 invokeApply : 如果设置为false，则避开脏值检查，否则将调用$apply 非必须参数，可不传 Pass : 函数的附加参数 非必须参数，可不传 方法： cancel(promise) promise：$interval函数的返回值。 具体实现1234567891011121314151617181920$scope.description = \"获取验证码\";var timerHandler = null;/** * 倒计时 * @param time 控制循环次数 */var countDown = function (second,time) &#123; timerHandler = $interval(function () &#123; if (second &lt;= 0) &#123; $interval.cancel(timerHandler); second = 59; $scope.description = \"获取验证码\"; &#125; else &#123; $scope.description = second + \"s 后可重发\"; second--; &#125; &#125;, 1000, time)&#125; 调用1countDown(59,60); 最后别忘了注入 $interval 。 我的博客：博客传送门 我的简书：简书传送门 我的CSDN：CSDN传送门 我的GitHub：GitHub传送门","categories":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Ionic/"}],"tags":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Ionic/"}],"keywords":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Ionic/"}]},{"title":" Ionic Cordova实现软键盘的监听 以及操作大全","slug":"Ionic-Cordova实现软键盘的监听-以及操作大全","date":"2017-04-19T10:40:26.000Z","updated":"2018-02-02T06:15:00.973Z","comments":true,"path":"2017/04/19/Ionic-Cordova实现软键盘的监听-以及操作大全/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/04/19/Ionic-Cordova实现软键盘的监听-以及操作大全/","excerpt":"","text":"今天在做项目的时候，在键盘显示的时候隐藏某些操作，键盘隐藏的时候，打开某些操作。网上找了很久，才找到具体的监听事件，特此记录下来，供大家参考： 首先需要添加插件：1cordova plugin add ionic-plugin-keyboard --save 1.软键盘显示监听1234window.addEventListener('native.keyboardshow', function (e) &#123; // todo 进行键盘可用时操作 //e.keyboardHeight 表示软件盘显示的时候的高度 &#125;); 2.软键盘隐藏监听123window.addEventListener(&apos;native.keyboardhide&apos;, function (e) &#123; // todo 进行键盘不可用时操作&#125;); 3. 打开软键盘1cordova.plugins.Keyboard.show(); 4. 关闭软键盘1cordova.plugins.Keyboard.close(); 5. 判断软键盘是否可用1cordova.plugins.Keyboard.isVisible 注意，这个不是方法，是一个属性。 6. 显示隐藏键盘附件栏12cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);cordova.plugins.Keyboard.hideKeyboardAccessoryBar(false); 7. 禁止和允许滑动12cordova.plugins.Keyboard.disableScroll(true);cordova.plugins.Keyboard.disableScroll(false); 我的博客：博客传送门 我的简书：简书传送门 我的CSDN：CSDN传送门 我的GitHub：GitHub传送门","categories":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Ionic/"}],"tags":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Ionic/"}],"keywords":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Ionic/"}]},{"title":"多终端更新个人博客教程","slug":"多终端更新个人博客教程","date":"2017-04-14T08:29:44.000Z","updated":"2018-02-02T06:15:00.963Z","comments":true,"path":"2017/04/14/多终端更新个人博客教程/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/04/14/多终端更新个人博客教程/","excerpt":"去年就搭建了自己的博客，但是最近域名到期了，账号密码也忘记了（尴尬），于是就重新搭建了一次博客，地址是：我的博客，但是自己又想在家和公司都能更新博客，于是花功夫研究了一下，将此次研究的成果记录如下：","text":"去年就搭建了自己的博客，但是最近域名到期了，账号密码也忘记了（尴尬），于是就重新搭建了一次博客，地址是：我的博客，但是自己又想在家和公司都能更新博客，于是花功夫研究了一下，将此次研究的成果记录如下： 一、首先你需要搭建好自己的博客。给出参考给大家： 一定基础的看这个 完全小白看这个 二、多终端配置1. 创建博客备份的仓库这里我选用的是国内的代码托管平台 码云 ，因为上面可以建立自己的私人仓库，这样的话，可以很好的保护你的个人隐私。 这里是地址 然后新建一个备份博客文件的仓库，比如我的仓库名字是 blog ，然后再 blog 仓库下面新建了一个分支是 hexo （当然你也可以用其他的，我只是为了容易辨识）。如图所示： 2. 将本地博客上传到私有仓库我们在使用 hexo 搭建自己本地博客的时候，会创建一个文件夹来存放，比如我的是 blog文件夹，如图所示： 其实就是我们本地博客的根目录， 然后我们在此处打开 Git Bash ，进行以下操作： 初始化仓库 12git initgit branch -b hexo //新建hexo分支并切换到hexo 添加必要文件到仓库中 1234567 git add scaffolds/git add source/git add themes // 注意这里是不能添加你通过 git 下载的主题的git add .npmignoregit add _config.ymlgit add package.jsongit commit -m &quot;init&quot; 添加本地和远程私有仓库的关联 1git remote add origin 仓库地址 提交代码到仓库 1git push origin hexo //提交到你创建好的分支 到这里已经成功的把博客必要文件传到本地仓库了。 接下来是在另外一台电脑上操作的。 3. 第二台电脑配置 首先我们需要把博客必要文件拉到本地1git clone 仓库地址 -b hexo 此时本地会生成博客文件夹，我的是 blog ，其实就是你的私有仓库的名字。进入该文件夹：1cd blog //注意！这里你的可能不是叫 blog ，具体根据你仓库名字而定 安装必要的组件1npm install 如果你的主题是通过 git 下载的话，需要重新再第二台电脑上下载，不然打开的页面是空的。这个时候你的两台电脑的配置就基本完成了。 4. 在任意一台配置好的电脑上发布博客 同步私有仓库文件 1git pull origin hexo 新建博客 1hexo new post &quot;博客名字&quot; 添加博客到 git 1git add source/ //因为博客文件是在source文件夹下面的 保存代码 1git commit -m &quot;博客更新&quot; 上传更新 1git push origin hexo 部署博客 1hexo g -d 至此，多终端发布博客已经配置完成。 如果你在配置的过程中遇到问题，欢迎留言交流~ 我的博客：博客传送门 我的简书：简书传送门 我的CSDN：CSDN传送门 我的GitHub：GitHub传送门","categories":[{"name":"我","slug":"我","permalink":"https://github.com/smartsean/smartsean.github.io/categories/我/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://github.com/smartsean/smartsean.github.io/tags/工具/"}],"keywords":[{"name":"我","slug":"我","permalink":"https://github.com/smartsean/smartsean.github.io/categories/我/"}]},{"title":"Error inflating class android.support.design.widget.FloatingActionButton","slug":"Error-inflating-class-android-support-design-widget-FloatingActionButton","date":"2017-03-30T15:05:12.000Z","updated":"2018-01-16T03:12:50.493Z","comments":true,"path":"2017/03/30/Error-inflating-class-android-support-design-widget-FloatingActionButton/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/03/30/Error-inflating-class-android-support-design-widget-FloatingActionButton/","excerpt":"","text":"我的简书：简书传送门 我的CSDN：CSDN传送门 我的GitHub：GitHub传送门 错误信息今天添加FloatingActionButton的时候，修改了默认的背景，结果导致Caused by: android.view.InflateException: Binary XML file line #54: Error inflating class android.support.design.widget.FloatingActionButton错误。 解决方案：把1android:backgroundTint=&quot;@color/colorPrimary&quot; 换成1app:backgroundTint=&quot;@color/colorPrimary&quot; 即可。 希望对你能有些帮助。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"},{"name":"异常","slug":"异常","permalink":"https://github.com/smartsean/smartsean.github.io/tags/异常/"}],"keywords":[]},{"title":"写给新手的Android环境配置","slug":"写给新手的Android环境配置","date":"2017-03-21T09:17:04.000Z","updated":"2018-01-16T03:12:09.965Z","comments":true,"path":"2017/03/21/写给新手的Android环境配置/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/03/21/写给新手的Android环境配置/","excerpt":"","text":"我的简书：简书传送门 我的CSDN：CSDN传送门 我的GitHub：GitHub传送门 前言今天有个新学 Android 的小伙伴问我怎么配置环境，这让我想到到自己刚开始学的时候也是对环境变量配置一脸懵逼，决定今天写下来，供 Android 新手参考。 准备工作首先打开配置： 在 “此电脑” 右键打开属性—&gt; 打开高级系统设置 —&gt; 打开环境变量，如下图所示： 一、 JDK 环境配置 点击系统变量下面的新建。 新建 12变量名：JAVA_HOME变量值：你的 SDK 安装路径（我的是：D:\\Program Files\\Java\\jdk1.8.0_102） 新建 12变量名：CLASSPATH变量值：.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar; 点开系统变量下面的 path ，在后面新加： 1%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; 二、 SDK环境配置 点击系统变量下面的新建。 新建 12变量名：ANDROID_HOME变量值：你的 SDK 安装路径（我的是：D:\\android\\03android-sdk） 点开系统变量下面的 path ，在后面新加： 1%ANDROID_HOME%\\platform-tools;%ANDROID_HOME%\\tools; 希望大家能够喜欢。","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Git常用操作、提交到GitHub等","slug":"Git","date":"2017-03-19T13:53:15.000Z","updated":"2018-01-16T02:24:59.484Z","comments":true,"path":"2017/03/19/Git/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/03/19/Git/","excerpt":"","text":"用了git好长时间了，但是很多命令不是经常用，容易忘掉，想了想还是记录下来，建立自己的git知识库，以后用的时候找起来也方便，会持续更新这个博客的。 一、初始化clone的时候直接切换到指定的分支：1git clone 地址 -b 分支名称 配置全局的Git：git config --global user.name &quot;你的名字&quot; git config --global user.email &quot;你的邮箱地址&quot; 初始化本地Git仓库：git init 查看仓库状态git status 撤销所有本地更改git reset --hard$HEAD 把文件改动手动添加到【暂存区】git add . 提交本次修改的代码(1)git commit -a 输入i之后输入本次提交的描述，然后点击Esc，输入:wq保存 提交本次修改的代码(1)git commit -m &quot;输入提交描述&quot; 获取网络端最新的代码git pull 向网络端提交本地仓库代码git push 二、分支新建a分支git branch a 切换到a分支git checkout a 新建分支a并切换到a分支git checkout -b a 删除a分支git branch -d a 强制删除a分支git branch -D a 查看分支git branch 合并分支比如我们要把a分支的代码合并到b分支上，首先需要切换到b分支1git checkout b 然后1git merge a 这样就可以合并a分支的内容到b分支了 三、远程上传操作1. 本地不存在git仓库，同步到GitHub123456git initgit add .git commit -agit remote add origin github地址git pull --rebase origin mastergit push -u origin master 2. 本地存在git仓库，并且没有绑定远程地址，同步到GitHub1git remote add origin github地址 3. 本地存在git仓库，并且已经绑定远程地址，需要修改地址并同步到GitHub1234git remote set-url origin 新github地址或者git remote rm origingit remote add origin 新github地址 如果是代码拉下来之后需要新建一个分支，在本地执行git branch -dev，这个时候就建立好了另外一个分支，如果把这个分支提交到github上，需要执行git push -u origin dev,这个时候dev下面的代码就可以提交到github上了 2017-8-18更新今天在gitlab上面看到了给的提示，这里也贴一下吧： 一、Create a new repository123456git clone git地址cd i5oncalltouch README.mdgit add README.mdgit commit -m &quot;add README&quot;git push -u origin master 2、Existing folder or Git repository123456cd existing_foldergit initgit remote add origin git地址git add .git commitgit push -u origin master","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/smartsean/smartsean.github.io/categories/工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Git/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://github.com/smartsean/smartsean.github.io/categories/工具/"}]},{"title":"一个项目，一个Toolbar","slug":"一个项目，一个Toolbar","date":"2017-03-13T05:58:58.000Z","updated":"2018-01-16T03:11:43.591Z","comments":true,"path":"2017/03/13/一个项目，一个Toolbar/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/03/13/一个项目，一个Toolbar/","excerpt":"","text":"需求在日常的开发当中，经常会用到Toolbar作为标题栏，如果在每个view里面都写一个Toolbar的话，显然有点冗余，一般情况下在每个项目里面都有一个BaseActivity，作为所有Activity的父类，我们就可以在BaseActivity中封装好Toolbar，在子类用BaseActivity提供的方法调用即可。 展示来来来，往这边看，下面的的gif都是通过一个Toolbar实现的： 是不是很不错，只用在子Activity中调用BaseActivity中的方法或者重写方法就可以了。有兴趣的可以看下代码，欢迎指正 Demo地址 实现先在BaseActivity中写好布局文件，一个Toolbar和一个RelativeLayout： 先看布局文件activity_base.xml： common_title_tb 就是我们复用的toolbar。 common_title_tv 就是复用的toolbar中的标题。 RelativeLayout 就是我们子Activity所要显示的地方 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_base\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"com.sean.demo.ui.BaseActivity\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/common_title_tb\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/common_toolbar_height\" android:background=\"@color/colorPrimary\" android:elevation=\"6dp\"&gt; &lt;TextView android:id=\"@+id/common_title_tv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:text=\"我是标题\" android:textColor=\"@color/white\" android:textSize=\"16sp\" /&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;RelativeLayout android:id=\"@+id/content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt;&lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 然后我们需要在BaseActivity中暴露给子类特定的方法，让子类去根据自己的实际情况去定制页面。 接下来看下我们的BaseActivity：主要方法有： setToolBar 子类重新设置Toolbar样式（需要子类重新写一个Toolbar） hidetoolBar 子类不需要Toolbar的时候，可以隐藏掉通用的Toolbar setToolBarMenuOnclick 给Toolbar的menu设置点击事件，满足不同页面的需求 setBackArrow 设置通用的返回按钮，需要的时候直接调用该方法就可以了 setContentLayout 设置子类的布局（这个时候就不用设置setContentView()了） setTitle 设置标题文字 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class BaseActivity extends AppCompatActivity &#123; /** * 通用的ToolBar标题 */ private TextView commonTitleTv; /** * 通用的ToolBar */ private Toolbar commonTitleTb; /** * 内容区域 */ private RelativeLayout content; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_base); initView(); setSupportActionBar(commonTitleTb); getSupportActionBar().setDisplayShowTitleEnabled(false); &#125; private void initView() &#123; commonTitleTv = (TextView) findViewById(R.id.common_title_tv); commonTitleTb = (Toolbar) findViewById(R.id.common_title_tb); content = (RelativeLayout) findViewById(R.id.content); &#125; /** * 子类调用，重新设置Toolbar * * @param layout */ public void setToolBar(int layout) &#123; hidetoolBar(); commonTitleTb = (Toolbar) content.findViewById(layout); setSupportActionBar(commonTitleTb); //设置actionBar的标题是否显示，对应ActionBar.DISPLAY_SHOW_TITLE。 getSupportActionBar().setDisplayShowTitleEnabled(false); &#125; /** * 隐藏ToolBar，通过setToolBar重新定制ToolBar */ public void hidetoolBar() &#123; commonTitleTb.setVisibility(View.GONE); &#125; /** * menu的点击事件 * * @param onclick */ public void setToolBarMenuOnclick(Toolbar.OnMenuItemClickListener onclick) &#123; commonTitleTb.setOnMenuItemClickListener(onclick); &#125; /** * 设置左上角back按钮 */ public void setBackArrow() &#123; final Drawable upArrow = getResources().getDrawable(R.drawable.common_back_ic); //给ToolBar设置左侧的图标 getSupportActionBar().setHomeAsUpIndicator(upArrow); // 给左上角图标的左边加上一个返回的图标 。对应ActionBar.DISPLAY_HOME_AS_UP getSupportActionBar().setDisplayHomeAsUpEnabled(true); //设置返回按钮的点击事件 commonTitleTb.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; finish(); &#125; &#125;); &#125; /** * 设置toolbar下面内容区域的内容 * * @param layoutId */ public void setContentLayout(int layoutId) &#123; LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE); View contentView = inflater.inflate(layoutId, null); ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); content.addView(contentView, params); &#125; /** * 设置标题 * * @param title */ public void setTitle(String title) &#123; if (!TextUtils.isEmpty(title)) &#123; commonTitleTv.setText(title); &#125; &#125; /** * 设置标题 * * @param resId */ public void setTitle(int resId) &#123; commonTitleTv.setText(resId); &#125;&#125; 比如你想在上面gif图的EventBusActivity的Activity使用，并且实现menu点击事件、返回按钮、设置标题等操作，只需要下面很简单的代码就可以了： 再来看看子Activity：12345678@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentLayout(R.layout.activity_event_bus);//设置到BaseActivity中的content中 setTitle(&quot;EventBus使用&quot;);//设置标题 setBackArrow();//设置返回按钮和点击事件 setToolBarMenuOnclick(new EventBusMenuItemClick());//设置menu菜单的显示和点击事件 &#125; 各位看官感兴趣的话，欢迎去看看，这里是地址，有什么可以修改的，欢迎提出宝贵意见！ 欢迎去踩我的简书：我的简书","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Java指定保留小数位数","slug":"Java指定保留小数位数","date":"2017-03-13T05:54:37.000Z","updated":"2018-01-16T03:10:55.277Z","comments":true,"path":"2017/03/13/Java指定保留小数位数/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/03/13/Java指定保留小数位数/","excerpt":"","text":"今天项目中需要更改时长的显示方式，规定必须保留两位小数，刚才看简书的时候正好看到一个指定保留小数位数的工具类的文章，在此基础上，做了一点小修改，用起来更加方便了，有需要的朋友尽管撸走 DecimalUtils 类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import java.math.BigDecimal;import java.math.RoundingMode;import java.text.DecimalFormat;/** * Created by Sean on 17/3/10. */public class DecimalUtils &#123; /** * 按四舍五入保留指定小数位数，位数不够用0补充 * @param o 格式化前的小数 * @param newScale 保留小数位数 * @return 格式化后的小数 */ public static String formatDecimalWithZero(Object o, int newScale) &#123; return String.format(\"%.\" + newScale + \"f\", o); &#125; /** * 按四舍五入保留指定小数位数，位数不够用0补充 * @param d 格式化前的小数 * @param newScale 保留小数位数 * @return 格式化后的小数 */ public static String formatDecimalWithZero(double d, int newScale) &#123; String pattern = \"0.\"; for (int i = 0; i &lt; newScale; i++) &#123; pattern += \"0\"; &#125; DecimalFormat df = new DecimalFormat(pattern); return df.format(d); &#125; /** * 按四舍五入保留指定小数位数，位数不够用0补充 * @param d 格式化前的小数 String形式 * @param newScale 保留小数位数 * @return 格式化后的小数 */ public static String formatDecimalWithZero(String d, int newScale) &#123; String pattern = \"0.\"; for (int i = 0; i &lt; newScale; i++) &#123; pattern += \"0\"; &#125; DecimalFormat df = new DecimalFormat(pattern); return df.format(Double.valueOf(d)); &#125; /** * 按四舍五入保留指定小数位数，小数点后仅保留有效位数 * @param d 格式化前的小数 * @param newScale 保留小数位数 * @return 格式化后的小数 */ public static String formatDecimal(double d, int newScale) &#123; String pattern = \"#.\"; for (int i = 0; i &lt; newScale; i++) &#123; pattern += \"#\"; &#125; DecimalFormat df = new DecimalFormat(pattern); return df.format(d); &#125; /** * 按四舍五入保留指定小数位数，小数点后仅保留有效位数 * @param d 格式化前的小数 * @param newScale 保留小数位数 * @return 格式化后的小数 */ public static String formatDecimal(String d, int newScale) &#123; String pattern = \"#.\"; for (int i = 0; i &lt; newScale; i++) &#123; pattern += \"#\"; &#125; DecimalFormat df = new DecimalFormat(pattern); return df.format(Double.valueOf(d)); &#125; /** * 按指定舍入模式保留指定小数位数 * @param d 格式化前的小数 * @param newScale 保留小数位数 * @param roundingMode 舍入模式 * (RoundingMode.UP始终进一/DOWN直接舍弃/ * CEILING正进负舍/FLOOR正舍负进/ * HALF_UP四舍五入/HALF_DOWN五舍六进/ * HALF_EVEN银行家舍入法/UNNECESSARY抛出异常) * @return 格式化后的小数 */ public static double formatDecimal(double d, int newScale, RoundingMode roundingMode) &#123; BigDecimal bd = new BigDecimal(d).setScale(newScale, roundingMode); return bd.doubleValue(); &#125; /** * 按指定舍入模式保留指定小数位数 * @param d 格式化前的小数 * @param newScale 保留小数位数 * @param roundingMode 舍入模式 * (RoundingMode.UP始终进一/DOWN直接舍弃/ * CEILING正进负舍/FLOOR正舍负进/ * HALF_UP四舍五入/HALF_DOWN五舍六进/ * HALF_EVEN银行家舍入法/UNNECESSARY抛出异常) * @return 格式化后的小数 */ public static double formatDecimal(String d, int newScale, RoundingMode roundingMode) &#123; BigDecimal bd = new BigDecimal(Double.valueOf(d)).setScale(newScale, roundingMode); return bd.doubleValue(); &#125;&#125; 原文地址","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Java/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android进阶---一个项目，一个Toolbar","slug":"Android进阶-一个项目，一个Toolbar","date":"2017-03-11T08:58:21.000Z","updated":"2018-01-16T02:14:37.023Z","comments":true,"path":"2017/03/11/Android进阶-一个项目，一个Toolbar/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/03/11/Android进阶-一个项目，一个Toolbar/","excerpt":"需求在日常的开发当中，经常会用到Toolbar作为标题栏，如果在每个view里面都写一个Toolbar的话，显然有点冗余，一般情况下在每个项目里面都有一个BaseActivity，作为所有Activity的父类，我们就可以在BaseActivity中封装好Toolbar，在子类用BaseActivity提供的方法调用即可。","text":"需求在日常的开发当中，经常会用到Toolbar作为标题栏，如果在每个view里面都写一个Toolbar的话，显然有点冗余，一般情况下在每个项目里面都有一个BaseActivity，作为所有Activity的父类，我们就可以在BaseActivity中封装好Toolbar，在子类用BaseActivity提供的方法调用即可。 展示来来来，往这边看，下面的的gif都是通过一个Toolbar实现的： 是不是很不错，只用在子Activity中调用BaseActivity中的方法或者重写方法就可以了。有兴趣的可以看下代码，欢迎指正 Demo地址 实现先在BaseActivity中写好布局文件，一个Toolbar和一个RelativeLayout： 先看布局文件activity_base.xml： common_title_tb 就是我们复用的toolbar。 common_title_tv 就是复用的toolbar中的标题。 RelativeLayout 就是我们子Activity所要显示的地方 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_base\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"com.sean.demo.ui.BaseActivity\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/common_title_tb\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/common_toolbar_height\" android:background=\"@color/colorPrimary\" android:elevation=\"6dp\"&gt; &lt;TextView android:id=\"@+id/common_title_tv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:text=\"我是标题\" android:textColor=\"@color/white\" android:textSize=\"16sp\" /&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;RelativeLayout android:id=\"@+id/content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt;&lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 然后我们需要在BaseActivity中暴露给子类特定的方法，让子类去根据自己的实际情况去定制页面。 接下来看下我们的BaseActivity：主要方法有： setToolBar 子类重新设置Toolbar样式（需要子类重新写一个Toolbar） hidetoolBar 子类不需要Toolbar的时候，可以隐藏掉通用的Toolbar setToolBarMenuOnclick 给Toolbar的menu设置点击事件，满足不同页面的需求 setBackArrow 设置通用的返回按钮，需要的时候直接调用该方法就可以了 setContentLayout 设置子类的布局（这个时候就不用设置setContentView()了） setTitle 设置标题文字 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class BaseActivity extends AppCompatActivity &#123; /** * 通用的ToolBar标题 */ private TextView commonTitleTv; /** * 通用的ToolBar */ private Toolbar commonTitleTb; /** * 内容区域 */ private RelativeLayout content; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_base); initView(); setSupportActionBar(commonTitleTb); getSupportActionBar().setDisplayShowTitleEnabled(false); &#125; private void initView() &#123; commonTitleTv = (TextView) findViewById(R.id.common_title_tv); commonTitleTb = (Toolbar) findViewById(R.id.common_title_tb); content = (RelativeLayout) findViewById(R.id.content); &#125; /** * 子类调用，重新设置Toolbar * * @param layout */ public void setToolBar(int layout) &#123; hidetoolBar(); commonTitleTb = (Toolbar) content.findViewById(layout); setSupportActionBar(commonTitleTb); //设置actionBar的标题是否显示，对应ActionBar.DISPLAY_SHOW_TITLE。 getSupportActionBar().setDisplayShowTitleEnabled(false); &#125; /** * 隐藏ToolBar，通过setToolBar重新定制ToolBar */ public void hidetoolBar() &#123; commonTitleTb.setVisibility(View.GONE); &#125; /** * menu的点击事件 * * @param onclick */ public void setToolBarMenuOnclick(Toolbar.OnMenuItemClickListener onclick) &#123; commonTitleTb.setOnMenuItemClickListener(onclick); &#125; /** * 设置左上角back按钮 */ public void setBackArrow() &#123; final Drawable upArrow = getResources().getDrawable(R.drawable.common_back_ic); //给ToolBar设置左侧的图标 getSupportActionBar().setHomeAsUpIndicator(upArrow); // 给左上角图标的左边加上一个返回的图标 。对应ActionBar.DISPLAY_HOME_AS_UP getSupportActionBar().setDisplayHomeAsUpEnabled(true); //设置返回按钮的点击事件 commonTitleTb.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; finish(); &#125; &#125;); &#125; /** * 设置toolbar下面内容区域的内容 * * @param layoutId */ public void setContentLayout(int layoutId) &#123; LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE); View contentView = inflater.inflate(layoutId, null); ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); content.addView(contentView, params); &#125; /** * 设置标题 * * @param title */ public void setTitle(String title) &#123; if (!TextUtils.isEmpty(title)) &#123; commonTitleTv.setText(title); &#125; &#125; /** * 设置标题 * * @param resId */ public void setTitle(int resId) &#123; commonTitleTv.setText(resId); &#125;&#125; 比如你想在上面gif图的EventBusActivity的Activity使用，并且实现menu点击事件、返回按钮、设置标题等操作，只需要下面很简单的代码就可以了： 再来看看子Activity：12345678@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentLayout(R.layout.activity_event_bus);//设置到BaseActivity中的content中 setTitle(&quot;EventBus使用&quot;);//设置标题 setBackArrow();//设置返回按钮和点击事件 setToolBarMenuOnclick(new EventBusMenuItemClick());//设置menu菜单的显示和点击事件 &#125; 各位看官感兴趣的话，欢迎去看看，这里是地址，有什么可以修改的，欢迎提出宝贵意见！","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/smartsean/smartsean.github.io/categories/工具/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://github.com/smartsean/smartsean.github.io/categories/工具/"}]},{"title":"EventBus3.0实用教程","slug":"EventBus3-0实用教程","date":"2017-03-02T10:54:02.000Z","updated":"2018-01-15T14:17:59.399Z","comments":true,"path":"2017/03/02/EventBus3-0实用教程/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/03/02/EventBus3-0实用教程/","excerpt":"作为一个Android开发者，我们在日常的开发中肯定会使用到EventBus，比如说当我们在做app的消息模块的时候，接收到后台推送的消息之后，为了方便用户查看，就需要把消息保存到本地，正常情况下在页面上会有个badge显示消息数量，如果我们不在badge显示界面的话，就需要在接收到后台推送之后更新badge上显示的消息数量，这个时候就可以使用EventBus发出一个事件，这样订阅者接收到事件之后，就会从数据库拿未读消息数，显示在badge上面。说了这么多，下面就简单的介绍下EventBus的使用： EventBus地址：GitHub","text":"作为一个Android开发者，我们在日常的开发中肯定会使用到EventBus，比如说当我们在做app的消息模块的时候，接收到后台推送的消息之后，为了方便用户查看，就需要把消息保存到本地，正常情况下在页面上会有个badge显示消息数量，如果我们不在badge显示界面的话，就需要在接收到后台推送之后更新badge上显示的消息数量，这个时候就可以使用EventBus发出一个事件，这样订阅者接收到事件之后，就会从数据库拿未读消息数，显示在badge上面。说了这么多，下面就简单的介绍下EventBus的使用： EventBus地址：GitHub 一、EventBus 介绍ventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。这个消息总线主要有三个部分： 事件（Event） 事件订阅者（Subscriber）（有没有想到RxJava里面的订阅者 ==。） 事件发布者（Publisher） 官方的关系图： 特征叙述： 简化组件间的通信 事件发送者和接收者解耦 在活动、片段和后台线程中执行良好 避免了复杂、易出错的依赖关系和生命周期问题 使你的代码更加简单 快！ 小！（大约50K） 在100,000,000+个程序上使用 先进特征，比如指定线程、设置优先级等 二、使用EventBus仅需四步1. 添加依赖使用Gradle：1compile 'org.greenrobot:eventbus:3.0.0' 或者Maven：12345&lt;dependency&gt; &lt;groupId&gt;org.greenrobot&lt;/groupId&gt; &lt;artifactId&gt;eventbus&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; 又或者下载Jar包添加到项目中jar包下载 2. 定义事件（Event）12public class TestMsg &#123;&#125; 这个TestMsg由从事件发布者发出，到事件订阅者接收，当然也可以加上额外的信息，比如下面可以传递name： 1234567891011public class TestMsg &#123; private String name; public TestMsg(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 3. 定义事件接收者（Subscriber）首先在所属的Activity的onCreate()里面注册123456@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_my_lib); EventBus.getDefault().register(this);&#125; 在onDestory里面取消注册12345@Override protected void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this); &#125; 然后定义处理事件：1234567@Subscribe(threadMode = ThreadMode.MAIN) public void onEventMainThread(TestMsg testMsg) &#123; if (testMsg != null) &#123; Log.d(\"MainActivity\", \"你收到的名字为： \"+testMsg.getName()); &#125; &#125; 这里的定义了事件接收者以及使用注解@Subscribe(threadMode = ThreadMode.MAIN)指定了执行的线程。ThreadMode有下面四种类型： MAIN UI主线程 POSTING 默认调用方式，在调用post方法的线程执行，避免了线程切换，性能开销最少 BACKGROUND 如果调用post方法的线程不是主线程，则直接在该线程执行。如果是主线程，则切换到后台单例线程，多个方法公用同个后台线程，按顺序执行，避免耗时操作 ASYNC 开辟新独立线程，用来执行耗时操作，例如网络访问。 当然这里可以在注解里面设置优先级，比如下面设置优先级为100，越大就越线先接收到事件：1234567@Subscribe(threadMode = ThreadMode.POSTING,priority = 100) public void onEventMainThread(TestMsg testMsg) &#123; if (testMsg != null) &#123; Log.d(\"MainActivity\", \"你收到的名字为： \"+testMsg.getName()); &#125; &#125; 如果你有三个接收事件，并且设置了不同的优先级，比如100、50、10,你也可以在priority = 100的接收到之后取消事件的传递，那么priority = 50和10的就不会接收到事件了。但是请注意，只能在ThreadMode.PostThread类型的才能取消，其他的三种ThreadMode类型是不能取消的。 如何设置： 1EventBus.getDefault().cancelEventDelivery(event) ; 4.定义事件发布者（Publisher）发出事件123456sendMessage.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; EventBus.getDefault().post(new TestMsg(\"测试EventBus\")); &#125; &#125;); 我写了一个小Demo，这个Demo是我在主module，也就是在app下面定义了事件接收者，在主app依赖的module下面发出事件来测试的。结果是可行的。有兴趣的小伙伴可以去看下： Demo地址","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"fastjson使用","slug":"fastjson使用入门","date":"2017-02-28T07:16:23.000Z","updated":"2018-01-16T03:10:08.599Z","comments":true,"path":"2017/02/28/fastjson使用入门/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/02/28/fastjson使用入门/","excerpt":"","text":"做客户端开发要经常的和服务端进行交互，现在基本上都是使用json进行交互的，所以对于json的生成和解析变得尤为重要，下面对自己日常工作中使用json的进行一个记录如下,以便一些刚学习的小伙伴参考和自己以后翻阅。 一、首先我们需要先添加fastjson的依赖：1compile &apos;com.alibaba:fastjson:1.2.24&apos; 二、使用fastjson来”制造”json请求数据 我们在日常和服务器交互的时候，经常是通过json字符串进行的，首先就先演示下如何造出下面的json字符串：123456789&#123; &quot;cmd&quot;:&quot;myApp/app/userCenter/queryFriend&quot;, &quot;userToken&quot;:&quot;bfcb38b5bcbf463af031a1e7b9d284af&quot;, &quot;parameters&quot;: &#123; &quot;friend&quot;:&quot;myGirlFriends&quot; &#125;&#125; 初步通过下面的代码实现：12345678//parametersMap用来生成parametersMap&lt;String, String&gt; parametersMap = new HashMap&lt;&gt;();parametersMap.put(&quot;friend&quot;, &quot;myGirlFriends&quot;);//upMap用来生成最终的上传数据Map&lt;String, Object&gt; upMap = new HashMap&lt;&gt;();upMap.put(&quot;cmd&quot;, &quot;myApp/app/userCenter/queryFriend&quot;);upMap.put(&quot;userToken&quot;, &quot;fc8b87f32bbdd8200de192350fd133cc&quot;);upMap.put(&quot;parameters&quot;, parametersMap); 这个时候的数据是这样的：1234567&#123; cmd=myApp/app/userCenter/queryFriend, userToken=fc8b87f32bbdd8200de192350fd133cc, parameters=&#123; friend=myGirlFriends &#125;&#125; 上面只是生成了一组map对象，我们和服务器交互是通过json字符串进行的，请看下面代码：12//JSON包名为：import com.alibaba.fastjson.JSON;String upParams = JSON.JSON.toJSONString(upMap); 这个时候upParams的结构就是我们想要的结构了1234567&#123; &quot;cmd&quot;: &quot;myApp/app/userCenter/queryFriend&quot;, &quot;userToken&quot;: &quot;fc8b87f32bbdd8200de192350fd133cc&quot;, &quot;parameters&quot;: &#123; &quot;friend&quot;: &quot;myGirlFriends&quot; &#125;&#125; upParams可以用来发送请求了。通过上面的例子，基本可以满足和服务器交互的请求格式，格式复杂点话，可能会有多层嵌套，只用使用Map来制造嵌套，最后使用fastjson进行转换就好了。 三、解析json字符串相关的操作比如现在有一个json字符串需要我们解析，如下：123456789101112131415161718&#123; &quot;name&quot;: &quot;sean&quot;, &quot;id&quot;: &quot;1&quot;, &quot;joined&quot;: [ &#123; &quot;joinName&quot;: &quot;joined1&quot;, &quot;joinId&quot;: &quot;10&quot; &#125;, &#123; &quot;joinName&quot;: &quot;joined2&quot;, &quot;joinId&quot;: &quot;11&quot; &#125;, &#123; &quot;joinName&quot;: &quot;joined3&quot;, &quot;joinId&quot;: &quot;12&quot; &#125; ]&#125; 获得这个json对象 只需要一行代码即可完成： 123//string：json字符串//jsonObject：生成的json对象JSONObject jsonObject = JSON.parseObject(string); 1. 获取json对象中的一个元素的值：12string name = jsonObject.getString(&quot;name&quot;);Log.d(&quot;name= &quot;+name); 得到的值为name= sean 2. 获取json对象中的一个数组一行代码： 123456789101112131415161718//jsonObject：json对象//joined：json对象中的一个字段，里面保存的是一个json数组。JSONArray joinedArray = jsonObject .getJSONArray(&quot;joined&quot;);此时，joinedArray 中的值为： [ &#123; &quot;joinName&quot;: &quot;joined1&quot;, &quot;joinId&quot;: &quot;10&quot; &#125;, &#123; &quot;joinName&quot;: &quot;joined2&quot;, &quot;joinId&quot;: &quot;11&quot; &#125;, &#123; &quot;joinName&quot;: &quot;joined3&quot;, &quot;joinId&quot;: &quot;12&quot; &#125;] 遍历该数组：12345for (int i = 0; i &lt; joinedArray.size(); i++) &#123; JSONObject obj = joinedArray.getJSONObject(i); Log.d(&quot;id= &quot;+obj.getJoinId); Log.d(&quot;name= &quot;+obj.getJoinName);&#125; 此时打印数据：123456id= 10name= joined1id= 11name= joined2id= 12name= joined3 以上是个人总结，有什么不对的地方欢迎指出、交流。","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Ionic1集成二维码扫描","slug":"Ionic1集成二维码扫描","date":"2017-01-23T08:16:14.000Z","updated":"2018-02-02T06:15:00.975Z","comments":true,"path":"2017/01/23/Ionic1集成二维码扫描/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/01/23/Ionic1集成二维码扫描/","excerpt":"","text":"公司的有一个项目是使用ionic开发的，最近客户提出了一个新功能：二维码扫描。我瞬间懵逼了，在原生上面实现二维码扫描是一件很容易的事情，但是自己从来没有在ionic上面使用二维码扫描，但是也没办法，默默地google，最后发现也不是那么的难，只是界面实现出来丑了点。 1、环境配置首先需要配置jdk、sdk、cordova、node、ionic的环境变量，使用该插件还需要使用phongGap，我使用的是5.1.1版本的phoneGap（和cordova一样，自我觉得一样比较好），配置phoneGap： 1npm install -g phoneGap@5.1.1 如果你不想指定版本的话，后面的@5.1.1可以不加。 2、安装插件1phonegap plugin add phonegap-plugin-barcodescanner 3、调用插件123456789101112131415161718192021222324252627$scope.scan = function (dispatchId) &#123; cordova.plugins.barcodeScanner.scan( function (result) &#123; if (result.wasCancelled) &#123; popup.loadMsg(&quot;返回按钮回到这个页面&quot;); &#125; alert(&quot;We got a barcode\\n&quot; + &quot;Result: &quot; + result.text + &quot;\\n&quot; + &quot;Format: &quot; + result.format + &quot;\\n&quot; + &quot;Cancelled: &quot; + result.cancelled); &#125;, function (error) &#123; alert(&quot;Scanning failed: &quot; + error); &#125;, &#123; preferFrontCamera: false, // iOS and Android showFlipCameraButton: false, // iOS and Android showTorchButton: true, // iOS and Android 显示开起手电筒的按钮 torchOn: false, // Android, launch with the torch switched on (if available) 默认开启手电筒 prompt: &quot;请将二维码放在扫描框中&quot;, // Android 提示信息 resultDisplayDuration: 500, // Android, display scanned text for X ms. 0 suppresses it entirely, default 1500 多久开始识别 formats: &quot;QR_CODE,PDF_417&quot;, // default: all but PDF_417 and RSS_EXPANDED orientation: &quot;portrait&quot;, // Android only (portrait|landscape), default unset so it rotates with the device 垂直还是水平 // disableAnimations : true // iOS &#125; ); &#125; 4、在index.html中引入js文件。123&lt;script src=&quot;lib/ngCordova/dist/ng-cordova.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;lib/ngCordova/dist/ng-cordova-mocks.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;cordova.js&quot;&gt;&lt;/script&gt; 特此记录！","categories":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Ionic/"}],"tags":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Ionic/"}],"keywords":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Ionic/"}]},{"title":"Ionic1 cordova环境问题","slug":"Ionic1-cordova环境问题","date":"2017-01-23T08:16:05.000Z","updated":"2018-02-02T06:15:00.976Z","comments":true,"path":"2017/01/23/Ionic1-cordova环境问题/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2017/01/23/Ionic1-cordova环境问题/","excerpt":"","text":"前几天把电脑重新装了系统，然后老老实实的把所有该配置的环境都配置好了。去运行ionic1项目的时候，发现出现了ionic platform add android总是出错，导致我无法继续开发这个项目，可以使用ionic serve命令在网页端来开发的，但是有的功能毕竟不是网页可以模拟的，然后各种google,昨晚弄到一点多也是没调好，今天偶尔在网上看到重新把cordova、ionic卸载，然后再安装一下就可以，自己试了试，还真的可以，现在把具体的方法给大家说下： 原来的环境：1234jdk -v :1.8ionic -v : 1.7.15node -v :5.4.1cordova-v: 5.4.1 执行以下操作： 重新安装node 执行以下命令 1234567npm install -g npmnpm uninstall -g cordovanpm uninstall -g phonegapnpm uninstall -g ionicnpm cache cleannpm install -g ionic@1.7.15npm install -g cordova@5.1.1 安装好的环境： 1234jdk -v :1.8ionic -v : 1.7.15node -v :4.4.4cordova-v: 5.1.1 可以看到，罪魁祸首还是那个nodejs的版本，这个时候再去执行：ionic platform add android和ionic run android的时候就可以顺利进行了。 特此记录开发ionic1遇到的深坑。。。","categories":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Ionic/"}],"tags":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Ionic/"}],"keywords":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Ionic/"}]},{"title":" Android6.0运行时权限处理","slug":"Android6-0运行时权限处理","date":"2016-12-15T08:03:59.000Z","updated":"2018-01-16T03:08:16.292Z","comments":true,"path":"2016/12/15/Android6-0运行时权限处理/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/12/15/Android6-0运行时权限处理/","excerpt":"","text":"前言在Android6.0版本以前，往往是应用程序需要什么权限直接在manifest.xml中直接声明，当你安装程序的时候，如果不想让该程序使用某种权限，唯一的办法只能是不装这个应用，但是我们生活中离不开应用，只能是默默的接受无耻的权限要求，比如一个聊天软件要获取你的短信、彩信等权限，明明就是明抢，我们平时又使用不到这些权限，Google也考虑到了这个问题，所以在Android6.0之后加入了运行时权限，把权限分为危险权限和普通权限。 普通权限不会直接威胁到用户的安全和隐私的权限 危险权限可能会触及用户的隐私、或者对用户的设备安全性造成影响的权限，危险权限总共有9组24个权限 Demo：模拟直接拨打电话 首先在Manifest.xml中添加拨打电话权限 12&lt;!--拨打电话权限--&gt;&lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;&gt;&lt;/uses-permission&gt; 在main_activity.xml文件中添加布局文件如下： 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;com.sean.css.runtimepermissiontest.MainActivity&quot;&gt; &lt;Button android:id=&quot;@+id/make_call&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;拨打10080&quot; /&gt;&lt;/RelativeLayout&gt; 在MainActivity.xml文件中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.sean.css.runtimepermissiontest;import android.Manifest;import android.content.Intent;import android.content.pm.PackageManager;import android.net.Uri;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.make_call); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //判断是否已经获得了拨打电话权限 if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) &#123; //没有获得拨打电话权限就去请求获得该权限，第一个参数是上下文对象，第二个参数是权限名称，第三个参数是请求码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.CALL_PHONE&#125;, 1); &#125; else &#123; call(); &#125; &#125; &#125;); &#125; private void call() &#123; try &#123; Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse(&quot;tel:10086&quot;)); startActivity(intent); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; &#125; /** * 申请权限回调 * * @param requestCode * @param permissions * @param grantResults */ @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case 1: //如果是返回的请求码是1，知道是申请拨打电话权限的回调。 //授权的结果在grantResults中，如果长度大于0并且里面的值表示以获取该权限，就直接拨打电话 //否则跳出提示，告诉用户为什么需要该权限，让用户自己开启权限 if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; call(); &#125; else &#123; Toast.makeText(this, &quot;你需要允许拨打电话权限才能进行下面的操作&quot;, Toast.LENGTH_SHORT).show(); &#125; break; &#125; &#125;&#125; 当我们申请运行时权限的时候，是不是有点似曾相识的感觉呢？我们在使用开启新的Activity并且需要新的Activity返回给我们值的时候，和申请权限的是相似的，这样就好理解多了。 其他现在的开源项目有很多已经帮我们封装好了申请运行时权限，我们可以直接拿来用，比如easypermissions等，不过还是要知道其中的原理比较好。 Android6.0的运行时权限处理，特此记录。","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":" 解决魅族手机不能Toast提示的方法","slug":"解决魅族手机不能Toast提示的方法","date":"2016-12-14T04:35:01.000Z","updated":"2018-01-16T02:45:37.840Z","comments":true,"path":"2016/12/14/解决魅族手机不能Toast提示的方法/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/12/14/解决魅族手机不能Toast提示的方法/","excerpt":"","text":"前言自己是做Android开发的，最近抛弃了iphone，自己也入手了一个魅族手机（MX6），但是在运行自己开发的应用时彻底懵逼了，Toast提示竟然不会出现，回去看了看代码，没问题啊，也是网上说的自己写的Toast，并不是原生的Toast，但是还是不能提示，感觉蛋疼无比，网上一顿搜索之后终于在 这里发现了问题所在。 解决方案 首先在应用里面添加通知窗权限12&lt;!-- 悬浮框权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt; 2.在手机管家——&gt;权限管理——&gt;通知管理——&gt;找到自己的应用——&gt;开启悬浮窗权限。 经过上面的两步总算是可以显示Toast了，真是搞不懂，为啥要把Toast合并到悬浮窗里面。 这里记录下坑爹的魅族手机bug（我的是mx6的5.2.4.1版本，不知道其他机型有没有这个问题），已经在魅族社区提了这个bug，希望魅族早点处理。","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"ToolBar学习笔记(一)","slug":"ToolBar学习笔记-一","date":"2016-12-07T08:40:56.000Z","updated":"2018-01-16T02:45:05.887Z","comments":true,"path":"2016/12/07/ToolBar学习笔记-一/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/12/07/ToolBar学习笔记-一/","excerpt":"","text":"现在项目中一般都会使用标题栏，谷歌在2014年推出了新的app bar—ToolBar，代替了以前使用的ActionBar。在做项目中会经常用到这个ToolBar，虽然用的很多，但是自己对它如何用还不是很明白，今天就来简单的学习下这个控件的使用。 效果图 1. 修改app的style我们如果要使用ToolBar，需要先把原来的ActionBar隐藏起来，就先要设置App的主题为Theme.AppCompat.Light.NoActionBar这种主题，就需要在values/style.xml里面修改Apptheme的Parent或者parent的parent为Theme.AppCompat.Light.NoActionBar，这样的话才能使用ToolBar得到我们想要的效果。 2. 在布局中使用ToolBar达到效果图1.标题首先在布局文件activity_main.xml中：12345678910111213141516&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; android:background=&quot;#ffffff&quot; android:gravity=&quot;center&quot; app:titleTextColor=&quot;#1d1d1d&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:text=&quot;工作&quot; android:textColor=&quot;#1d1d1d&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;/android.support.v7.widget.Toolbar&gt; 需要说明的是，ToolBar其实也是一个ViewGroup，他的布局和LinearLayout类似，所以在使用的过程中，可以使用android:layout_gravity=&quot;center&quot;来让TextView居中显示 这个时候的标题栏是这样的： 2. 右侧按钮标题栏已经居中显示了，但是我们可能还需要在右侧需要一个按钮来进行一定的操作，比如下面的按钮操作 这个怎么实现呢，看下面的代码： 第一种实现123456789101112131415161718192021222324252627282930313233343536 &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; android:background=&quot;#ffffff&quot; android:gravity=&quot;center&quot; app:titleTextColor=&quot;#1d1d1d&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:layout_gravity=&quot;center&quot; android:text=&quot;工作&quot; android:textColor=&quot;#1d1d1d&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_marginRight=&quot;12dp&quot; android:text=&quot;按钮&quot; android:textColor=&quot;#1d1d1d&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;/RelativeLayout&gt; &lt;/android.support.v7.widget.Toolbar&gt;``` &gt; 这里在ToolBar的自定义区放入了一个RelativeLayout，在RelativeLayout里面放置了一个标题和右侧的按钮，右侧的按钮是可以随意定制的，#### 第二种实现我们可以利用菜单选项menu来实现这种效果，1. 首先在res目录下新建menu文件夹，在该文件夹下面建立menu.main.xml，代码如下： 12. 在`MainActivity.java`中重写`onCreateOptionsMenu`方法如下所示： @Override public boolean onCreateOptionsMenu(Menu menu) { // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return true; }1234### 3. 左侧的返回箭头首先，你得先准备一个返回箭头的图标，然后以下两种都行，都可以实现显示小箭头，并且点击小箭头返回#### 第一种方案 //设置小箭头 toolbar.setNavigationIcon(R.drawable.common_back_ic); //设置小箭头点击事件 toolbar.setNavigationOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { finish(); } });123456这种方案是只能在当前的Activity中使用，达不到复用的目的。#### 第二种方案在日常的开发中，通常我们会写一个基类，让所有的Activity都继承于这个基类，便于统一管理和减少代码量。所以我们可以在改基类（比如：`BaseActivity.java`）中写入以下方法： /** * 设置左上角back按钮 */ public void setBackArrow() { final Drawable upArrow = getResources().getDrawable(R.drawable.common_back_ic); getSupportActionBar().setHomeAsUpIndicator(upArrow); getSupportActionBar().setDisplayHomeAsUpEnabled(true); getSupportActionBar().setDisplayShowHomeEnabled(true); } /** * 点击左上角的返回按钮，结束本Activity * home就是左上角的小箭头，在toolbar上 * * @param item * @return */ @Override public boolean onOptionsItemSelected(MenuItem item) { if (item.getItemId() == android.R.id.home) { basefinish(); return true; } return super.onOptionsItemSelected(item); } /** * 抽象方法，用于结束activity */ public abstract void basefinish(); @Override public void onBackPressed() { basefinish(); } ``` 这样的话，我们在的其他Activity只要继承于这个BaseActivity，就需要实现抽象方法，抽象方法会实现返回操作，我们每次只用调用 setBackArrow()这个方法就可以很方便的实现返回小箭头的功能了。简直不能更方便啦！ 到此就实现了ToolBar的基本使用，建立了自己的一个标题栏，效果和上面是一样的： 特此记录！","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"四步教你理解回调","slug":"四步教你理解回调","date":"2016-11-22T14:06:49.000Z","updated":"2018-01-16T02:44:34.531Z","comments":true,"path":"2016/11/22/四步教你理解回调/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/11/22/四步教你理解回调/","excerpt":"","text":"我的简书：简书传送门 我的CSDN：CSDN传送门 我的GitHub：GitHub传送门 前言项目中要用到类似支付宝首页九宫格的显示，主要分为两个部分：第一部分是我的应用；第二部分是全部应用。要实现可以从我的应用中删除已添加的常用应用，也可以从全部应用添加到我的应用中。 本来是想实现可以拖动排序的，但是由于自己的技术功底还不够，就先实现了可以增加和删除的小功能。后来自己使用的是稍微修改过的 GridView 来实现的。 但是在实现的过程中，发现我需要在 GridView 的 item 里面来控制在 Activity 中的和 GridView 同级别的的控件，就在网上搜索，不知道是自己的搜索方法不对，还是本身的内容就比较少，搜索了大半天都没搜索到，于是问了公司的同事，同事说用一个接口来回调就可以了。 需求在 GridView 的 Adapter 里面长按 item 改变 在 Activity 中的控件。 效果演示：如果我长按 GridView 中的 item ，就要改变上方的“编辑”按钮变成“完成”。效果如下： 四步实现1.首先定义一个接口： 123public interface UpdateDataInterface &#123; void setText(String text);&#125; 2.在“编辑”控件所在的Activity或者Frafment中实现该接口如下： 1234567891011/** * 实现在adapter内部更改主页按钮 * workManageTv就是显示\"编辑\"和\"完成\"的TextView */ class UpdateTextImp implements UpdateDataInterface &#123; @Override public void setText(String text) &#123; workManageTv.setText(text); &#125; &#125; 3.然后在实例化适配器对象的时候把这个接口传递进去： 12// WorkMyAppAdapter就是适配器workMyAppAdapter = new WorkMyAppAdapter(context, new UpdateTextImp(), false); 4.在适配器里面定义该接口，在构造方法中接收该接口，并直接拿来用，调用接口中的方法即可 12345678910111213141516// 定义用于回调的类private UpdateDataInterface updateDataInterface;// 构造方法，接收 UpdateDataInterface public WorkMyAppAdapter(UpdateDataInterface updateDataInterface)&#123; this.updateDataInterface = updateDataInterface;&#125;// 调用public void changeStatus()&#123; if (isEdit) &#123; updateDataInterface.setText(&quot;完成&quot;); &#125; else &#123; updateDataInterface.setText(&quot;编辑&quot;); &#125;&#125; 以前自己总是不太清楚回调的实现，但是模模糊糊的会用上一点，今天到自己真正需要的时候，自己一步步的去实现，才真正懂了回调的用法。 特此记录！","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android 修改密码或者手机号事务实现","slug":"Android-修改密码或者手机号事务实现","date":"2016-11-20T11:18:39.000Z","updated":"2018-01-16T02:44:07.787Z","comments":true,"path":"2016/11/20/Android-修改密码或者手机号事务实现/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/11/20/Android-修改密码或者手机号事务实现/","excerpt":"","text":"前言在开发中我们经常会遇到以下情况，比如以下场景：在修改密码的时候，要执行以下步骤： 1. 输入手机号获取验证码 2. 输入验证码 3. 输入新密码 1. 第一种情况可以把修改密码这三个步骤看成是一个事务，任何一个环节中断都要重新回到第一个步骤再次执行。这就需要我们在每一步执行完之后执行所在Activity的Finish（）方法，结束这个步骤，当最后一步返回的时候，就会重新回到修改密码按钮界面了，这个时候点击修改密码还是从输入手机号获取验证码开始。 2. 第二种情况当然了，有的需求比较不正常，他需要在这三个步骤之间还没结束的时候可以返回上一个步骤，当新密码输入完毕，点击提交的时候，就不能回到上一步骤，而是回到有修改密码的页面，这个时候我们就不能直接在前两个步骤结束的时候调用finish()方法了，而是在第三个步骤执行完之后结束这个三个步骤的活动（Activity）。 实现：假设三个步骤依次是ActivityA,ActivityB,ActivityC,那么需要在ActivityA：1public static ActivityA instance = null; 在ActivityA的onCreate方法中：1instance = ActivityA.this; 同理，在ActivityB中也要设置：1public static ActivityB instance = null; 在ActivityB的onCreate方法中：1instance = ActivityB.this; 那么在ActivityC的操作执行完之后，可以直接调用以下方法结束这三个活动（Activity）：123456//结束第一步的ActivityA ActivityA.instance.finish(); //结束第二步的ActivityB ActivityB.instance.finish(); //结束本身ActivityC finish(); 大致的两种情况已经介绍完了，大家在自己的项目中灵活应用哦！ 特此记录！","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":" Android 主界面多个Tab栏的实现","slug":"Android-主界面多个Tab栏的实现","date":"2016-11-20T10:52:32.000Z","updated":"2018-01-16T02:43:44.514Z","comments":true,"path":"2016/11/20/Android-主界面多个Tab栏的实现/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/11/20/Android-主界面多个Tab栏的实现/","excerpt":"","text":"前言现在比较流行的就是类似qq或者微信上的布局，都是在底部都几个Tab栏，点击不同的Tab栏可以切换不同的页面，大概的实现原理就是使用RadioGroup包裹几个RadioButton来实现的，而不同的页面展示则是放置一个FrameLayout来实现的。 效果图： 1.代码布局：顶部设置了标题，使用的是现在都在用的toolBar，可以在切换不同页面的时候设置不同的标题。然后下面放了一个Radiogroup，里面包裹了四个RadioButton实现不同页面的切换。里面的View控件是设置的水平的分割线，使页面好看点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.Toolbar xmlns:toolbar=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/index_title_tb&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; android:background=&quot;@color/colorPrimaryDark&quot; toolbar:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; toolbar:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt; &lt;TextView android:id=&quot;@+id/index_title_tv&quot; style=&quot;@style/title_text_style&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:textColor=&quot;@color/white&quot; android:text=&quot;我是标题&quot;/&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;View android:id=&quot;@+id/index_title_divider&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1dp&quot; android:layout_below=&quot;@id/index_title_tb&quot; android:background=&quot;@drawable/common_horizontal_divider&quot;/&gt; &lt;RadioGroup android:id=&quot;@+id/index_bottom_navigation_rg&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;44dp&quot; android:layout_alignParentBottom=&quot;true&quot; android:background=&quot;@color/white&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;RadioButton android:id=&quot;@+id/index_tab_a_rb&quot; style=&quot;@style/Index_tab_style&quot; android:drawableTop=&quot;@drawable/index_equipment_tab_sel&quot; android:text=&quot;@string/index_tab_equipment&quot;/&gt; &lt;RadioButton android:id=&quot;@+id/index_tab_b_rb&quot; style=&quot;@style/Index_tab_style&quot; android:drawableTop=&quot;@drawable/index_bill_tab_sel&quot; android:text=&quot;@string/index_tab_bill&quot;/&gt; &lt;RadioButton android:id=&quot;@+id/index_tab_c_rb&quot; style=&quot;@style/Index_tab_style&quot; android:drawableTop=&quot;@drawable/index_contract_tab_sel&quot; android:text=&quot;@string/index_tab_contract&quot;/&gt; &lt;RadioButton android:id=&quot;@+id/index_tab_d_rb&quot; style=&quot;@style/Index_tab_style&quot; android:drawableTop=&quot;@drawable/index_setting_tab_sel&quot; android:text=&quot;@string/index_tab_setting&quot;/&gt; &lt;/RadioGroup&gt; &lt;View android:id=&quot;@+id/index_bottom_divider&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1dp&quot; android:layout_above=&quot;@id/index_bottom_navigation_rg&quot; android:background=&quot;@drawable/common_horizontal_divider&quot;/&gt; &lt;FrameLayout android:id=&quot;@+id/index_content_fl&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_above=&quot;@id/index_bottom_divider&quot; android:layout_below=&quot;@id/index_title_divider&quot; android:background=&quot;@color/white&quot;/&gt;&lt;/RelativeLayout&gt; 2.Java代码控制不同页面切换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199package com.css.demo;import android.content.Context;import android.os.Bundle;import android.support.v4.app.FragmentTransaction;import android.widget.CompoundButton;import android.widget.RadioButton;import android.widget.TextView;import com.css.demo.ui.index.TabA;import com.css.demo.ui.index.TabB;import com.css.demo.ui.index.TabC;import com.css.demo.ui.index.TabD;import com.css.demo.utils.L;import butterknife.Bind;import butterknife.ButterKnife;/** * Created by cssch on 2016/10/11. */public class IndexActivity extends BaseIndexActivity &#123; @Bind(R.id.index_tab_a_rb)//第一页tab按钮 RadioButton indexTabARb; @Bind(R.id.index_tab_b_rb)//第二页tab按钮 RadioButton indexTabBRb; @Bind(R.id.index_tab_c_rb)//第三页tab按钮 RadioButton indexTabCRb; @Bind(R.id.index_tab_d_rb)//第四页tab按钮 RadioButton indexTabDRb; @Bind(R.id.index_title_tv)//标题 TextView indexTitleTv; private static final int TABA = 1;//第一页标记 private static final int TABB = 2;//第二页标记 private static final int TABC = 3;//第三页标记 private static final int TABD = 4;//第四页标记 //这里的是四个Fragment的说明 private TabA tabA;//第一页 private TabB tabB;//第二页 private TabC tabC;//第三页 private TabD tabD;//第四页 private Context context; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); L.d(&quot;myname&quot;.toString()); setContentView(R.layout.index); ButterKnife.bind(this); context = IndexActivity.this; //设置四个Tab栏的监听 indexTabARb.setOnCheckedChangeListener(new OnNaviCheckChangeListener(TABA)); indexTabBRb.setOnCheckedChangeListener(new OnNaviCheckChangeListener(TABB)); indexTabCRb.setOnCheckedChangeListener(new OnNaviCheckChangeListener(TABC)); indexTabDRb.setOnCheckedChangeListener(new OnNaviCheckChangeListener(TABD)); //设置默认的显示页面为b页面 indexTabBRb.setChecked(true); &#125; /** * 监听事件的实现 */ class OnNaviCheckChangeListener implements CompoundButton.OnCheckedChangeListener &#123; private int position; public OnNaviCheckChangeListener(int position) &#123; this.position = position; &#125; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; if (isChecked) &#123; changeTab(position); &#125; &#125; &#125; /** * @param position 切换tab */ public void changeTab(int position) &#123; FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); hideFragments(transaction); switch (position) &#123; case TABA: changeToTabA(transaction); break; case TABB: changeToTabB(transaction); break; case TABC: changeToTabC(transaction); break; case TABD: changeToTabD(transaction); break; default: changeToTabA(transaction); break; &#125; transaction.commitAllowingStateLoss(); &#125; /** * 跳转到tabA * * @param transaction */ private void changeToTabA(FragmentTransaction transaction) &#123; indexTitleTv.setText(&quot;TabA页面&quot;); if (tabA == null) &#123; tabA = new TabA(); transaction.add(R.id.index_content_fl, tabA); &#125; else &#123; transaction.show(tabA); &#125; &#125; /** * 跳转到tabB * * @param transaction */ private void changeToTabB(FragmentTransaction transaction) &#123; indexTitleTv.setText(&quot;TabB页面&quot;); if (tabB == null) &#123; tabB = new TabB(); transaction.add(R.id.index_content_fl, tabB); &#125; else &#123; transaction.show(tabB); &#125; &#125; /** * 跳转到tabC * * @param transaction */ private void changeToTabC(FragmentTransaction transaction) &#123; indexTitleTv.setText(&quot;TabC页面&quot;); if (tabC == null) &#123; tabC = new TabC(); transaction.add(R.id.index_content_fl, tabC); &#125; else &#123; transaction.show(tabC); &#125; &#125; /** * 跳转到tabD * * @param transaction */ private void changeToTabD(FragmentTransaction transaction) &#123; indexTitleTv.setText(&quot;TabD页面&quot;); if (tabD == null) &#123; tabD = new TabD(); transaction.add(R.id.index_content_fl, tabD); &#125; else &#123; transaction.show(tabD); &#125; &#125; /** * @param transaction 隐藏所有fragment */ private void hideFragments(FragmentTransaction transaction) &#123; if (tabA != null &amp;&amp; !tabA.isHidden()) &#123; transaction.hide(tabA); &#125; if (tabB != null &amp;&amp; !tabB.isHidden()) &#123; transaction.hide(tabB); &#125; if (tabC != null &amp;&amp; !tabC.isHidden()) &#123; transaction.hide(tabC); &#125; if (tabD != null &amp;&amp; !tabD.isHidden()) &#123; transaction.hide(tabD); &#125; &#125;&#125; 总结总体来说还是挺简单的，当然还可以使用其他的方式进行布局，有兴趣的朋友可以研究下。如果想用这种方式的话，你只用把里面的资源文件改成自己使用的资源文件就可以在自己的项目中使用了。当然，我这个命名还不是很规范，大家可以规范下命名。 特此记录！","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android 使用CheckBox实现好看的开关按钮","slug":"Android-使用CheckBox实现好看的开关按钮","date":"2016-11-20T10:11:24.000Z","updated":"2018-01-16T02:43:14.054Z","comments":true,"path":"2016/11/20/Android-使用CheckBox实现好看的开关按钮/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/11/20/Android-使用CheckBox实现好看的开关按钮/","excerpt":"","text":"近期项目中需要使用到开关按钮，就是有两个选项，实现是否接受新消息的功能，首先想到的就是使用CheckBox，把ui给的图片设置成开关的样式就可以了。 效果展示： 这里使用的是ToggleButton在xml布局文件里面设置如下：123456789101112&lt;ToggleButton android:id=&quot;@+id/account_receive_new_message_explain_label_tb&quot; android:layout_width=&quot;38dp&quot; android:layout_height=&quot;22dp&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginRight=&quot;16dp&quot; android:button=&quot;@drawable/account_message_select&quot; android:checked=&quot;true&quot; android:text=&quot;&quot; android:textOff=&quot;&quot; android:textOn=&quot;&quot; /&gt; 说明1.这里只用把button属性设置成自己定义的文件就行了，我的selector（account_message_select.xml）文件如下：1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!--按下状态的显示图片--&gt; &lt;item android:state_checked=&quot;true&quot; android:drawable=&quot;@drawable/account_message_sel&quot;&gt;&lt;/item&gt; &lt;!--平时状态的显示图片--&gt; &lt;item android:state_checked=&quot;false&quot; android:drawable=&quot;@drawable/account_message_no_sel&quot;&gt;&lt;/item&gt;&lt;/selector&gt; 2.这里是不用显示文字的，所以把Text属性、TextOn属性、TextOff属性都设置为空，就不会有文字显示了。","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android---验证码倒计时的简单实现","slug":"Android-验证码倒计时的简单实现","date":"2016-10-16T10:31:11.000Z","updated":"2018-01-16T02:42:44.499Z","comments":true,"path":"2016/10/16/Android-验证码倒计时的简单实现/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/10/16/Android-验证码倒计时的简单实现/","excerpt":"","text":"前言 现在的很多app都是使用手机注册的，为了确认使用的是自己的手机，都会加上一个短线验证码的选项，最近公司的项目使用到了这个短信验证码，并且要加入验证码倒计时功能，也就是60秒才能发送一次验证码，再次做过记录，以后使用的时候，可以随时拿来用。 实现发送验证码的时候一般都会有一个按钮，点击之后便会给你输入的手机发送一条验证码，我这里使用的是一个TextView，显示特定的数字，只用设置TextView的点击事件即可； Android中有一个类，可以很方便的时候该功能，但是也会存在一个问题，就是在最后一秒的时候，会等待很久才会显示出“重新发送”的文字，这个类是CountDownTimer，有兴趣的朋友可以去研究下，用起来还是挺方便的，不过我后来发现重新开启一个线程来实现是比较完美的。 代码如下： 12345678910111213141516171819202122232425262728293031323334/** * 短信验证码倒计时 */ private void startTimer() &#123; registerVerificationCodeTv.setTextColor(getResources().getColor(R.color.text_color_code_green)); registerVerificationCodeTv.setText(getResources().getString(R.string.timer_default_show)); registerVerificationCodeTv.setEnabled(false); new Thread() &#123; @Override public void run() &#123; for (int i = 59; i &gt;= 0; i--) &#123; final int second = i; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if (second &lt;= 0) &#123; registerVerificationCodeTv.setTextColor(getResources().getColor(R.color.text_get_verification_code)); registerVerificationCodeTv.setText(getResources().getString(R.string.register_re_get_verification_code)); registerVerificationCodeTv.setEnabled(true); &#125; else &#123; registerVerificationCodeTv.setTextColor(getResources().getColor(R.color.text_color_code_green)); registerVerificationCodeTv.setText(second + &quot;s&quot;); &#125; &#125; &#125;); &#125; &#125; &#125;.start(); &#125; 说明： registerVerificationCodeTv就是那个显示倒计时秒数的TextView，用的时候只用在registerVerificationCodeTv的点击事件里面调用此方法就好了。","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"程序员的Windows工具（持续更新）","slug":"程序员的Windows工具（持续更新）","date":"2016-10-16T10:03:07.000Z","updated":"2018-01-15T14:16:41.873Z","comments":true,"path":"2016/10/16/程序员的Windows工具（持续更新）/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/10/16/程序员的Windows工具（持续更新）/","excerpt":"前言 相信一千台电脑就有一千个样子，每个人使用电脑的用途、习惯都是大相径庭的，并没有说谁的是最好用的，只有适合自己的才是最好的，今天我就来分享下我用Windows电脑的一些工具以及习惯：","text":"前言 相信一千台电脑就有一千个样子，每个人使用电脑的用途、习惯都是大相径庭的，并没有说谁的是最好用的，只有适合自己的才是最好的，今天我就来分享下我用Windows电脑的一些工具以及习惯： 效率类: OneNote OneNote是我在大四实习的适合接触到的，当时看到同事同的OneNote，感觉挺好的，当时并没有在意，直到在学校上课的时候，老师用的也是OneNote，看他使用的样子好炫酷啊，于是决定回去之后研究下。安装之后就自己慢慢的摸索，通过知乎等平台不断的学习使用技巧，之后还发现不仅可以在Windows上使用，在手机和ipad上都可以使用，我就可以在工作或者学习的时候在电脑把自己的日常记录、心得、想法记录下来，然后在移动端同步查看，这种特别适用于上班路上时间比较长的人，实习的时候就是住的地方离公司比较远，每天坐车上的一个小时基本都用来看OneNote。现在上班时间短了，也不带电脑上下班，通过OneNote可以实现公司和家里的信息共享。这个是极力推荐的软件，各大平台都有客户端。 有道云笔记 网易出品，必属精品。我主要用来存储一些网上看到的好文章，很多平台都支持一键收藏到有道云笔记，使用起来很方便，还可以存储一些自己的加密信息，上面的普通用户都可以享受到加密文档的服务，感觉很良心，支持网易 滴答清单 滴答清单主要就是用来记录自己的代办事项的，有时候 ，正所谓好记性不如烂笔头，现在我们都随身携带手机，可以把手机当做一个记事本来用，把自己以后要做的事情记录下来，不仅可以随时查看，还可以在设定的时间进行提醒。简直妙哉 Cortana 这个是升级了Windows10之后才开始使用的，个人觉得很好用，不过我使用的场景也就是和滴答清单差不多，只用到了提醒功能，这个在你工作中进行提醒还是很好的，不用随时注意手机，当你设定的事情进行提醒的时候，会在左下角弹窗提醒，很清新，并且最近升级了win10周年版之后界面也变得好看了很多。 XMind win下面的思维导图工具，免费版可以实现我的基本需求。我觉得win下面最好用的思维导图工具。 对于我而言，OneNote+有道云笔记+滴答清单+Cortana可以满足我基本的需求。 小工具类 Lantern 想必很多小伙伴在上网的时候都偶尔会有“世界那么大，我想去看看”的想法，但是受限于国内的网络环境，并不能如愿以偿，这个Lantern是一个免费的科学上网的工具，很好用，上次在mac上用的时候，发现还有收费版，土豪朋友可以去试试传送门 TeamViewer 远程控制电脑的神器，比qq远程靠谱多了。传送门 Listary 文件搜索工具，以前使用的是EvertThing，自从在Zealer上发现这个工具 之后便抛弃了EvertThing，开始使用Listary，正在慢慢学习中。传送门 Launchy win下面快速启动应用的工具，其实大多数都可以通过win10自带的功能实现，但是这个是装逼利器啊有木有，直接给你弹出小框，搜索之后回车打开，开可以加动画，也是刚开始使用，感觉很赞。传送门 程序员工具 Beyond Compare 代码比对工具，相信很多人都喜欢 postman 这个大家应该都知道，api调试用的，后端给的接口能不能用，用这个试一下就知道了，新做好的功能有问题的时候，如果找到不到问题所在，不要一直怀疑你的代码，说不定接口本来就是有问题的。。。 HIJson 这个也算是个神器，AndroidStudio调试看到后端返回的json数据看起来不是很直观，好办，直接复制到HIJson里面，便可以帮你格式化，以更加清晰的数据展示给你 Atom 好用的前端编辑器，以前的sublime很火，很多人都在用，虽说很轻量级，但是自己并不是很喜欢用，知道在慕课网上看老师课程的时候，知道了这个GitHub出品的编辑器，自己也下载了一个，很好用，感觉给人一种很稳重的感觉。 gif录制–LICEcap 可以很方便的录制gif，超级好用，可以调整录制大小，做出小功能之后，可以录制下，写博客也可以方便的上传。 PxCook 像素大厨（需要Adobe air运行环境） 安卓开发必备，ui给你设计之后，你可以用这个工具很方便的进行取色、测量距离等操作，可以在px和dp之间转换，超级 方便，建议大家使用","categories":[{"name":"我","slug":"我","permalink":"https://github.com/smartsean/smartsean.github.io/categories/我/"}],"tags":[{"name":"我","slug":"我","permalink":"https://github.com/smartsean/smartsean.github.io/tags/我/"}],"keywords":[{"name":"我","slug":"我","permalink":"https://github.com/smartsean/smartsean.github.io/categories/我/"}]},{"title":"Android 显示隐藏密码的简单实现","slug":"Android-显示隐藏密码的简单实现","date":"2016-10-15T07:23:26.000Z","updated":"2018-01-16T02:42:13.961Z","comments":true,"path":"2016/10/15/Android-显示隐藏密码的简单实现/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/10/15/Android-显示隐藏密码的简单实现/","excerpt":"","text":"前言 现在的应用中，人性化的设置越来越多，比如在输入密码的界面可以选择是否显示密码，这样当用户在不安全的环境中还可以使用密码不可见的方式填写密码（以**表示），当用户确认所处环境是安全的，并且有需求看自己输入的密码的时候，便可以实时查看自己输入的密码是不是自己想要的。公司最近的新项目便加入了这个需求，自己网上搜了下，简单的实现了该需求。 效果图： 代码实现首先，右侧的小眼睛是我用的是CheckBox，然后给CheckBox设置了图片，当处于选中装填的时候，眼睛是绿色的，否则是灰色的，然后在activity里面设置该CheckBox的监听事件如下： 12345678910111213//判断当前是否需要显示密码private void isPasswordShowListener() &#123; registerShowPasswordCb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; int passwordLength = registerPasswordEt.getText().length(); registerPasswordEt.setInputType(isChecked ? (InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD) : (InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD)); registerPasswordEt.setSelection(passwordLength); &#125; &#125;); &#125; 说明： registerPasswordEt是前面密码输入的EditText registerShowPasswordCb就是那个小眼睛的CheckBox， 用的时候直接改下就可以直接用了。特此记录。","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"【事故】项目开发中的生产事故","slug":"【事故】项目开发中的生产事故","date":"2016-10-14T16:31:11.000Z","updated":"2018-01-16T02:39:52.035Z","comments":true,"path":"2016/10/15/【事故】项目开发中的生产事故/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/10/15/【事故】项目开发中的生产事故/","excerpt":"","text":"缘由本周发生了自己在正式工作以后的一个重大的错误，公司使用的是七牛云存储，app使用过程中上传的图片信息存储在七牛云空间，周二的时候，后端人员删除了一些测试环境上的数据，在晚上的客户就反馈说图片上传功能有故障，公司的架构和后端紧急查看了出现该故障的原因，发现是生产环境的图片传到测试环境来了，由于后端人员删除了一部分数据，导致该故障，但是由于自己不知道这个空间也是分测试环境和生产环境的，所以在打包的时候只是改了整个app的环境，没有改图片上传的环境，导致了这次生产事故。 反思虽说是自己不知道有这个图片上传地址的区别，也没人告诉我，但是归根结底还是由于自己对项目不是很熟悉，对项目的每个细节把握的不是很好，这个项目的app端以后都是我来负责，一定要对整个项目熟悉，这样以后自己维护起来也会方便，如果以后有什么新的需求自己做起来也是比较的得心应手，等现在手头上的项目做完，一定要好好的研究下i5项目，争取不再犯错。","categories":[{"name":"我","slug":"我","permalink":"https://github.com/smartsean/smartsean.github.io/categories/我/"}],"tags":[{"name":"我","slug":"我","permalink":"https://github.com/smartsean/smartsean.github.io/tags/我/"}],"keywords":[{"name":"我","slug":"我","permalink":"https://github.com/smartsean/smartsean.github.io/categories/我/"}]},{"title":"【Android笔记】淡入淡出、上下弹出动画的","slug":"【Android笔记】淡入淡出、上下弹出动画的","date":"2016-09-30T03:34:19.000Z","updated":"2018-01-16T02:38:55.563Z","comments":true,"path":"2016/09/30/【Android笔记】淡入淡出、上下弹出动画的/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/09/30/【Android笔记】淡入淡出、上下弹出动画的/","excerpt":"","text":"今天想到了自己毕业设计时候做的app，里面主页上面的搜索框用到了一个PopupWindow来实现，我就琢磨这在给他加上一个动画，当时真的是什么都不懂，囫囵吞枣的就拿来用了，现在又大概找了两种动画效果来实现，现在记录下。 一、淡入、淡出动画 在res文件下面建立一个叫anim的文件夹。 在anim文件下面建立两个xml文件，分别为： push_bottom_in.xml（淡入效果）123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;alpha android:duration=&quot;200&quot; android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot; /&gt;&lt;/set&gt; - push_bottom_out.xml（淡出效果） 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;alpha android:duration=&quot;200&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.0&quot; /&gt;&lt;/set&gt; 参数解释： - `duration`设置完成动画需要的时间 - `fromAlpha`动画开始时的透明度 - `toAlpha`动画结束时候的透明度 在res文件夹下面的values文件夹下面的styles.xml里面加入以下代码：1234&lt;style name=&quot;AnimBottom&quot; parent=&quot;@android:style/Animation&quot;&gt; &lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@anim/push_bottom_in&lt;/item&gt; &lt;item name=&quot;android:windowExitAnimation&quot;&gt;@anim/push_bottom_out&lt;/item&gt;&lt;/style&gt; AnimBottom就是该动画的名字，在需要设置的地方直接调用R.style.AnimBottom就可以使用该动画了。 二、弹出动画步骤和上面的一样，anim下面： inuptodown.xml（弹入） 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;translate android:duration=&quot;500&quot; android:fromYDelta=&quot;-100%&quot; android:toYDelta=&quot;0&quot; /&gt;&lt;/set&gt; outdowntoup.xml（弹出） 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;translate android:duration=&quot;500&quot; android:fromYDelta=&quot;0&quot; android:toYDelta=&quot;-100%&quot; /&gt;&lt;/set&gt; styles.xml中：1234&lt;style name=&quot;AnimationFade&quot;&gt; &lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@anim/inuptodown&lt;/item&gt; &lt;item name=&quot;android:windowExitAnimation&quot;&gt;@anim/outdowntoup&lt;/item&gt; &lt;/style&gt; 使用的话和上面的是一样的。","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Genymotion下载慢或者下载失败的解决办法","slug":"Genymotion下载慢或者下载失败的解决办法","date":"2016-09-26T13:18:06.000Z","updated":"2018-01-16T02:37:56.382Z","comments":true,"path":"2016/09/26/Genymotion下载慢或者下载失败的解决办法/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/09/26/Genymotion下载慢或者下载失败的解决办法/","excerpt":"","text":"以前使用 genymotion 的时候都是等了很久才能下载完成，并且有时候会下载失败。今天在网上无意间看到了一个方法解决这个问题。现在记录下，备用。 ##办法如下： 首先点击界面上的 + 号（Add）按钮，选择你要下载的模拟器虚拟机版本，点击下载（一定要走这一步，不然会影响下面的步骤） 然后到C:\\Users\\你的用户名\\AppData\\Local\\Genymobile\\ 下面打开genymotion.log文件，找到 Downloading file 后面的 http 开头的链接，复制到迅雷开始下载； 下载完成之后拷贝这个文件（称为文件1）到 C:\\Users\\你的用户名 \\AppData\\Local\\Genymobile\\Genymotion\\ova 。然后你会看到里面已经存在一个 .ova 文件，（这个文件就是你刚才第一步选择下载的那个，自动下载的，暂且称为文件2），把文件2的文件名复制到文件 1上（记得删除文件2）。 重新打开 genymotion 模拟器，和刚才步骤1一样的步骤，你会发现很快就可以加载好了，接下来就可以愉快的使用模拟器了 最近在网上找到了其他的方法，试了下，也是可以的，有兴趣可点击下面链接查看mac电脑解决方案 windows解决方案 更新：如果说你已经下载好了一个版本的模拟器 .ova 文件，那么如果你可以对其进行备份，下次直接拷贝进 C:\\Users\\你的用户名 \\AppData\\Local\\Genymobile\\Genymotion\\ova 目录下面就可以了。这样就省去了再次下载的时间。","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"},{"name":"模拟器","slug":"模拟器","permalink":"https://github.com/smartsean/smartsean.github.io/tags/模拟器/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":" Mac下Android Studio JDK的配置","slug":"Mac下Android-Studio-JDK的配置","date":"2016-09-15T10:20:39.000Z","updated":"2018-01-16T02:24:19.743Z","comments":true,"path":"2016/09/15/Mac下Android-Studio-JDK的配置/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/09/15/Mac下Android-Studio-JDK的配置/","excerpt":"","text":"前言之前没有用过mac版的android studio，mac上的jdk安装和win不太一样，win上安装的时候是可以选择安装路径的，但是在mac上是没选择安装路径的，这点比较难搞。在今天打开项目的时候提示项目的jdk路径不对，在网上一顿找，最终终于知道怎么设置了 获取jdk安装的路径： 终端运行：/usr/libexec/java_home 我的运行效果： 然后打开Android Studio—&gt;file—&gt;other Setting —&gt;Default Project Setting,在出现的页面选择到你机器上出现的路径就行了。 2016-9-15特此记录！","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"ionic开发webApp---百度定位","slug":"ionic开发webApp-百度定位","date":"2016-08-19T02:18:34.000Z","updated":"2018-02-02T06:15:00.972Z","comments":true,"path":"2016/08/19/ionic开发webApp-百度定位/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/08/19/ionic开发webApp-百度定位/","excerpt":"","text":"反思好久没写博客了，最近比较忙，这段时间忙的差不多了，博客一定要坚持写下去。 概述最近客户提出了新的需求：在客户操作节点增加地图定位，以便获取操作节点时候的地理位置，经过调研发现，官方提供的有个叫cordova-plugin-geolocation的插件，在ios上可以直接使用，但是在天朝因为某些网络原因不能给正常使用，并且在网上很少能够搜索到关于这方面的文章，就去在github上找一些第三方提供的插件去实现。这里记录一下，防止以后走弯路。 1. 申请百度的秘钥 百度秘钥申请地址2. 安装插件：ionic plugin add https://github.com/mrwutong/cordova-qdc-baidu-location --variable API_KEY=&quot;&lt;API_KEY&gt;&quot; 3. 使用方法在需要获取位置信息的地方直接使用以下代码:12345baidu_location.getCurrentPosition(function ( message ) &#123; console.debug(message); &#125;, function ( message ) &#123; console.debug(message); &#125;); 第一个函数是成功的回调，第二个是失败的回调。 ##切记 在安装了插件之后，千万记得要先ionic remove platform android，然后再执行ionic platform add android命令，不然插件不能正确的执行，事实上，每一次修改插件的内容，都要执行上面的两个操作，才能使插件正常运行 如果你使用sdk23版本进行打包的，你就要注意了，在最新的android6.0上面，和以前的权限授权机制已经不同，如果使用23版本的进行打包，在android6.0以上的手机上运行不会给出获取地理位置权限的弹窗，务必改为23以下的版本进行编译 获取成功的话，默认是只给出经纬度信息的，如果要获取定位的地址的具体信息，要在插件里面的BaiduLocation.java文件把 12改为```option.setIsNeedAddress(true); 默认返回的是一个字符串，对于现在json这么流行的情况下，当然是获得json格式的数据比较让人喜欢，这个时候坐着已经替我们封装好了，只需要在BaiduLocation.java文件中把PluginResult pluginResult = new PluginResult(PluginResult.Status.OK, sb.toString());改为PluginResult pluginResult = new PluginResult(PluginResult.Status.OK, json.toString());，你就可以获得一个json格式的字符串了 最后上面的内容大多数是在github上找到的，这里只是写上了自己遇到的一些问题，分享出来，这里附上github地址：GitHub地址","categories":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Ionic/"}],"tags":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Ionic/"}],"keywords":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Ionic/"}]},{"title":"Ionic Css简介与基本布局","slug":"Ionic-Css简介与基本布局","date":"2016-06-21T10:05:26.000Z","updated":"2018-02-02T06:15:00.974Z","comments":true,"path":"2016/06/21/Ionic-Css简介与基本布局/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/06/21/Ionic-Css简介与基本布局/","excerpt":"","text":"Ionic Css简介与基本布局Ionic简介 Ionic属于hybrid开发模式，本质上是讲移动web应用与浏览器打包，优点是采用标准的web技术进行开发，避免了不同平台原声开发体系的学习，上手快、效率高。缺点是性能上有一定的损失 ionic是一个强大的混合式/hybrid_HTML5移动开发框架，特点是使用标准的HTML、CSS、JavaScript，开发跨平台（目前支持：Android、IOS）的原生App应用。 ionic主要包括三个部分： CSS框架 提供原生质感的CSS样式模拟，ionic这个部分使用了ionicons图标样式库 JavaScript提供移动Web应用开发框架，ionic基于AngularJS基础框架开发，因此自然的遵循AngularJS框架的约束，此外，ionic使用AngularJS UI Router实现前端路由 命令行/CLI命令行工具集用来简化应用程序的开发、构造和仿真运行，ionic命令行工具使用了Cordova，依赖于平台SDK（Android&amp;IOS）实现将移动web项目打包成原生App 由于ionic使用了HTML5和CSS3的一些新规范，所以要求ios7+/Android4.1+，在低版本上使用ionic开发的应用的时候，有时会出现问题 CSS框架 可以直接使用ionic的CSS框架，直接在HTML中引入ionic.css就可以。ionic的CSS框架提供了预定义的CSS类，来帮助我们快速构建适用于手机端的UI，ionic的预定义CSS类主要分为下面四个方面： 基本布局类 ionic将手机页面的布局模式基本抽象为三块：头部、内容和尾部，基本布局类提供了这几个区域的CSS类 颜色和图标类ionic定义了几个配色方案CSS类，并使用ionicons提供的字体图标类 界面组件类ionic定义了丰富的界面组件CSS类，让HTML元素看起来像移动平台的UI组件 格栅系统类和Bootstrap一样，ionic也提供了格栅系统，不过ionic的实现是基于CSS3的flexBox模型，更为灵活 布局模式在APP开发中，通常一个页面分为三个部分 标题/header 标题总是位于屏幕顶部 内容/content 内容区占据除了标题和页脚的区域 页脚/footer 页脚区总是位于屏幕的底部ionic使用以下的CSS类声明区域的性质： .bar.bar-header 声明元素为标题区 .bar.bar-footer 声明元素为页脚区 .content声明元素为内容区定高条块：.bar样式.bar将元素声明为屏幕上绝对定义和块状区域，具有固定的高度（44px）：123456789101112131415161718&lt;any class=&quot;bar&quot;&gt;.....&lt;any&gt;``` 一旦元素应用了.bar样式，就可以继续选用两类预定义样式来进一步声明元素及其内容的外观：1. 同级样式---同级样式与.bar应用在同一元素上，声明元素的位置、配色等2. 下级样式---下级样式只能应用在.bar的子元素上，声明子元素的大小等特征具体的样式如下：![这里写图片描述](http://img.blog.csdn.net/20160621180215881)#### .bar：位置ionic使用以下样式定义条块的位置：- .bar-header -置顶- .bar-subheader -header之下置顶- .bar-footer - 置底- .bar-subfooter -footrt之上置顶比如腾讯App中，可以看到三个条块：标题、副标题、页脚![这里写图片描述](http://img.blog.csdn.net/20160621180245928)#### .bar :嵌入子元素在ionic中，有三种.bar子元素的样式是自定义的：- **标题文字** -对包含的标题文字的元素使用.title样式，通常是使用h1元素；一般是居中显示的标题 …12- **按钮** --对用作按钮的元素，应用.button样式，通常使用button或者a元素作为按钮，注意按钮将使用.bar的配色方案；经常会用到，比如顶部标题栏右侧的+号按钮，或者顶部左侧的返回按钮 …12- **工具栏** - 工具栏包含一组按钮，对用作工具栏的元素，应用.button-bar样式，通常使用div元素作为工具栏;一般较少用到 …12345678#### .bar :嵌入input一种常见的UI模式是在标题栏中嵌入搜索栏，比如说大众点评如下：![这里写图片描述](http://img.blog.csdn.net/20160621180311273)在.bar元素中嵌入input元素，需要注意两点：1. 在条块元素上应用.item-input-insert样式2. 将input包裹在应用.item-input-wrapper样式的元素内这是因为在ionic的实现中，.bar中的input样式定义如下：比如以下代码： 北京 ``` 内容：.content和.scroll-contentionic预定义了两个内容容器样式： .content - 流式定位，内容元素在文档流中按顺序定位 .scroll-content - 决定定位，内容元素占满整个屏幕这两个样式都可以使用以下样式进一步确定位置及其范围","categories":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Ionic/"}],"tags":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Ionic/"}],"keywords":[{"name":"Ionic","slug":"Ionic","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Ionic/"}]},{"title":"JAVA 生成JSON格式数据","slug":"JAVA-生成JSON格式数据","date":"2016-06-03T03:25:21.000Z","updated":"2018-01-16T02:19:59.524Z","comments":true,"path":"2016/06/03/JAVA-生成JSON格式数据/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/06/03/JAVA-生成JSON格式数据/","excerpt":"","text":"简介刚开始学习android的时候，使用的是第三方的数据库，平时调用网络请求都是通过封装好的api进行数据请求的，之后到了公司进行webApp开发，使用js来操作json格式的数据简直不能再爽了，但是自己还是有点不太清楚java获得json对象，今天花了一会时间研究下，作为记录，以后忘的时候记起来方便些。 初始数据12345678&#123; &quot;cmd&quot;: &quot;service&quot;, &quot;parameters&quot;: &#123; &quot;engineerId&quot;: &quot;10015&quot;, &quot;name&quot;:&quot;Sean&quot; &#125;&#125; java代码中生成json对象的代码：12345678910111213JSONObject jsonObject = new JSONObject();//最终得到的JSON对象Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();map.put(&quot;engineerId&quot;,&quot;10015&quot;);map.put(&quot;name&quot;,&quot;Sean&quot;);JSONObject jsonObject1 = new JSONObject(map);try &#123; jsonObject.put(&quot;cmd&quot;,&quot;service&quot;); jsonObject.put(&quot;parameters&quot;,jsonObject1); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; 经过上面的步骤便可以生成个Json对象，可以在请求服务器的时候使用。","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android---open failed: ENOENT (No such file or directory) 错误","slug":"Android-open-failed-ENOENT-No-such-file-or-directory-错误","date":"2016-04-22T08:44:22.000Z","updated":"2018-01-16T02:19:05.652Z","comments":true,"path":"2016/04/22/Android-open-failed-ENOENT-No-such-file-or-directory-错误/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/04/22/Android-open-failed-ENOENT-No-such-file-or-directory-错误/","excerpt":"","text":"今天我把sd卡下面的应用目录删掉了，然后重新打开应用的时候，出现上面的错误，说是找不到该file，然后不断的加log调试，最后通过查找资料了解到新建File的时候不支持新建两级目录，也就是只能一层一层的创建。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940/** * @param bitmap:图片的bitmap * @param src：要保存到本地的路径 * @param bitName：要保存到本地的文件名 * @throws IOException */ private void saveBitmap(Bitmap bitmap,String src, String bitName) throws IOException &#123; File pictureFileDir = new File(src); if (!pictureFileDir.exists()) &#123; pictureFileDir.mkdir(); &#125; File pictureFileDirImage = new File(pictureFileDir.getAbsolutePath()+&quot;/images/&quot;); if (!pictureFileDirImage.exists()) &#123; pictureFileDirImage.mkdir(); &#125; File picFile = new File(pictureFileDirImage.getAbsolutePath()+&quot;/&quot;+ bitName); if(!picFile.exists())&#123; picFile.createNewFile(); &#125; FileOutputStream out; try&#123; out = new FileOutputStream(picFile); if(bitmap.compress(Bitmap.CompressFormat.JPEG, 90, out)) &#123; out.flush(); out.close(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"},{"name":"异常","slug":"异常","permalink":"https://github.com/smartsean/smartsean.github.io/tags/异常/"}],"keywords":[]},{"title":" Android控件之CheckBox换图标、焦点问题","slug":"Android控件之CheckBox换图标、焦点问题","date":"2016-04-19T11:17:32.000Z","updated":"2018-01-16T02:17:30.567Z","comments":true,"path":"2016/04/19/Android控件之CheckBox换图标、焦点问题/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/04/19/Android控件之CheckBox换图标、焦点问题/","excerpt":"","text":"今天在实现ListView点击事件的时候，发现点击之后没有效果，查了下，发现是Item布局里面的CheckBox控件截取了焦点，只需要把CheckBox中的focusable属性设置为false即可 1android:focusable=&quot;false&quot; 由于系统自带的图标满足不了我的需求，然后又重新定制了属于自己的图标，过程如下：1、在Drawable下面新建文件，比如checkbox_for_addpending_0.xml 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- 点击之后的图标 --&gt; &lt;item android:state_checked=&quot;true&quot; android:drawable=&quot;@mipmap/priority_no&quot; /&gt; &lt;!-- 点击之前的图标 --&gt; &lt;item android:state_checked=&quot;false&quot; android:drawable=&quot;@mipmap/priority_no_normal&quot; /&gt;&lt;/selector&gt; 2、在布局文件中直接设置button属性指向这个文件即可第一种写法：1234567&lt;CheckBox android:id=&quot;@+id/cb_is_finish_in_lv&quot; android:focusable=&quot;false&quot; android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:button=&quot;@drawable/checkbox_for_addpending_0&quot; /&gt; 如果按照上面的写法，你设置的图标不会再CheckBox的正中间显示，会垂直居中，而不会水平居中，并且当你点击的CheckBox控件的时候，会有灰色背景显示，很难看，按照下面的这种写法就可以解决上面的问题： 第二种写法：12345678910111213&lt;CheckBox android:id=&quot;@+id/cb_is_finish_in_lv&quot; android:focusable=&quot;false&quot; android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:button=&quot;@null&quot; android:drawableLeft=&quot;@drawable/checkbox_for_addpending_0&quot; android:drawablePadding=&quot;10dip&quot; android:paddingBottom=&quot;10dip&quot; android:paddingLeft=&quot;10dip&quot; android:paddingTop=&quot;10dip&quot; android:background=&quot;#FFFFFF&quot; /&gt; 按照上面写的话也有一定的弊端，比如我想更换CheckBox图片按钮的时候，就会在左侧加上你更新的图片，会很丑陋，这个时候可以使用第一种写法，然后把背景设置的和父布局一致，让CheckBox向右移动下，也可以实现第二种写法的效果。 特此记录。","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"【转】Android面试题精选","slug":"【转】Android面试题精选","date":"2016-04-18T14:43:54.000Z","updated":"2018-01-16T02:16:04.681Z","comments":true,"path":"2016/04/18/【转】Android面试题精选/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/04/18/【转】Android面试题精选/","excerpt":"","text":"1.Android dvm 的进程和Linux的进程，应用程序的进程是否为同一个概念：答：dvm是dalivk虚拟机。每一个android应用程序都在自己的进程中运行，都拥有一个dalivk虚拟机实例。而每一个dvm都是在linux的一个进程。所以说可以认为是同一个概念。2.android的动画有哪几种？他们的特点和区别是什么？答：两种，一种是tween动画，一种是frame动画。tween动画，这种实现方式可以使视图组件移动，放大或缩小以及产生透明度的变化。frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。3.handler进制的原理：答：android提供了handler和looper来满足线程间的通信。Handler先进先出原则。looper用来管理特定线程内对象之间的消息交换（message Exchange）. 1)looper:一个线程可以产生一个looper对象，由它来管理此线程里的message queue(消息队列) 2)handler:你可以构造一个handler对象来与looper沟通，以便push新消息到messagequeue里；或者接收looper（从messagequeue里取出）所送来的消息。 3)messagequeue:用来存放线程放入的消息。 4)线程：UI thread 通常就是main thread,而android启动程序时会为它建立一个message queue.4.android view的刷新：答：Android中对View的更新有很多种方式，使用时要区分不同的应用场合。我感觉最要紧的是分清：多线程和双缓冲的使用情况。 1).不使用多线程和双缓冲 这种情况最简单了，一般只是希望在View发生改变时对UI进行重绘。你只需在Activity中显式地调用View对象中的invalidate()方法即可。系统会自动调用 View的onDraw()方法。 2).使用多线程和不使用双缓冲 这种情况需要开启新的线程，新开的线程就不好访问View对象了。强行访问的话会报：android.view.ViewRoot$CalledFromWrongThreadException：Only the originalthread that created a view hierarchy can touch its views. 这时候你需要创建一个继承了android.os.Handler的子类，并重写handleMessage(Messagemsg)方法。android.os.Handler是能发送和处理消息的，你需要在Activity中发出更新UI的消息，然后再你的Handler（可以使用匿名内部类）中处理消息（因为匿名内部类可以访问父类变量，你可以直接调用View对象中的invalidate()方法 ）。也就是说：在新线程创建并发送一个Message，然后再主线程中捕获、处理该消息。 3).使用多线程和双缓冲 Android中SurfaceView是View的子类，她同时也实现了双缓冲。你可以定义一个她的子类并实现SurfaceHolder.Callback接口。由于实现SurfaceHolder.Callback接口，新线程就不需要android.os.Handler帮忙了。SurfaceHolder中lockCanvas()方法可以锁定画布，绘制玩新的图像后调用unlockCanvasAndPost(canvas)解锁（显示），还是比较方便得。 5.说说mvc模式的原理，它在android中的运用:答：android的官方建议应用程序的开发采用mvc模式。何谓mvc？ mvc是model,view,controller的缩写，mvc包含三个部分： l模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。 2视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。 3控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，想用用户出发的相关事件，交给m哦得了处理。 android鼓励弱耦合和组件的重用，在android中mvc的具体体现如下： 1)视图层（view）：一般采用xml文件进行界面的描述，使用的时候可以非常方便的引入，当然，如何你对android了解的比较的多了话，就一定 可以想到在android中也可以使用JavaScript+html等的方式作为view层，当然这里需要进行Java和javascript之间的通 信，幸运的是，android提供了它们之间非常方便的通信实现。 2)控制层（controller）：android的控制层的重 任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写代码，要通过activity交割model业务逻辑层处理， 这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。 3)模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。 6.Activity的生命周期:答：onCreate: 在这里创建界面，做一些数据 的初始化工作 onStart: 到这一步变成用户可见不可交互的 onResume:变成和用户可交互 的，(在activity 栈系统通过栈的方式管理这些个Activity的最上面，运行完弹出栈，则回到上一个Activity) onPause: 到这一步是可见但不可交互的，系统会停止动画 等消耗CPU 的事情从上文的描述已经知道，应该在这里保存你的一些数据,因为这个时候你的程序的优先级降低，有可能被系统收回。在这里保存的数据，应该在 onstop: 变得不可见，被下一个activity覆盖了onDestroy: 这是activity被干掉前最后一个被调用方法了，可能是外面类调用finish方法或者是系统为了节省空间将它暂时性的干掉 7.让Activity变成一个窗口：答：Activity属性设定：有时候会做个应用程序是漂浮在手机主界面的。这个只需要在设置下Activity的主题theme,即在Manifest.xml定义Activity的地方加一句：android :theme=”@android:style/Theme.Dialog”如果是作半透明的效果：android:theme=”@android:style/Theme.Translucent”8.Android中常用的五种布局:答：LinearLayout线性布局；AbsoluteLayout绝对布局；TableLayout表格布局；RelativeLayout相对布局；FrameLayout帧布局；9.Android的五种数据存储方式：答：sharedPreferences；文件；SQLite；contentProvider；网络10.请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系：答：Handler获取当前线程中的looper对象，looper用来从存有Message的Message Queue里取出message，再由Handler进行message的分发和处理。11.AIDL的全称是什么?如何工作?能处理哪些类型的数据?答：AIDL(AndroidInterface Definition Language)android接口描述语言12.系统上安装了多种浏览器，能否指定某浏览器访问指定页面？请说明原由：答：通过直接发送Uri把参数带过去，或者通过manifest里的intentfilter里的data属性。代码如下： Intent intent = new Intent();Intent.setAction(“android.intent.action.View”);Uri uriBrowsers = Uri.parse(“http://www.sina.com.cn”);Intent.setData(uriBrowsers);//包名、要打开的activity intent.setClassName(“com.android.browser”,”com.android.browser.BrowserActivity”);startActivity(intent);13.什么是ANR,如何避免？答：ANR的定义：在android上，如果你的应用程序有一段时间响应不移灵敏，系统会向用户提示“应用程序无响应”（ANR：application Not Responding）对话框。因此，在程序里对响应性能的设计很重要，这样，系统不会显示ANR给用户。如何避免：首先来研究下为什么它会在android的应用程序里发生和如何最佳构建应用程序来避免ANR. android应用程序通常是运行在一个单独的线程（例如：main）里，这就意味你的应用程序所做的事情如果在主线程里占用了大长时间的话，就会引发ANR对话框，因为你的应用程序并没有给自己机会来处理输入事件或者Intent广播。 因此，运行在主线程里的任何访求都尽可能少做事情。特别是，activity应该在它的关键生命周期方法（onCreate()和onResume()）里尽可能少的去作创建操作。潜在的耗时操作，例如网络或数据库操作，或者高耗时的计算如改变位图尺寸，应该在子线程里（或者以数据库操作为例，通过异步请求的方式）来完成。然而，不是说你的主线程阻塞在那里等待子线程的完成—也不是调用Thread.wait()或者Thread.sleep()。替代的方法是：主线程应该为子线程提供一个Handler,以便完成时能够提交给主线程。以这种方式设计你的应用程序，将能保证你的主线程保持对输入的响应性并能避免由5秒输入事件的超时引发的ANR对话框。这种做法应该在其它显示UI的线程里效仿，因为它们都受相同的超时影响。 IntentReceiver执行时间的特殊限制意味着它应该做：在后台里做小的、琐碎的工作，如保存设定或注册一个Notification。和在主线程里调用的其它方法一样，应用程序应该避免在BroadcastReceiver里做耗时的操作或计算，但也不是在子线程里做这些任务（因为BroadcastReceiver的生命周期短），替代的是，如果响应Intent广播需要执行一个耗时的动作的话，应用程序应该启动一个Service。顺便提及一句，你也应该避免在Intent Receiver里启动一个Activity，因为它会创建一个新的画面，并从当前用户正在运行的程序上抢夺焦点。如果你的应用程序在响应Intent广播时需要向用户展示什么，你应该使用Notification Manager来实现。 一般来说，在应用程序里，100到200ms是用户能感知阻滞的时间阈值，下面总结了一些技巧来避免ANR,并有助于让你的应用程序看起来有响应性。 如果你的应用程序为响应用户输入正在后台工作的话，可以显示工作的进度（ProgressBar和ProgressDialog对这种情况来说很有用）。特别是游戏，在子线程里做移动的计算。如果你的程序有一个耗时的初始化过程的话，考虑可以显示一个Splash Screen或者快速显示主画面并异步来填充这些信息。在这两种情况下，你都应该显示正在进行的进度，以免用户认为程序被冻结了。 14.什么情况会导致Force Close？如何避免？能否捕获导致其的异常？答：如空指针等可以导致ForceClose;可以看Logcat，然后找到对应的程序代码来解决错误。15.横竖屏切换时候的activity的生命周期：答：1） 新建一个activity,并把各个生命周期打印出来2） 运行activity，得到如下信息：onCreate()àonStart()àonResume()à 3) 按ctrl+F12切换成横屏时 onSaveInstanceState()à onPause()à onStop()à onDestroy()à onCreate()à onStart()à onRestoreInstanceState()à onResume()à 4) 再按ctrl+f12切换成竖屏时，发现打印了两次相同的Log onSaveInstanceState()à onPause()à onStop()à onDestroyà onCreate()à onStart()à onRestoreInstanceState()à onResume()à onSaveInstanceState()à onPause()à onStop()à onDestroyà onCreate()à onStart()à onRestoreInstanceState()à onResume()à 5) 修改AndroidManifest.xml，把该Activity添加android:configChanges=“orientation”,执行步骤3 onSaveInstanceState()à onPause()à onStop()à onDestroy()à onCreate()à onStart()à onRestoreInstanceState()à onResume()à 6) 修改AndroidManifest.xml，把该Activity添加android:configChanges=“orientation”,执行步骤4,发现不会再打印相同信息，但多打印了一行onConfigChanged onSaveInstanceState()à onPause()à onStop()à onDestroy()à onCreate()à onStart()à onRestoreInstanceState()à onResume()à onConfigurationChanged()à 7) 把步骤5的android:configChanges=“orientation”改成 android:configChanges=“orientation|keyboradHidden”,执行步骤3，就只打印onConfigChanged onConfigurationChanged()à 8) 把步骤5的android:configChanges=“orientation”改成android:configChanges=“orientation|keyboradHidden”,执行步骤4 onConfigurationChanged()à onConfigurationChanged()à 总结：1） 不设置activity的android:configChanges时,切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次。2） 设置activity的android:configChanges=“orientation”时, 切屏会重新调用各个生命周期，切横屏、竖屏时都只会执行一次，但是竖屏最后多打印一条onConfigurationChanged()3） 设置activity的android:configChanges=“orientation|keyboardHidden”时,切屏不会重新调用各个生命周期，只会执行onConfigurationChanged(),横屏一次，竖屏两次再总结下整个activity的生命周期：1） 当前activity产生事件弹出Toast和AlertDialog的时候Activity的生命周期不会有改变2） Activity运行时按下HOME键（跟被完全覆盖一样的）onSavaInstanceStateàonPauseàonStopà onRestartàonStartàonResumeà 3) 未被完全覆盖，只是失去焦点： onPauseà onResumeà16.如何将SQLite数据库(.db文件)与apk文件一起发布?答：可以将.db文件复制到Eclipse Android工程中的res aw目录中。所有在res aw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。可以将.db文件复制到res aw目录中17.如何将打开res aw目录中的数据库文件?答：在Android中不能直接打开res aw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。复制的基本方法是使用getResources().openRawResource方法获得res aw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。18.android 中有哪几种解析xml的类？官方推荐哪种？以及它们的原理和区别：答：XML解析主要有三种方式，SAX、DOM、PULL。常规在PC上开发我们使用Dom相对轻松些，但一些性能敏感的数据库或手机上还是主要采用SAX方 式，SAX读取是单向的，优点:不占内存空间、解析属性方便，但缺点就是对于套嵌多个分支来说处理不是很方便。而DOM方式会把整个XML文件加载到内存 中去，这里Android开发网提醒大家该方法在查找方面可以和XPath很好的结合如果数据量不是很大推荐使用，而PULL常常用在J2ME对于节点处 理比较好，类似SAX方式，同样很节省内存，在J2ME中我们经常使用的KXML库来解析。19.DDMS和TraceView的区别?答：DDMS是一个程序执行查看器，在里面可以看见线程和堆栈等信息，TraceView是程序性能分析器20.谈谈Android的IPC机制：答：IPC是内部进程通信的简称，是共享”命名管道”的资源。Android中的IPC机制是为了让Activity和Service之间可以随时的进行交互，故在Android中该机制，只适用于Activity和Service之间的通信，类似于远程方法调用，类似于C/S模式的访问。通过定义AIDL接口文件来定义IPC接口。Servier端实现IPC接口，Client端调用IPC接口本地代理。21.NDK是什么：答：NDK是一系列工具的集合 NDK提供了一系列的工具，帮助开发者迅速的开发C/C++的动态库，并能自动将so和java应用打成apk包 NDK集成了交叉编译器，并提供了相应的mk文件和隔离cpu，平台等的差异，开发人员只需简单的修改mk文件就可以创建出so22.描述一下android的系统架构：答：android系统架构分从下往上为Linux内核层、运行库、应用程序框架层和应用程序层。 Linux内核层：负责硬件的驱动程序、网络、电源、系统安全以及内存管理等功能。运行库和androidruntion：运行库：即c/c++函数库部分，大多数都是开放源代码的函数库，例如webkit，该函数库负责android网页浏览器的运行；例如标准的c函数库libc、openssl、sqlite等，当然也包括支持游戏开发的2dsgl和3dopengles，在多媒体方面有mediaframework框架来支持各种影音和图形文件的播放与显示，如mpeg4、h.264、mp3、aac、amr、jpg和png等众多的多媒体文件格式。Androidruntion负责解释和执行生成的dalvik格式的字节码应用软件架构：java应用程序开发人员主要是使用该层封装好的api进行快速开发的。应用程序层：该层是java的应用程序层，android内置的googlemaps、email、IM、浏览器等，都处于该层，java开发人员工发的程序也处于该层，而且和内置的应用程序具有平等的地位，可以调用内置的应用程序，也可以替换内置的应用程序23.Activity 与 Task的启动模式有哪些，它们含义具体是什么?答：在一个activity中，有多次调用startActivity来启动另一个activity，要想只生成一个activity实例，可以设置启动模式。 一个activity有四种启动模式：standed,signleTop,singleTask,singleInstance Standed:标准模式，一调用startActivity()方法就会产生一个新的实例。 SingleTop:如果已经有一个实例位于activity栈顶，就不产生新的实例，而只是调用activity中的newInstance()方法。如果不位于栈顶，会产生一个新的实例。 singleTask:会在一个新的task中产生这个实例，以后每次调用都会使用这个，不会去产生新的实例了。 SingleInstance:这个和singleTask基本一样，只有一个区别：在这个模式下的activity实例所处的task中，只能有这个activity实例，不能有其他实例24.Application类的作用：答：API里的第一句是：Base class for those who need to maintain global application state 如果想在整个应用中使用全局变量，在java中一般是使用静态变量，public类型；而在android中如果使用这样的全局变量就不符合Android的框架架构，但是可以使用一种更优雅的方式就是使用Application context。 首先需要重写Application，主要重写里面的onCreate方法，就是创建的时候，初始化变量的值。然后在整个应用中的各个文件中就可以对该变量进行操作了。 启动Application时，系统会创建一个PID，即进程ID，所有的Activity就会在此进程上运行。那么我们在Application创建的时候初始化全局变量，同一个应用的所有Activity都可以取到这些全局变量的值，换句话说，我们在某一个Activity中改变了这些全局变量的值，那么在同一个应用的其他Activity中值就会改变25.说明onSaveInstanceState() 和 onRestoreInstanceState()在什么时候被调用：答：Activity的 onSaveInstanceState() 和 onRestoreInstanceState()并不是生命周期方法，它们不同于 onCreate()、onPause()等生命周期方法，它们并不一定会被触发。当应用遇到意外情况（如：内存不足、用户直接按Home键）由系统销毁一个Activity时，onSaveInstanceState()才会被调用。但是当用户主动去销毁一个Activity时，例如在应用中按返回键，onSaveInstanceState()就不会被调用。因为在这种情况下，用户的行为决定了不需要保存Activity的状态。通常onSaveInstanceState()只适合用于保存一些临时性的状态，而onPause()适合用于数据的持久化保存。 另外，当屏幕的方向发生了改变， Activity会被摧毁并且被重新创建，如果你想在Activity被摧毁前缓存一些数据，并且在Activity被重新创建后恢复缓存的数据。可以重写Activity的 onSaveInstanceState() 和 onRestoreInstanceState()方法。26.android的service的生命周期？哪个方法可以多次被调用：答：1)与采用Context.startService()方法启动服务有关的生命周期方法 onCreate() -&gt; onStart() -&gt; onDestroy() onCreate()该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，服务也只被创建一次。onStart() 只有采用Context.startService()方法启动服务时才会回调该方法。该方法在服务开始运行时被调用。多次调用startService()方法尽管不会多次创建服务，但onStart() 方法会被多次调用。onDestroy()该方法在服务被终止时调用。 2)与采用Context.bindService()方法启动服务有关的生命周期方法onCreate() -&gt; onBind() -&gt; onUnbind() -&gt; onDestroy() onBind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务绑定时被调用，当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。onUnbind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务解除绑定时被调用。如果先采用startService()方法启动服务,然后调用bindService()方法绑定到服务，再调用unbindService()方法解除绑定，最后调用bindService()方法再次绑定到服务，触发的生命周期方法如下：onCreate() -&gt;onStart() -&gt;onBind() -&gt;onUnbind()[重载后的方法需返回true] -&gt;onRebind()27.android的broadcast的生命周期：答：1)Broadcast receiver生命周期中仅有一个回调方法：void onReceive(Context curContext, Intent broadcastMsg)当接收器接收到一条broadcast消息，Android就会调用onReceiver(),并传递给它一个Intent对象，这个对象携带着那条broadcast消息。我们认为仅当执行这个方式时，Broadcast receiver是活动的；这个方法返回时，它就终止了。这就是Broadcast receiver的生命周期。 2)由于Broadcast receiver的生命周期很短，一个带有活动的Broadcast receiver的进程是受保护的，以避免被干掉；但是别忘了有一点，Android会在任意时刻干掉那些携带不再活动的组件的进程，所以很可能会造成这个问题。 3)解决上述问题的方案采用一个Service来完成这项工作，Android会认为那个进程中（Service所在的进程）仍然有在活动的组件。28.android view，surfaceview，glsurfaceview的区别：答：SurfaceView是从View基类中派生出来的显示类，直接子类有GLSurfaceView和VideoView，可以看出GL和视频播放以及Camera摄像头一般均使用SurfaceViewSurfaceView和View最本质的区别在于，surfaceView是在一个新起的单独线程中可以重新绘制画面而View必须在UI的主线程中更新画面。那么在UI的主线程中更新画面 可能会引发问题，比如你更新画面的时间过长，那么你的主UI线程会被你正在画的函数阻塞。那么将无法响应按键，触屏等消息。当使用surfaceView 由于是在新的线程中更新画面所以不会阻塞你的UI主线程。但这也带来了另外一个问题，就是事件同步。比如你触屏了一下，你需要surfaceView中thread处理，一般就需要有一个event queue的设计来保存touch event，这会稍稍复杂一点，因为涉及到线程同步。 所以基于以上，根据游戏特点，一般分成两类。 1)被动更新画面的。比如棋类，这种用view就好了。因为画面的更新是依赖于 onTouch 来更新，可以直接使用 invalidate。 因为这种情况下，这一次Touch和下一次的Touch需要的时间比较长些，不会产生影响。 2)主动更新。比如一个人在一直跑动。这就需要一个单独的thread不停的重绘人的状态，避免阻塞main UI thread。所以显然view不合适，需要surfaceView来控制。","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Java/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android Studio---定制属于自己的注解模板","slug":"Android-Studio-定制属于自己的注解模板","date":"2016-04-18T14:43:46.000Z","updated":"2018-01-16T02:13:40.426Z","comments":true,"path":"2016/04/18/Android-Studio-定制属于自己的注解模板/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/04/18/Android-Studio-定制属于自己的注解模板/","excerpt":"","text":"相信大家都很喜欢用注解这个功能吧，今天就介绍下如何在Android Studio中定制属于自己的注解模板吧：1、打开Android Studio的Settings，设置图如下：2、3、4、5、6、上述设置完毕就可以保存使用了，在函数上方直接输如cc就可以快速注解了。 我的自定义代码： 12345/** *$desc$ *@auther css *created at $date$ $time$ */ Over","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"},{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"https://github.com/smartsean/smartsean.github.io/tags/AndroidStudio/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android异常：ServiceConnection 泄露","slug":"Android异常：ServiceConnection-泄露","date":"2016-04-18T06:35:34.000Z","updated":"2018-01-16T02:12:12.834Z","comments":true,"path":"2016/04/18/Android异常：ServiceConnection-泄露/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/04/18/Android异常：ServiceConnection-泄露/","excerpt":"","text":"写了个service，用来播放提示音，当用户没有去处理并且提示音播放完毕的时候，发送一条Notification执行onDestory()方法，这个时候是直接销毁的方法，并没有调用unbindService去释放服务连接，那么就会出现 ServiceConnection 泄露的情况，虽然说不会影响程序的正常运行，但是还是解决掉比较好。 解决办法就是使用unbindService 解除绑定，限于我的特定情况，我在Activity中动态注册了一个广播接收器，然后在Service中当提示音播放完毕的时候发送一条广播，在Activity中接收，解除和Service的绑定。 有时间把整个程序弄到博客上来做个记录。//TODO 123456789101112131415161718192021222304-18 11:01:02.270 440-440/css.alarm.com.alarmdemo E/ActivityThread: Activity css.alarm.com.alarmdemo.PlayAlarmActivity has leaked ServiceConnection css.alarm.com.alarmdemo.PlayAlarmActivity$1@42efa448 that was originally bound here android.app.ServiceConnectionLeaked: Activity css.alarm.com.alarmdemo.PlayAlarmActivity has leaked ServiceConnection css.alarm.com.alarmdemo.PlayAlarmActivity$1@42efa448 that was originally bound here at android.app.LoadedApk$ServiceDispatcher.&lt;init&gt;(LoadedApk.java:979) at android.app.LoadedApk.getServiceDispatcher(LoadedApk.java:873) at android.app.ContextImpl.bindServiceAsUser(ContextImpl.java:1833) at android.app.ContextImpl.bindService(ContextImpl.java:1821) at android.content.ContextWrapper.bindService(ContextWrapper.java:503) at css.alarm.com.alarmdemo.PlayAlarmActivity.initView(PlayAlarmActivity.java:153) at css.alarm.com.alarmdemo.PlayAlarmActivity.onCreate(PlayAlarmActivity.java:47) at android.app.Activity.performCreate(Activity.java:5372) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1104) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2257) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2349) at android.app.ActivityThread.access$700(ActivityThread.java:159) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1316) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loop(Looper.java:176) at android.app.ActivityThread.main(ActivityThread.java:5419) at java.lang.reflect.Method.invokeNative(Native Method) at java.lang.reflect.Method.invoke(Method.java:525) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1209) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1025) at dalvik.system.NativeStart.main(Native Method)","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android组件之服务---Service","slug":"Android组件之服务-Service","date":"2016-04-17T11:44:33.000Z","updated":"2018-01-16T02:12:15.411Z","comments":true,"path":"2016/04/17/Android组件之服务-Service/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/04/17/Android组件之服务-Service/","excerpt":"","text":"—今天在做毕设的时候需要用到播放提示音，想了想，当需要提示的时候新建一个Service来播放提示音比较好，而且可以在响应事件中控制提示音的播放，就先专门弄了个小的例子来练下手，于是修改了下之前入门Service时候写的代码，实现一个简易的音乐播放。（这里使用的是MediaPlayer，如果是较短提示音的话使用SoundPool比较好） 什么是服务： 服务是Android中实现程序后台运行的解决方案，它非常适合用于去执行哪些不需要和用户交互而且还要求长期运行的任务，服务不依赖于任何界面，即使当程序被切换到后台，或者打开了另外一个程序，服务仍然能够保持正常运行，服务的优先级是高于Activity的，另外服务作为四大组件，在新建的时候一定要在AndroidManifest.xml文件中进行注册才能使用。服务运行环境： 服务不是独立运行在进程中的，而是依赖于创建该服务时所在的应用程序进程，当某个应用程序被杀掉时，所依赖于这个进程的服务也会被停止。 需要注意的是，服务不会自己开启线程，所有的代码都是默认运行在主线程当中的，也就是说，我们需要在服务的内部手动创建子线程，并在其中执行具体的任务，负责就可能出现子线程被阻塞的情况，可以用多线程编程解决，Android专门为我们提供了一个类---IntentService，可以创建异步的、可自动停止运行的服务。 常见的服务用途：后台放音乐，后台记录地理位置的改变，监听程序动作 常见使用服务的方式： 不和Activity绑定 启动：startService(Intent实例);Intent intent1 = new Intent(MainActivity.this,MyStartService.class);startService(intent1); 关闭：stopService(Intent实例);stopService(intent1); 启动和关闭的时候Intent实例必须是同一个，不然不能停止服务； 和Activity绑定完成Activity和Service间的通信 启动：bindService(Intent实例,ServiceConnection实例,BIND_AUTO_CREATE);Intent intent2 = new Intent(MainActivity.this,MyBindService.class);bindService(intent2, conn, BIND_AUTO_CREATE); 关闭：unbindService(conn);unbindService(conn); conn是ServiceConnection实例的实例，待会在代码中给出,需要注意的是，如果要活Service自动关闭，上面两种都可以使用stopSelf();但是如果既使用了startService又使用了bingService的话，就要同时调用stopService和ubBindService方法才能使服务的onDestory()执行； 今天正好用到下面通过一个小的简易音乐播放来演示下Activity和Service之间的通信：主要利用服务中的onBind方法，新建一个专门的Binder对象进行通信。1、建一个服务，用来定义一些播放的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package com.service.css.servicedemo;import android.app.Service;import android.content.Intent;import android.media.MediaPlayer;import android.os.Binder;import android.os.IBinder;import android.support.annotation.Nullable;import android.util.Log;import java.io.IOException;/** * Created by css on 2016/3/29. */public class MyBindService extends Service implements MediaPlayer.OnCompletionListener&#123; private MediaPlayer mediaPlayer; //实现MediaPlayer.OnCompletionListener接口的方法 @Override public void onCompletion(MediaPlayer mp) &#123; stopSelf(); &#125; //新建类同于回调 public class MyBinder extends Binder &#123; public MyBindService getService() &#123; //获得MyBindService，可以执行它的方法 return MyBindService.this; &#125; &#125; //用于传送Binder对象给Activity @Nullable @Override public IBinder onBind(Intent intent) &#123; Log.d(&quot;TAG&quot;, &quot;这里是 onBind&quot;); return new MyBinder(); &#125; //初始化的时候使用，对此绑定只执行一次 @Override public void onCreate() &#123; Log.d(&quot;TAG&quot;,&quot;这里是 onCreate&quot;); mediaPlayer = MediaPlayer.create(this, R.raw.alarm); mediaPlayer.setOnCompletionListener(this); //开始震动// vibrator = (Vibrator) getApplicationContext().getSystemService(Service.VIBRATOR_SERVICE); super.onCreate(); &#125; //初始化的时候使用，对此绑定执行多次， @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; if(!mediaPlayer.isPlaying())&#123; mediaPlayer.start(); &#125; return START_STICKY; &#125; //解绑定的时候执行的方法 @Override public boolean onUnbind(Intent intent) &#123; Log.d(&quot;TAG&quot;, &quot;这里是 onUnbind&quot;); return super.onUnbind(intent); &#125; //重写onDestroy方法 @Override public void onDestroy() &#123; Log.d(&quot;TAG&quot;, &quot;这里是 onDestroy&quot;); //停止 if(mediaPlayer.isPlaying())&#123; mediaPlayer.stop(); &#125; //释放 mediaPlayer.release(); super.onDestroy(); &#125; //播放 public void play() &#123; Log.d(&quot;TAG&quot;, &quot;播放&quot;); //如果不正在播放，则开始播放 if(!mediaPlayer.isPlaying())&#123; mediaPlayer.start(); &#125; &#125; //暂停 public void pause() &#123; Log.d(&quot;TAG&quot;, &quot;暂停&quot;); //暂停播放，下次点击播放可以接着暂停的地方播放 mediaPlayer.pause(); &#125; //停止 public void stop() &#123; Log.d(&quot;TAG&quot;, &quot;停止&quot;); //如果不为空，停止 if (mediaPlayer != null) &#123; mediaPlayer.stop(); try &#123; mediaPlayer.prepare();//stop后下次重新播放要首先进入prepared状态 mediaPlayer.seekTo(0);//须将播放时间设置到0；这样才能在下次播放是重新开始，否则会继续上次播放 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 2、主Activity中的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.service.css.servicedemo;import android.app.Activity;import android.content.ComponentName;import android.content.Intent;import android.content.ServiceConnection;import android.os.Bundle;import android.os.IBinder;import android.util.Log;import android.view.View;public class MainActivity extends Activity &#123; private MyBindService myBindService; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; //使用ServiceConnection，在Activity和Service连接、断开的时候执行操作； ServiceConnection conn = new ServiceConnection() &#123; //连接执行的操作 @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.d(&quot;TAG&quot;,&quot;service is onServiceConnected!&quot;); myBindService = ((MyBindService.MyBinder)service).getService(); &#125; //断开执行的操作 @Override public void onServiceDisconnected(ComponentName name) &#123; Log.d(&quot;TAG&quot;,&quot;service is onServiceDisconnected!&quot;); &#125; &#125;; //处理Button的点击事件(在布局文件中指定了onClick属性) public void doClick(View v) &#123; switch(v.getId()) &#123; //Activity和Service绑定 case R.id.bind: Intent intent2 = new Intent(MainActivity.this,MyBindService.class); bindService(intent2, conn, BIND_AUTO_CREATE); break; //播放操作 case R.id.play: myBindService.play(); break; //暂停操作 case R.id.pause: myBindService.pause(); break; //停止操作 case R.id.stop: myBindService.stop(); break; //解绑定操作 case R.id.unbind: unbindService(conn); myBindService = null; break; &#125; &#125;&#125; 对了，今天遇到了一个问题，在Activity绑定Service的操作可以在Activity的onCreate方法中直接进行，但是如果想要在Activity中播放音乐的话，不能把上面的myBindService.play();写在onCreate或者onResume中。 源码","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android震动---启动、循环、取消控制","slug":"Android震动-启动、循环、取消控制","date":"2016-04-16T07:17:00.000Z","updated":"2018-01-16T02:12:15.410Z","comments":true,"path":"2016/04/16/Android震动-启动、循环、取消控制/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/04/16/Android震动-启动、循环、取消控制/","excerpt":"","text":"今天在做闹钟Demo的时候，想加上闹钟到期提醒的时候实现震动功能，就上网大概查了下Android中震动的相关资料，总体来说还是蛮简单的。 Android中的Vibrator 类负责对手机震动的处理 导包：import android.os.Vibrator;加权限：&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt; 先大概介绍下常用的几个方法： 方法 描述 public void cancel() 取消震动 public boolean hasVibrator() 判断当前是否在震动 public void vibrate(long[] pattern, int repeat) 设置震动周期，如果repeat为-1则不循环震动，0表示一直震动 public void vibrate(long milliseconds) 打开震动，设置震动时长，1000为1秒 1、首先要获取到Vibrator的实例，这个和获取AlarmManger比较类似，获取系统服务，代码如下： 12private Vibrator vibrator=null;vibrator = ( Vibrator ) getApplication().getSystemService(Service.VIBRATOR_SERVICE); 2、开启震动，这里有两个方式，在上面给出，一个参数（不能设置循环）、多个参数（可设置循环） 1vibrator.vibrate(1000);//震动一秒 12//long型数组内的数组依次表示：等待1秒、震动2秒、等待3秒、震动4秒，0表示无限循环long型数组内定义的震动规则；如果是-1则表示不循环震动vibrator.vibrate( new long[]&#123;1000,2000,3000,4000&#125;,0); 需要说明的是，不管后边的是0、1、2、3等，都会先把Long型数组内的震动模式执行一遍，之后，如果是2，则表示把第一遍执行完之后把1000移除，循环{2000,3000,4000}这样，只不过是模式变为震动、等待、震动。。。 3、取消震动 12//取消该实例的震动vibrator.cancel(); 最后大家不要忘了加上相应的权限，还有记得运行的时候不要忘了在真机上运行，模拟器不支持震动。","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android res/raw 和 assets 使用","slug":"Android-res-raw-和-assets-使用","date":"2016-04-10T14:42:49.000Z","updated":"2018-01-16T02:12:15.409Z","comments":true,"path":"2016/04/10/Android-res-raw-和-assets-使用/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/04/10/Android-res-raw-和-assets-使用/","excerpt":"","text":"今天在研究通知栏的时候，不想用系统默认的提示音，就想着自定义提示音，了解到可以可以在项目中添加raw文件夹或者assets文件夹来存放音频，使用raw的话是放在res下面的，也就是说可以直接用过R.raw.xxx.mp3，获取到该音频。注意：但是该文件夹下的音频会被编译成二进制文件，不能直接打开 音频具体的新建方法： 下面是代码，说明下，我是为了图方便直接在BroadcastReceiver的onReceive方法里面发送Notification的，最好不要在onReceive方法里面做耗时操作。 1234567891011121314151617181920212223242526272829public class Receiver1 extends BroadcastReceiver &#123; NotificationManager manager; int notificationId = 0; @Override public void onReceive(Context context, Intent intent) &#123; Intent intent1 = new Intent(context,MainActivity.class);//启动Activity的Intent PendingIntent pintent = PendingIntent.getActivity(context,0,intent1,0); Notification.Builder builder = new Notification.Builder(context); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setTicker(&quot;Hello&quot;);//手机状态栏的提示 builder.setWhen(System.currentTimeMillis());//设置时间 builder.setContentTitle(&quot;通知栏通知&quot;); builder.setContentText(&quot;练习Notification&quot;); builder.setContentIntent(pintent);//点击之后的意图 builder.setSound(Uri.parse(&quot;android.resource://&quot; + context.getPackageName() + &quot;/&quot;+R.raw.sound));//自定义声音// builder.setDefaults(Notification.DEFAULT_SOUND);//设置声音 builder.setDefaults(Notification.DEFAULT_LIGHTS);//设置指示灯，，，，，指示灯个震动都需要配置权限 builder.setDefaults(Notification.DEFAULT_VIBRATE);//设置震动效果// builder.setDefaults(Notification.DEFAULT_ALL);//设置上面的三种效果 //Android4.1以上的版本用Notification notification = builder.build(); //Android4.1以下的版本用builder.getNotification(); manager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE); Notification notification = builder.build(); manager.notify(notificationId,notification); &#125;&#125; 文件在如下位置新建 assets 文件夹： 然后里面用到了一个 error.html 的 html 文件，用于在加载 webView 失败的时候展示给用户。 使用： 1webView.loadUrl(&quot;file:///android_asset/error.html&quot;); 这种方式可以加载assets目录下的网页，并且与网页有关的css，js，图片等文件也会的加载。 这样就可以使用了，是不是很简单呢？ 后续相同点两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制，这些文件将被打包到APK中应用使用。 不同点区别 一可能有的朋友会问了，既然两种方式都是不会被编译成二进制文件，而我们在引用音频文件的时候，使用的是 R.raw.xxx.mp3 这种方式，为什么在使用文件的时候要使用 webView.loadUrl(&quot;file:///android_asset/error.html&quot;); 这种方式？难道不能也使用 R.assets.errpr.html 这种方式来引用文件吗？ 要弄清这个问题，首先要明白第一个不同点： res/raw 中的文件会被映射到 R.java 文件中，访问的时候直接使用资源 ID 即 R.raw.xxx.mp3； assets 文件夹下的文件不会被映射到 R.java 中，访问的时候需要 AssetManager 类。 那么我们既然不能通过使用 R 文件的方式引用，我们可以通过使用绝对路径的方式去引用吗？ 答案是否定的！ 因为 apk 文件安装之后会放在 /data/app/ 目录下，以 apk 形式存在， asset/res 被绑定在 apk 里，并不会解压到 /data/data/你的应用包名 目录下去，所以我们无法直接获取到 assets 的绝对路径，因为它们根本就没有。 注意：下面的只能在已经 Root 的手机或者模拟器中可以看到 首先我们看下我们的手机在没安装 app 的情况下，data/app 文件夹下面有什么文件？ 现在我们来安装一下简书 App ： 我们发现，我们安装的 app 确实是出现在了 /data/app 文件夹下面。 这个时候如果你点开 /data/data/你的应用包名 文件夹查看的话，是看不到 assets 文件夹的，说明并没有解压到这里，所以就不能使用绝对路径去引用了。 system/app 系统自带的应用程序，无法删除。 data/app 用户程序安装的目录，有删除权限。安装时把apk文件复制到此目录。 data/data 存放应用程序的数据。 data/dalvik-cache 将 apk 中的 dex 文件安装到 dalvik-cache 目录下( dex 文件是 dalvik 虚拟机的可执行文件,其大小约为原始 apk 文件大小的四分之一)。 APP安装过程：复制APK安装包到data/app目录下，解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录，并data/data目录下创建对应的应用数据目录。 附录： res/anim/ XML文件，它们被编译进逐帧动画（frame by frame animation）或补间动画(tweened animation)对象 res/drawable/ .png、.9.png、.jpg文件，它们被编译进以下的Drawable资源子类型中： 要获得这种类型的一个资源，可以使用Resource.getDrawable(id) 位图文件 9-patches（可变尺寸的位图） 为了获取资源类型，使用mContext.getResources().getDrawable(R.drawable.imageId)注意：放在这里的图像资源可能会被aapt工具自动地进行无损压缩优化。比如，一个真彩色但并不需要256色的PNG可能会被转换为一个带调色板的8位PNG。这使得同等质量的图片占用更少的资源。所以我们得意识到这些放在该目录下的二进制图像在生成时可能会发生变化。如果你想读取一个图像位流并转换成一个位图(bitmap)，请把图像文件放在res/raw/目录下，这样可以避免被自动优化。 res/layout/ 被编译为屏幕布局(或屏幕的一部分)的XML文件。参见布局声明(Declaring Layout) res/values/ 可以被编译成很多种类型的资源的XML文件。注意: 不像其他的res/文件夹，它可以保存任意数量的文件，这些文件保存了要创建资源的描述，而不是资源本身。XML元素类型控制这些资源应该放在R类的什么地方,尽管这个文件夹里的文件可以任意命名，不过下面使一些比较典型的文件（文件命名的惯例是将元素类型包含在该名称之中）： array.xml 定义数组 colors.xml 定义color drawable和颜色的字符串值(color string values)。使用Resource.getDrawable()和Resources.getColor()分别获得这些资源。 dimens.xml定义尺寸值(dimension value)。使用Resources.getDimension()获得这些资源。 strings.xml定义字符串(string)值。使用Resources.getString()或者Resources.getText()获取这些资源。getText()会保留在UI字符串上应用的丰富的文本样式。 styles.xml 定义样式(style)对象。 res/xml/ 任意的XML文件，在运行时可以通过调用Resources.getXML()读取。 res/raw/ 直接复制到设备中的任意文件。它们无需编译，添加到你的应用程序编译产生的压缩文件中。要使用这些资源，可以调用Resources.openRawResource()，参数是资源的ID，即R.raw.somefilename。 区别 二另外需要我们注意的是： res/raw 不可以有目录结构，也就是说只能存放一级目录，不能再下面建立文件夹。 而 assets 则可以有目录结构，也就是 assets 目录下可以再建立任意深度和数量的文件夹 assets 下面文件的使用html文件如上面例子所示 其他文件获取 AssetManager12AssetManager assetManager =getAssets();InputStream is = assetManager.open(&quot;filename&quot;); 补充一下：在未知目录下有哪些文件，该去和获取这些文件的名称并把文件拷贝到目标目录中呢？（用于内置文件但不知道文件名称，需要筛选出想要的文件然后拷贝到目标目录中，推荐内置在assets文件夹中） res/raw目录：通过反射的方式得到R.java里面raw内部类里面所有的资源ID的名称，然后通过名称获取资源ID的值来读取我们想要的文件。（这个方法我没试过，有用过的同学麻烦发一段代码看看）。 assets目录：getAssets().list(“”);来获取assets目录下所有文件夹和文件的名称，再通过这些名称再读取我们想要的文件。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[]},{"title":"Android Studio常用快捷键及设置","slug":"Android Studio常用快捷键及设置","date":"2016-04-10T06:37:03.000Z","updated":"2018-01-15T14:17:33.531Z","comments":true,"path":"2016/04/10/Android Studio常用快捷键及设置/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/04/10/Android Studio常用快捷键及设置/","excerpt":"1.代码提示快捷键：1在Settings中搜索Class Name Completion","text":"1.代码提示快捷键：1在Settings中搜索Class Name Completion 2.显示代码行数1Settings-&gt;IDE Settings-&gt;Editor-&gt;Appearance-&gt;Show line numbers 3.修改代码字体大小1Settings-&gt;IDE Settings-&gt;Editor-&gt;Colors &amp; Fonts -&gt;Font-&gt;Save As-&gt;改个名字后才能改字体大小 4.错误修正提示列表1Keymap-&gt;Other-&gt;Show Intention Action：默认是Alt+Enter 5.快速Overried方法1Keymap-&gt;Main menu-&gt;Code-&gt;Override Methods：需要自己设定 6.鼠标悬浮显示doc1Settings-&gt;IDE Settings-&gt;Editor-&gt;Show quick doc on mouse move 7.智能感知不区分大小写1Settings-&gt;搜索Sensitive 修改case sensitive complement 的值为none 8.单行注释快捷键设置1Setting –KeyMap–Main menu –code – comment with line comment，右键添加自己的快捷注释单行 9.自动导包和删除包12Setting –Editor–General – Auto Import勾选Java下面的三个选项，并选择Insert imports on paste为All 我的博客：博客传送门 我的简书：简书传送门 我的CSDN：CSDN传送门 我的GitHub：GitHub传送门","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android 获得Bitmap","slug":"Android-获得Bitmap","date":"2016-04-06T01:53:16.000Z","updated":"2018-01-16T01:57:59.759Z","comments":true,"path":"2016/04/06/Android-获得Bitmap/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/04/06/Android-获得Bitmap/","excerpt":"","text":"1、 本地url转换为Bitmap 1234567891011121314/** * @param uri：图片的本地url地址 * @return Bitmap； */ private Bitmap decodeUriAsBitmap(Uri uri) &#123; Bitmap bitmap = null; try &#123; bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(uri)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); return null; &#125; return bitmap; &#125; 2、网络url转换为Bitmap 1234567891011121314151617181920212223242526272829/** * 根据图片的url路径获得Bitmap对象 * @param url * @return */private Bitmap decodeUriAsBitmapFromNet(String url) &#123; URL fileUrl = null; Bitmap bitmap = null; try &#123; fileUrl = new URL(url); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; try &#123; HttpURLConnection conn = (HttpURLConnection) fileUrl .openConnection(); conn.setDoInput(true); conn.connect(); InputStream is = conn.getInputStream(); bitmap = BitmapFactory.decodeStream(is); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return bitmap; &#125; 3、获取指定大小的 Bitmap /** * @param path:图片的物理路径 * @param display_width：设置图片的宽 * @param display_height：设置图片的高 * @return * @throws Exception */ private Bitmap decodeBitmap(String path,float display_width,float display_height) throws Exception { if (Float.compare(display_width,0.0f) == 0 || Float.compare(display_width,0.0f) == 0) { throw new Exception(&quot;图片的宽高均不能为0！&quot;); } BitmapFactory.Options op = new BitmapFactory.Options(); //inJustDecodeBounds //If set to true, the decoder will return null (no bitmap), but the out… op.inJustDecodeBounds = true; Bitmap bmp = BitmapFactory.decodeFile(path, op); //获取尺寸信息 //获取比例大小 int wRatio = (int)Math.ceil(op.outWidth/display_width); int hRatio = (int)Math.ceil(op.outHeight/display_height); //如果超出指定大小，则缩小相应的比例 if(wRatio &gt; 1 &amp;&amp; hRatio &gt; 1){ if(wRatio &gt; hRatio){ op.inSampleSize = wRatio; }else{ op.inSampleSize = hRatio; } } op.inJustDecodeBounds = false; bmp = BitmapFactory.decodeFile(path, op); return bmp; }","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"},{"name":"工具","slug":"工具","permalink":"https://github.com/smartsean/smartsean.github.io/tags/工具/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android组件之广播（Broadcast）","slug":"Android组件之广播（Broadcast）","date":"2016-03-29T14:22:51.000Z","updated":"2018-01-16T01:50:30.315Z","comments":true,"path":"2016/03/29/Android组件之广播（Broadcast）/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/03/29/Android组件之广播（Broadcast）/","excerpt":"","text":"四大组件之广播（Broadcast）最近学习了安卓四大组件之广播的用法。下面简单的总结下： 广播其实是一种信息的传递，主要分为标准广播和有序广播。下面举例描述下， 广播分类标准广播在我们的日常工作中，如果单位要告诉全体员工周末全体加班，只需要给全体员工发一个邮件出去，这样员工就能收到周末加班的邮件，就可以在周末来加班了，这种方式是全体员工都能收到，不能被截断，这就是标准广播；特点： 1. 同级别接收先后是随机的（无序的） 2. 级别低的后接收到广播 3. 接收器不能截断广播的继续传播，也不能处理广播 4. 同级别动态注册（代码中注册）高于静态注册（AndroidManifest中注册） 有序广播有些时候，单位的老大并不想直接给全体员工都发邮件，那么邮件走向可能就是这样的情况，老大—总经理—副总经理—项目经理等等，这样加班的信息是根据职位的高低（广播的优先级）一级一级的传递的，到每一级都可以被继续传递或者停止传递，所以这种信息是有可能被截断的这就是有序广播。特点： 同级别接收是随机的 能截断广播的继续传播，高级别的接收到广播之后，可以截断传播，是通过intent-filter中的priority声明的，范围是-1000到1000 能接收广播。也可以处理广播 同级别动态注册（代码中注册）高于静态注册（AndroidManifest中注册）广播接收器的注册注册广播一般有两种方式1. 在代码中注册（动态注册）顾名思义，就是在代码中注册的，比如在一个button的点击事件中点击时：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.css.sean.broadcasttest;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.net.ConnectivityManager;import android.net.NetworkInfo;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; private IntentFilter intentFilter;//用于处理过滤特定的intent private NetworkChangeReceiver networkChangeReceiver;//广播接收器 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); intentFilter = new IntentFilter(); //指定过滤器的action，这里传入的是网络状态发生改变时发出的广播 intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;); networkChangeReceiver = new NetworkChangeReceiver(); registerReceiver(networkChangeReceiver, intentFilter);//注册广播 &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(networkChangeReceiver);//用完之后取消注册 &#125; //用于监听网络状态的广播接收器 private class NetworkChangeReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; //ConnectivityManager是系统服务类，专门用来管理网络连接的 ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo(); if (networkInfo != null &amp;&amp; networkInfo.isAvailable()) &#123; Toast.makeText(MainActivity.this, &quot;网络状态可用！&quot;, Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(MainActivity.this, &quot;网络状态不可用！&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;&#125; 2. 在配置文件AndroidManifest中注册（静态注册）动态注册时必须程序在运行时才能注册的，有一定的局限性，如果我们需要在程序还没启动的时候就可以接收到注册的广播，就需要静态注册了，下面用接收开机启动开举例：首先创建一个广播类：123456public class BootCompleteReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context,&quot;开机启动广播&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125; 然后再配置文件中注册：12345&lt;receiver android:name=&quot;.BootCompleteReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;&gt;&lt;/action&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 发送广播广播接收器不仅可以接收系统发出的广播，也可以接收自定义的广播。 发送标准广播1234//创建一个intent，带有参数就是Filter的actionIntent intent = new Intent(&quot;com.sean.css.MY_BROADCAST&quot;);//发送广播sendBroadcast(intent); 是不是很简单，只需要两行代码，但是别忘了，这只是发出的广播，还要去写一个广播接收器去接受这个广播，然后去执行的操作，并且大家intent是可以传递数据的，当然也可以在intent中加入参数进行传递，这样就可以在广播接收器中拿到这个参数了 发送有序广播1234//创建一个intent，带有参数就是Filter的actionIntent intent = new Intent(&quot;com.sean.css.MY_BROADCAST&quot;);//发送广播sendOrderBroadcast(intent,null); 看起来和发送普通广播也差不多，主要就是在发送的时候方法变了，并且参数也变成了两个，第二个参数是与权限有关的字符串，前面说过，有序广播是有顺序的，所以是涉及到多个广播接收器的，只需要在我们注册广播接收器的时候加入以下代码：123456//动态注册 intentFilter.setPriority(100); //静态注册 &lt;intent-filter android:priority=&quot;200&quot;&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;&gt;&lt;/action&gt; &lt;/intent-filter&gt; 这样priority为200的会先收到广播，然后priority为100的后收到广播，如果先收到的广播在执行完自己操作后执行abortBroadcast()；那么优先级为100的就收不到该广播了。 本地广播前面我们发出的广播，不仅仅是我们自己的程序可以收到，其他的应用程序也可以收到，这样的话有可能会引起一定的安全问题，比如其他的应用程序可以一直向我们的程序发送垃圾广播，干扰我们程序的正常运行。幸好Android中有一个本地广播的机制，如果使用本地广播管理，那么只能在本地接收、发送广播。使用起来非常方便，只需要在发送或者接收的时候调用LocalBroadcastManager就行了，比如：1234//发送localBroadcastManager.sendBroadcast(inetnt);//接收localBroadcastManager.registerReceiver(localReceiver,intentFilter); 注意事项BroadcastReceiver的生命周期只有10秒左右，不能再里面做一些耗时的操作，如果要做耗时的操作，应该通过发送Intent给Service，由Service来完成耗时操作，并且不能在BroadcastReceiver中使用子线程 我在博客园的小例子：广播实现强制下线","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"异步任务处理---AsyncTask","slug":"异步任务处理-AsyncTask","date":"2016-03-29T14:19:32.000Z","updated":"2018-01-16T01:49:35.787Z","comments":true,"path":"2016/03/29/异步任务处理-AsyncTask/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/03/29/异步任务处理-AsyncTask/","excerpt":"","text":"今天学习了AsyncTask的基本用法，现在进行一个总结： 首先要知道为什么异步任务： 1、Android单线程模型2、 耗时的操作要放在非主线程中进行，避免主线程堵塞 其次要知道AsyncTask的作用： 1、在子线程中更新UI2、封装、简化异步操作 接下来看下AsyncTask的基本用法： 由于AsyncTask是一个抽象类，所以如果我们想使用它，就必须创建一个子类去继承它，在继承时我们必须为AsyncTask类指定三个泛型参数，如果传入Void，则表示不传入参数 1、Params：在执行时传入要传入的参数，可用于在后台任务中使用2、Progress：后台任务执行时，如果需要在界面上显示当前的进度，则使用指定的泛型作为进度单位3、Result：当任务执行执行完毕后，如果需要对结果进行返回，使用这里指定的泛型作为返回值类型 然后我们需要构建AsyncTask子类的回调方法： onPrexecute()执行后台操作前调用，一般执行初始化操作，在doInBackground方法前执行 doInBackground(Params…)必须重写，在这里执行异步任务；耗时操作写在这里，可调用publishProgress(Progress…)方法返回当前的执行进度 onProgressUpdate(Progress…)当在doInBackground调用doInBackground()后很快被调用对UI操作，这个可以不写（没有在doInBackground中调用） onPostExecute(Result)：当doInBackground方法结束执行，系统自动调用该方法，接收的值就是doInBackground最后返回的值； 说下使用AsyncTask的注意事项 1、必须在UI线程中创建AsyncTask实例2、必须在UI线程中调用AsyncTask的execute()方法3、重写的四个方法是系统自动调用的，不要手动去调用4、每个AsyncTask只能被执行一次，多次调用将会引发异常 下面开始实例：使用AsyncTask加载图片首选我们创建布局：image.xml用于显示图片IMageView和加载进度ProgressBar 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:padding=&quot;16dp&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/image&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;ProgressBar android:id=&quot;@+id/progrssBar&quot; android:visibility=&quot;gone&quot; android:layout_centerInParent=&quot;true&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/RelativeLayout&gt; 新建活动ImageTest 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.asynctask.css.asynctask;import android.app.Activity;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.AsyncTask;import android.os.Bundle;import android.view.View;import android.widget.ImageView;import android.widget.ProgressBar;import java.io.BufferedInputStream;import java.io.IOException;import java.net.URL;//手动导入import java.io.InputStream;import java.net.URLConnection;/** * Created by css on 2016/3/28. */public class ImageTest extends Activity &#123; private ImageView mImageView; private ProgressBar mProgressBar; MyAsynvTask mtask; //定义静态的String类型的URL用于存储要加载图片的地址 private static String URL = &quot;http://pic.mmfile.net/2013/08/1315595G7-2.jpg&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.image); mImageView = (ImageView) findViewById(R.id.image); mProgressBar = (ProgressBar) findViewById(R.id.progrssBar); //当调用execute之后，进行异步操作 mtask = new MyAsynvTask(); mtask.execute(URL); &#125;// 新建内部类MyAsynvTask继承AsyncTask，设置传递进去的参数，// 1、第一个参数表示加载图片的地址，所以传入String，// 2、第二个参数表示不需要显示返回进度，使用Void，// 3、第三个参数表示最后返回Bitmap class MyAsynvTask extends AsyncTask&lt;String,Void,Bitmap&gt; &#123;// 1、系统调用该方法，对异步操作进行初始化操作，这里显示ProgressBar @Override protected void onPreExecute() &#123; super.onPreExecute(); mProgressBar.setVisibility(View.VISIBLE); &#125;// 2、开始真正的异步操作处理，都在子线程中处理，放置任意的耗时操作，最后返回指定的类型 @Override protected Bitmap doInBackground(String... params) &#123; String url = params[0];//可以传递不止一个参数进来，以数组的形式存在，取出对应的URL Bitmap bitmap = null; URLConnection connection ; //定义网络连接对象 InputStream is; //用于获取数据的输入流 //访问网络的费时操作 try &#123; connection = new URL(url).openConnection(); //此处需要手动导入URL包，获取网络连接对象 is = connection.getInputStream(); //获取输入流 BufferedInputStream bis = new BufferedInputStream(is); //加入睡眠时间，晚点执行// try &#123;// Thread.sleep(3000);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; //使用BitmapFactory的decodeStream方法可以很方便的把bis输入流转换为Bitmap bitmap = BitmapFactory.decodeStream(bis); is.close();//关闭输入流 bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //将bitmap作为返回值传递到onPostExecute中，在onPostExecute进行UI更新 return bitmap; &#125;// 3、运行在主线程，任意进行UI操作onPostExecute在本方法中操作UI，把图像设置到ImageView @Override protected void onPostExecute(Bitmap bitmap) &#123; super.onPostExecute(bitmap); mProgressBar.setVisibility(View.GONE); //隐藏ProgressBar mImageView.setImageBitmap(bitmap); //显示图片 &#125; &#125;&#125; 写完活动之后立马注册活动，养成好习惯； 1&lt;activity android:name=&quot;.ImageTest&quot;&gt;&lt;/activity&gt; 最后在主活动里面点击Button实现加载图片，剩下的点击Button就省略了，很简单。看下运行效果：1、MainActivity主界面 2、加载过程中ProgressBar显示界面 3、加载成功图片显示界面 最后说下AsyncTask的取消： AsyncTaskc是通过线程池执行的，如果前面的线程没有执行完，再去点击开启一个新的线程的时候就会出现空白，即新线程并没有执行，而是等待上一个线程执行完之后才开始执行的；那么怎么解决这个问题呢？ 需要通过让AsyncTask的声明周期和activity的声明周期保持一致，在activity的onpause方法中加入如下代码： 123456789@Override protected void onPause() &#123; super.onPause(); if (mTask != null &amp;&amp; mTask.getStatus() == AsyncTask.Status.RUNNING) &#123; //cancel方法只是将AsyncTask标记为cancel状态，并不是真正的取消线程的执行 mTask.cancel(true); &#125; &#125; 仅仅写这些事不够的，因为.cancel方法只是对该线程进行标示，并没有取消该线程，还要加上下面的代码 1234if(isCancelled())&#123; break;&#125; 具体的参考代码，下载地址：AsyncTask小例子","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]},{"title":"Android UI模板设计---TopBar(标题栏)","slug":"Android-UI模板设计-TopBar-标题栏","date":"2016-03-29T14:18:04.000Z","updated":"2018-01-16T01:46:28.368Z","comments":true,"path":"2016/03/29/Android-UI模板设计-TopBar-标题栏/","link":"","permalink":"https://github.com/smartsean/smartsean.github.io/2016/03/29/Android-UI模板设计-TopBar-标题栏/","excerpt":"","text":"之前在郭神的书上看到了自定义控件这个概念，今天在慕课网又接触了自定义模板，今天就把学习到的自定义TopBar模板的总结写在这里。 自定义主要分为三步： 设置自定义模板需要的属性 在java代码中实现我们的自定义模板 在布局文件中引用自定义模板 1. 设置自定义模板需要的属性 首先新建项目TopBar，在res的values目录下新建一个xml文件topba_atts，用来设置我们自定义模板需要的属性，xml代码里面resources下通过declare-styleable来声明，告诉系统这是我们声明的属性，declare-styleable下的attr声明我们需要属性的名称name和引用的资源的类型format；代码如下：123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;Topbar&quot;&gt; &lt;!--设置标题栏属性--&gt; &lt;attr name=&quot;titleText&quot; format=&quot;string&quot;&gt;&lt;/attr&gt; &lt;attr name=&quot;titleTextSize&quot; format=&quot;dimension&quot;&gt;&lt;/attr&gt; &lt;attr name=&quot;titleTextColor1&quot; format=&quot;color&quot;&gt;&lt;/attr&gt; &lt;!--设置左侧显示属性，可以设置为图片什么的--&gt; &lt;attr name=&quot;leftText&quot; format=&quot;string&quot;&gt;&lt;/attr&gt; &lt;attr name=&quot;leftTextColre&quot; format=&quot;color&quot;&gt;&lt;/attr&gt; &lt;attr name=&quot;leftBackground&quot; format=&quot;reference|color&quot;&gt;&lt;/attr&gt; &lt;!--设置右侧显示属性，可以设置为图片什么的--&gt; &lt;attr name=&quot;rightText&quot; format=&quot;string&quot;&gt;&lt;/attr&gt; &lt;attr name=&quot;rightTextColre&quot; format=&quot;color&quot;&gt;&lt;/attr&gt; &lt;attr name=&quot;rightBackground&quot; format=&quot;reference|color&quot;&gt;&lt;/attr&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; Topbar需要的属性定义完毕，下面是java代码中实现。 2. 在java代码中实现我们的自定义模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139package com.udmodel.css.topbar;import android.content.Context;import android.content.res.TypedArray;import android.graphics.drawable.Drawable;import android.util.AttributeSet;import android.view.Gravity;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.RelativeLayout;import android.widget.TextView;/** * Created by css on 2016/3/27. */public class Topbar extends RelativeLayout &#123; //定义我们要用到控件 private Button leftButton,rightButton; private TextView tvtitle; //声明控件属性，和在values下面的topbar_atts.xml中的对应 private int titleTextColor1; private String titleText; private float titleTextSize; private int leftTextColor; private Drawable leftBackground; private String leftText; private int rightTextColor; private Drawable rightBackground; private String rightText; //定义控件的布局属性 private LayoutParams leftParams,rightParams,titleParams; //仿照系统实现onclick事件的方法，实现自定义模板内控件的点击事件 //用于映射调用者传进来的topbarClickListener接口 private topbarClickListener listener; //定义接口，实现两个方法 public interface topbarClickListener&#123; public void leftClick(); public void rightClick(); &#125; //创建一个方法给调用者，调用者可以传递进来匿名内部类实现 public void setOnTopbarClickListener(topbarClickListener listener) &#123; this.listener = listener; &#125; public Topbar(Context context, AttributeSet attrs) &#123; super(context, attrs); //获取我们定义的xml文件 TypedArray topBarAtts = context.obtainStyledAttributes(attrs,R.styleable.Topbar); titleTextColor1 = topBarAtts.getColor(R.styleable.Topbar_titleTextColor1, 0); titleText = topBarAtts.getString(R.styleable.Topbar_titleText); titleTextSize = topBarAtts.getDimension(R.styleable.Topbar_titleTextSize, 0); leftTextColor =topBarAtts.getColor(R.styleable.Topbar_leftTextColor, 0); leftBackground = topBarAtts.getDrawable(R.styleable.Topbar_leftBackground); leftText = topBarAtts.getString(R.styleable.Topbar_leftText); rightTextColor =topBarAtts.getColor(R.styleable.Topbar_rightTextColor, 0); rightBackground = topBarAtts.getDrawable(R.styleable.Topbar_rightBackground); rightText = topBarAtts.getString(R.styleable.Topbar_rightText); //避免浪费资源，避免因为缓存造成的错误 topBarAtts.recycle(); //实例化控件 leftButton = new Button(context); rightButton = new Button(context); tvtitle = new TextView(context); //把获取到的属性赋值给我们的控件 leftButton.setTextColor(leftTextColor); leftButton.setBackground(leftBackground); leftButton.setText(leftText); rightButton.setTextColor(rightTextColor); rightButton.setBackground(rightBackground);//该方法必须在API16以上才可以用 rightButton.setText(rightText); tvtitle.setTextColor(titleTextColor1); tvtitle.setText(titleText); tvtitle.setTextSize(titleTextSize); tvtitle.setGravity(Gravity.CENTER); setBackgroundColor(0xffffff00);//设置Topbar的背景色 //给左边Button添加属性，然后添加到View中 leftParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); //定义左侧按钮的宽高属性 leftParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT, TRUE);//制定左对齐的规则 addView(leftButton, leftParams);//添加到View中 //给右边Button添加属性，然后添加到View中 rightParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); rightParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT, TRUE); addView(rightButton, rightParams); //给中间的TextView添加属性，然后添加到View中 titleParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.MATCH_PARENT); titleParams.addRule(RelativeLayout.CENTER_IN_PARENT, TRUE);//居中对齐 addView(tvtitle, titleParams); //在leftButton和rightButton的OnClick事件中去调用该接口的两个方法 leftButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; listener.leftClick(); &#125; &#125;); rightButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; listener.rightClick(); &#125; &#125;); &#125; //自定义方法控制左侧button的显示吗，调用者只用传入值来选择true可用，false不可用消失 public void setLeftButtonIsvisiable(boolean flag) &#123; if(flag) &#123; leftButton.setVisibility(View.VISIBLE); &#125; else &#123; leftButton.setVisibility(View.GONE); &#125; &#125;&#125; 3. 在布局文件中引用自定义模板 代码如下：1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:custom=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; custom:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; tools:context=&quot;com.udmodel.css.topbar.MainActivity&quot; tools:showIn=&quot;@layout/activity_main&quot;&gt; &lt;com.udmodel.css.topbar.Topbar android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; android:id=&quot;@+id/topbar&quot; custom:leftBackground=&quot;@color/colorAccent&quot; custom:leftText=&quot;Back&quot; custom:leftTextColor=&quot;#FFFFFF&quot; custom:rightBackground=&quot;@color/colorAccent&quot; custom:rightText=&quot;more&quot; custom:rightTextColor=&quot;#FFFFFF&quot; custom:titleText=&quot;自定义标题&quot; custom:titleTextColor1=&quot;#123412&quot; custom:titleTextSize=&quot;10sp&quot; &gt;&lt;/com.udmodel.css.topbar.Topbar&gt;&lt;/RelativeLayout&gt; 下面这句在AS中可以直接在最后写res-auto，但是如果在eclipse中就需要写全包名，具体是引用第三方的名称空间(NameSpace),定义为custom，然后通过custom找到我们定义的属性1xmlns:custom=&quot;http://schemas.android.com/apk/res-auto&quot; 下面的@color/colorAccent是在values下面的color下面有个自定义颜色，直接引用，如果没有，新建一个，颜色自己选1custom:leftBackground=&quot;@color/colorAccent&quot; 最后，我们在代码中展示自定义的模板，并且验证功能； 123456789101112131415161718192021@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //获得topbar Topbar topbar = (Topbar) findViewById(R.id.topbar); //利用Topbar类中的方法来重写点击事件 topbar.setOnTopbarClickListener(new Topbar.topbarClickListener() &#123; @Override public void leftClick() &#123; Toast.makeText(MainActivity.this,&quot;left&quot;,Toast.LENGTH_SHORT).show(); &#125; @Override public void rightClick() &#123; Toast.makeText(MainActivity.this,&quot;right&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;); //设置左侧的Button不可见 topbar.setLeftButtonIsvisiable(false); 效果图：1、未点击Button，左侧Button隐藏 2、点击右侧Button，提示Toast 下载地址：自定义Topbar下载","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/tags/Android/"},{"name":"自定义View","slug":"自定义View","permalink":"https://github.com/smartsean/smartsean.github.io/tags/自定义View/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://github.com/smartsean/smartsean.github.io/categories/Android/"}]}]}